// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Copyright 2025 Oxide Computer Company

/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8)
            .offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = (core::ptr::addr_of_mut!((*this).storage) as *mut u8)
            .offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8
                <= self.storage.as_ref().len()
        );
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(
        this: *const Self,
        bit_offset: usize,
        bit_width: u8,
    ) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8
                <= core::mem::size_of::<Storage>()
        );
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8
                <= self.storage.as_ref().len()
        );
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(
        this: *mut Self,
        bit_offset: usize,
        bit_width: u8,
        val: u64,
    ) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8
                <= core::mem::size_of::<Storage>()
        );
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _BOOL_ALIGNMENT: u32 = 1;
pub const _CHAR_ALIGNMENT: u32 = 1;
pub const _SHORT_ALIGNMENT: u32 = 2;
pub const _INT_ALIGNMENT: u32 = 4;
pub const _FLOAT_ALIGNMENT: u32 = 4;
pub const _FLOAT_COMPLEX_ALIGNMENT: u32 = 4;
pub const _LONG_ALIGNMENT: u32 = 8;
pub const _LONG_LONG_ALIGNMENT: u32 = 8;
pub const _DOUBLE_ALIGNMENT: u32 = 8;
pub const _DOUBLE_COMPLEX_ALIGNMENT: u32 = 8;
pub const _LONG_DOUBLE_ALIGNMENT: u32 = 16;
pub const _LONG_DOUBLE_COMPLEX_ALIGNMENT: u32 = 16;
pub const _POINTER_ALIGNMENT: u32 = 8;
pub const _MAX_ALIGNMENT: u32 = 16;
pub const _ALIGNMENT_REQUIRED: u32 = 1;
pub const _CACHE_LINE_SHIFT: u32 = 6;
pub const _CACHE_LINE_SIZE: u32 = 64;
pub const _LONG_LONG_ALIGNMENT_32: u32 = 4;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const _FILE_OFFSET_BITS: u32 = 64;
pub const _XOPEN_VERSION: u32 = 3;
pub const __EXT1_VISIBLE: u32 = 0;
pub const _DTRACE_VERSION: u32 = 1;
pub const REG_LABEL_PC: u32 = 0;
pub const REG_LABEL_SP: u32 = 1;
pub const REG_LABEL_BP: u32 = 2;
pub const REG_LABEL_RBX: u32 = 3;
pub const REG_LABEL_R12: u32 = 4;
pub const REG_LABEL_R13: u32 = 5;
pub const REG_LABEL_R14: u32 = 6;
pub const REG_LABEL_R15: u32 = 7;
pub const REG_LABEL_MAX: u32 = 8;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const WCHAR_MAX: u32 = 2147483647;
pub const WINT_MAX: u32 = 2147483647;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const WCHAR_MIN: i32 = -2147483648;
pub const WINT_MIN: i32 = -2147483648;
pub const _MODF8: &[u8; 1] = b"\0";
pub const _MODF16: &[u8; 1] = b"\0";
pub const _PRId: &[u8; 2] = b"d\0";
pub const _PRIi: &[u8; 2] = b"i\0";
pub const _PRIo: &[u8; 2] = b"o\0";
pub const _PRIu: &[u8; 2] = b"u\0";
pub const _PRIx: &[u8; 2] = b"x\0";
pub const _PRIX: &[u8; 2] = b"X\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNdFAST16: &[u8; 2] = b"d\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNiFAST16: &[u8; 2] = b"i\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNoFAST16: &[u8; 2] = b"o\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNuFAST16: &[u8; 2] = b"u\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNxFAST16: &[u8; 2] = b"x\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const SCNX8: &[u8; 4] = b"hhX\0";
pub const SCNXLEAST8: &[u8; 4] = b"hhX\0";
pub const SCNXFAST8: &[u8; 4] = b"hhX\0";
pub const SCNX16: &[u8; 3] = b"hX\0";
pub const SCNXLEAST16: &[u8; 3] = b"hX\0";
pub const SCNX32: &[u8; 2] = b"X\0";
pub const SCNXFAST16: &[u8; 2] = b"X\0";
pub const SCNXLEAST32: &[u8; 2] = b"X\0";
pub const SCNXFAST32: &[u8; 2] = b"X\0";
pub const SCNX64: &[u8; 3] = b"lX\0";
pub const SCNXLEAST64: &[u8; 3] = b"lX\0";
pub const SCNXFAST64: &[u8; 3] = b"lX\0";
pub const SCNXPTR: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNXMAX: &[u8; 3] = b"lX\0";
pub const _PRIdID: &[u8; 2] = b"d\0";
pub const _PRIiID: &[u8; 2] = b"i\0";
pub const _PRIoID: &[u8; 2] = b"o\0";
pub const _PRIxID: &[u8; 2] = b"x\0";
pub const _PRIuID: &[u8; 2] = b"u\0";
pub const _PRIXID: &[u8; 2] = b"X\0";
pub const _SCNdID: &[u8; 2] = b"d\0";
pub const _SCNiID: &[u8; 2] = b"i\0";
pub const _SCNoID: &[u8; 2] = b"o\0";
pub const _SCNxID: &[u8; 2] = b"x\0";
pub const _SCNuID: &[u8; 2] = b"u\0";
pub const _SCNXID: &[u8; 2] = b"X\0";
pub const _PRIdWC: &[u8; 2] = b"d\0";
pub const _PRIiWC: &[u8; 2] = b"i\0";
pub const _PRIoWC: &[u8; 2] = b"o\0";
pub const _PRIxWC: &[u8; 2] = b"x\0";
pub const _PRIuWC: &[u8; 2] = b"u\0";
pub const _PRIXWC: &[u8; 2] = b"X\0";
pub const _SCNdWC: &[u8; 2] = b"d\0";
pub const _SCNiWC: &[u8; 2] = b"i\0";
pub const _SCNoWC: &[u8; 2] = b"o\0";
pub const _SCNxWC: &[u8; 2] = b"x\0";
pub const _SCNuWC: &[u8; 2] = b"u\0";
pub const _SCNXWC: &[u8; 2] = b"X\0";
pub const _MUTEX_MAGIC: u32 = 19800;
pub const _SEMA_MAGIC: u32 = 21325;
pub const _COND_MAGIC: u32 = 17238;
pub const _RWL_MAGIC: u32 = 21079;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const ULONG_MAX: i32 = -1;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const ULLONG_MAX: i32 = -1;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const P_MYID: i32 = -1;
pub const FD_SETSIZE: u32 = 65536;
pub const _NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const DST_GB: u32 = 7;
pub const DST_RUM: u32 = 8;
pub const DST_TUR: u32 = 9;
pub const DST_AUSTALT: u32 = 10;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const ITIMER_REALPROF: u32 = 3;
pub const SEC: u32 = 1;
pub const MILLISEC: u32 = 1000;
pub const MICROSEC: u32 = 1000000;
pub const NANOSEC: u32 = 1000000000;
pub const __CLOCK_REALTIME0: u32 = 0;
pub const CLOCK_VIRTUAL: u32 = 1;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 2;
pub const CLOCK_REALTIME: u32 = 3;
pub const CLOCK_MONOTONIC: u32 = 4;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 5;
pub const CLOCK_HIGHRES: u32 = 4;
pub const CLOCK_PROF: u32 = 2;
pub const CLOCK_MAX: u32 = 6;
pub const TIMER_RELTIME: u32 = 0;
pub const TIMER_ABSTIME: u32 = 1;
pub const KSTAT_STRLEN: u32 = 31;
pub const KSTAT_TYPE_RAW: u32 = 0;
pub const KSTAT_TYPE_NAMED: u32 = 1;
pub const KSTAT_TYPE_INTR: u32 = 2;
pub const KSTAT_TYPE_IO: u32 = 3;
pub const KSTAT_TYPE_TIMER: u32 = 4;
pub const KSTAT_NUM_TYPES: u32 = 5;
pub const KSTAT_FLAG_VIRTUAL: u32 = 1;
pub const KSTAT_FLAG_VAR_SIZE: u32 = 2;
pub const KSTAT_FLAG_WRITABLE: u32 = 4;
pub const KSTAT_FLAG_PERSISTENT: u32 = 8;
pub const KSTAT_FLAG_DORMANT: u32 = 16;
pub const KSTAT_FLAG_INVALID: u32 = 32;
pub const KSTAT_FLAG_LONGSTRINGS: u32 = 64;
pub const KSTAT_READ: u32 = 0;
pub const KSTAT_WRITE: u32 = 1;
pub const KSTAT_DATA_CHAR: u32 = 0;
pub const KSTAT_DATA_INT32: u32 = 1;
pub const KSTAT_DATA_UINT32: u32 = 2;
pub const KSTAT_DATA_INT64: u32 = 3;
pub const KSTAT_DATA_UINT64: u32 = 4;
pub const KSTAT_DATA_LONG: u32 = 7;
pub const KSTAT_DATA_ULONG: u32 = 8;
pub const KSTAT_DATA_STRING: u32 = 9;
pub const KSTAT_DATA_LONGLONG: u32 = 3;
pub const KSTAT_DATA_ULONGLONG: u32 = 4;
pub const KSTAT_DATA_FLOAT: u32 = 5;
pub const KSTAT_DATA_DOUBLE: u32 = 6;
pub const KSTAT_INTR_HARD: u32 = 0;
pub const KSTAT_INTR_SOFT: u32 = 1;
pub const KSTAT_INTR_WATCHDOG: u32 = 2;
pub const KSTAT_INTR_SPURIOUS: u32 = 3;
pub const KSTAT_INTR_MULTSVC: u32 = 4;
pub const KSTAT_NUM_INTRS: u32 = 5;
pub const LOCK_HELD_VALUE: u32 = 255;
pub const PIL_MAX: u32 = 15;
pub const CLOCK_LEVEL: u32 = 10;
pub const LOCK_LEVEL: u32 = 10;
pub const DISP_LEVEL: u32 = 11;
pub const HIGH_LEVELS: u32 = 5;
pub const CPU_INTR_ACTV_HIGH_LEVEL_MASK: u32 = 63488;
pub const PTR24_LSB: u32 = 5;
pub const PTR24_MSB: u32 = 29;
pub const PTR24_ALIGN: u32 = 32;
pub const PTR24_BASE: u32 = 3758096384;
pub const _POSIX_VDISABLE: u32 = 0;
pub const _TTY_BUFSIZ: u32 = 2048;
pub const MAX_INPUT: u32 = 512;
pub const MAX_CANON: u32 = 256;
pub const CANBSIZ: u32 = 256;
pub const UID_NOBODY: u32 = 60001;
pub const GID_NOBODY: u32 = 60001;
pub const UID_UNKNOWN: u32 = 96;
pub const GID_UNKNOWN: u32 = 96;
pub const UID_DLADM: u32 = 15;
pub const UID_NETADM: u32 = 16;
pub const GID_NETADM: u32 = 65;
pub const UID_NOACCESS: u32 = 60002;
pub const MAX_TASKID: u32 = 999999;
pub const MAX_MAXPID: u32 = 999999;
pub const MAXEPHUID: u32 = 4294967292;
pub const FAMOUS_PID_SCHED: u32 = 0;
pub const FAMOUS_PID_INIT: u32 = 1;
pub const FAMOUS_PID_PAGEOUT: u32 = 2;
pub const FAMOUS_PID_FSFLUSH: u32 = 3;
pub const FAMOUS_PIDS: u32 = 4;
pub const DEFAULT_MAXPID: u32 = 30000;
pub const DEFAULT_JUMPPID: u32 = 0;
pub const MAXUID: u32 = 2147483647;
pub const MAXPROJID: u32 = 2147483647;
pub const MAXLINK: u32 = 32767;
pub const MINEPHUID: u32 = 2147483648;
pub const NMOUNT: u32 = 40;
pub const NOFILE: u32 = 20;
pub const NGROUPS_UMIN: u32 = 0;
pub const NGROUPS_UMAX: u32 = 1024;
pub const NGROUPS_OLDMAX: u32 = 32;
pub const NGROUPS_MAX_DEFAULT: u32 = 16;
pub const NZERO: u32 = 20;
pub const CMASK: u32 = 18;
pub const CDLIMIT: u32 = 2048;
pub const NBPS: u32 = 131072;
pub const NBPSCTR: u32 = 512;
pub const UBSIZE: u32 = 512;
pub const SCTRSHFT: u32 = 9;
pub const SYSNAME: u32 = 9;
pub const PREMOTE: u32 = 39;
pub const MAXPATHLEN: u32 = 1024;
pub const TYPICALMAXPATHLEN: u32 = 64;
pub const MAXSYMLINKS: u32 = 20;
pub const MAXNAMELEN: u32 = 256;
pub const MAXLINKNAMELEN: u32 = 32;
pub const NADDR: u32 = 13;
pub const PIPE_BUF: u32 = 5120;
pub const PIPE_MAX: u32 = 5120;
pub const MAXBSIZE: u32 = 8192;
pub const DEV_BSIZE: u32 = 512;
pub const DEV_BSHIFT: u32 = 9;
pub const MAXFRAG: u32 = 8;
pub const MAXOFF_T: u64 = 9223372036854775807;
pub const MAXOFFSET_T: u64 = 9223372036854775807;
pub const NCARGS32: u32 = 1048576;
pub const NCARGS64: u32 = 2097152;
pub const NCARGS: u32 = 2097152;
pub const FSHIFT: u32 = 8;
pub const FSCALE: u32 = 256;
pub const _AIO_LISTIO_MAX: u32 = 4096;
pub const _AIO_MAX: i32 = -1;
pub const _MQ_OPEN_MAX: i32 = -1;
pub const _MQ_PRIO_MAX: u32 = 32;
pub const _SEM_NSEMS_MAX: u32 = 2147483647;
pub const _SEM_VALUE_MAX: u32 = 2147483647;
pub const _CS_PATH: u32 = 65;
pub const _CS_LFS_CFLAGS: u32 = 68;
pub const _CS_LFS_LDFLAGS: u32 = 69;
pub const _CS_LFS_LIBS: u32 = 70;
pub const _CS_LFS_LINTFLAGS: u32 = 71;
pub const _CS_LFS64_CFLAGS: u32 = 72;
pub const _CS_LFS64_LDFLAGS: u32 = 73;
pub const _CS_LFS64_LIBS: u32 = 74;
pub const _CS_LFS64_LINTFLAGS: u32 = 75;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: u32 = 700;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: u32 = 701;
pub const _CS_XBS5_ILP32_OFF32_LIBS: u32 = 702;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: u32 = 703;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: u32 = 705;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: u32 = 706;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: u32 = 707;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: u32 = 708;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: u32 = 709;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: u32 = 710;
pub const _CS_XBS5_LP64_OFF64_LIBS: u32 = 711;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: u32 = 712;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: u32 = 713;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: u32 = 714;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: u32 = 715;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: u32 = 716;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: u32 = 800;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: u32 = 801;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: u32 = 802;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: u32 = 803;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: u32 = 804;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: u32 = 805;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: u32 = 806;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: u32 = 807;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: u32 = 808;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: u32 = 809;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: u32 = 810;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: u32 = 811;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: u32 = 812;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: u32 = 813;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: u32 = 814;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: u32 = 815;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: u32 = 816;
pub const _SC_ARG_MAX: u32 = 1;
pub const _SC_CHILD_MAX: u32 = 2;
pub const _SC_CLK_TCK: u32 = 3;
pub const _SC_NGROUPS_MAX: u32 = 4;
pub const _SC_OPEN_MAX: u32 = 5;
pub const _SC_JOB_CONTROL: u32 = 6;
pub const _SC_SAVED_IDS: u32 = 7;
pub const _SC_VERSION: u32 = 8;
pub const _SC_PASS_MAX: u32 = 9;
pub const _SC_LOGNAME_MAX: u32 = 10;
pub const _SC_PAGESIZE: u32 = 11;
pub const _SC_XOPEN_VERSION: u32 = 12;
pub const _SC_NPROCESSORS_CONF: u32 = 14;
pub const _SC_NPROCESSORS_ONLN: u32 = 15;
pub const _SC_STREAM_MAX: u32 = 16;
pub const _SC_TZNAME_MAX: u32 = 17;
pub const _SC_AIO_LISTIO_MAX: u32 = 18;
pub const _SC_AIO_MAX: u32 = 19;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 20;
pub const _SC_ASYNCHRONOUS_IO: u32 = 21;
pub const _SC_DELAYTIMER_MAX: u32 = 22;
pub const _SC_FSYNC: u32 = 23;
pub const _SC_MAPPED_FILES: u32 = 24;
pub const _SC_MEMLOCK: u32 = 25;
pub const _SC_MEMLOCK_RANGE: u32 = 26;
pub const _SC_MEMORY_PROTECTION: u32 = 27;
pub const _SC_MESSAGE_PASSING: u32 = 28;
pub const _SC_MQ_OPEN_MAX: u32 = 29;
pub const _SC_MQ_PRIO_MAX: u32 = 30;
pub const _SC_PRIORITIZED_IO: u32 = 31;
pub const _SC_PRIORITY_SCHEDULING: u32 = 32;
pub const _SC_REALTIME_SIGNALS: u32 = 33;
pub const _SC_RTSIG_MAX: u32 = 34;
pub const _SC_SEMAPHORES: u32 = 35;
pub const _SC_SEM_NSEMS_MAX: u32 = 36;
pub const _SC_SEM_VALUE_MAX: u32 = 37;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 38;
pub const _SC_SIGQUEUE_MAX: u32 = 39;
pub const _SC_SIGRT_MIN: u32 = 40;
pub const _SC_SIGRT_MAX: u32 = 41;
pub const _SC_SYNCHRONIZED_IO: u32 = 42;
pub const _SC_TIMERS: u32 = 43;
pub const _SC_TIMER_MAX: u32 = 44;
pub const _SC_2_C_BIND: u32 = 45;
pub const _SC_2_C_DEV: u32 = 46;
pub const _SC_2_C_VERSION: u32 = 47;
pub const _SC_2_FORT_DEV: u32 = 48;
pub const _SC_2_FORT_RUN: u32 = 49;
pub const _SC_2_LOCALEDEF: u32 = 50;
pub const _SC_2_SW_DEV: u32 = 51;
pub const _SC_2_UPE: u32 = 52;
pub const _SC_2_VERSION: u32 = 53;
pub const _SC_BC_BASE_MAX: u32 = 54;
pub const _SC_BC_DIM_MAX: u32 = 55;
pub const _SC_BC_SCALE_MAX: u32 = 56;
pub const _SC_BC_STRING_MAX: u32 = 57;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 58;
pub const _SC_EXPR_NEST_MAX: u32 = 59;
pub const _SC_LINE_MAX: u32 = 60;
pub const _SC_RE_DUP_MAX: u32 = 61;
pub const _SC_XOPEN_CRYPT: u32 = 62;
pub const _SC_XOPEN_ENH_I18N: u32 = 63;
pub const _SC_XOPEN_SHM: u32 = 64;
pub const _SC_2_CHAR_TERM: u32 = 66;
pub const _SC_XOPEN_XCU_VERSION: u32 = 67;
pub const _SC_ATEXIT_MAX: u32 = 76;
pub const _SC_IOV_MAX: u32 = 77;
pub const _SC_XOPEN_UNIX: u32 = 78;
pub const _SC_PAGE_SIZE: u32 = 11;
pub const _SC_T_IOV_MAX: u32 = 79;
pub const _SC_PHYS_PAGES: u32 = 500;
pub const _SC_AVPHYS_PAGES: u32 = 501;
pub const _SC_COHER_BLKSZ: u32 = 503;
pub const _SC_SPLIT_CACHE: u32 = 504;
pub const _SC_ICACHE_SZ: u32 = 505;
pub const _SC_DCACHE_SZ: u32 = 506;
pub const _SC_ICACHE_LINESZ: u32 = 507;
pub const _SC_DCACHE_LINESZ: u32 = 508;
pub const _SC_ICACHE_BLKSZ: u32 = 509;
pub const _SC_DCACHE_BLKSZ: u32 = 510;
pub const _SC_DCACHE_TBLKSZ: u32 = 511;
pub const _SC_ICACHE_ASSOC: u32 = 512;
pub const _SC_DCACHE_ASSOC: u32 = 513;
pub const _SC_MAXPID: u32 = 514;
pub const _SC_STACK_PROT: u32 = 515;
pub const _SC_NPROCESSORS_MAX: u32 = 516;
pub const _SC_CPUID_MAX: u32 = 517;
pub const _SC_EPHID_MAX: u32 = 518;
pub const _SC_UADDR_MAX: u32 = 519;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 568;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 569;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 570;
pub const _SC_LOGIN_NAME_MAX: u32 = 571;
pub const _SC_THREAD_KEYS_MAX: u32 = 572;
pub const _SC_THREAD_STACK_MIN: u32 = 573;
pub const _SC_THREAD_THREADS_MAX: u32 = 574;
pub const _SC_TTY_NAME_MAX: u32 = 575;
pub const _SC_THREADS: u32 = 576;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 577;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 578;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 579;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 580;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 581;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 582;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 583;
pub const _SC_XOPEN_LEGACY: u32 = 717;
pub const _SC_XOPEN_REALTIME: u32 = 718;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 719;
pub const _SC_XBS5_ILP32_OFF32: u32 = 720;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 721;
pub const _SC_XBS5_LP64_OFF64: u32 = 722;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 723;
pub const _SC_2_PBS: u32 = 724;
pub const _SC_2_PBS_ACCOUNTING: u32 = 725;
pub const _SC_2_PBS_CHECKPOINT: u32 = 726;
pub const _SC_2_PBS_LOCATE: u32 = 728;
pub const _SC_2_PBS_MESSAGE: u32 = 729;
pub const _SC_2_PBS_TRACK: u32 = 730;
pub const _SC_ADVISORY_INFO: u32 = 731;
pub const _SC_BARRIERS: u32 = 732;
pub const _SC_CLOCK_SELECTION: u32 = 733;
pub const _SC_CPUTIME: u32 = 734;
pub const _SC_HOST_NAME_MAX: u32 = 735;
pub const _SC_MONOTONIC_CLOCK: u32 = 736;
pub const _SC_READER_WRITER_LOCKS: u32 = 737;
pub const _SC_REGEXP: u32 = 738;
pub const _SC_SHELL: u32 = 739;
pub const _SC_SPAWN: u32 = 740;
pub const _SC_SPIN_LOCKS: u32 = 741;
pub const _SC_SPORADIC_SERVER: u32 = 742;
pub const _SC_SS_REPL_MAX: u32 = 743;
pub const _SC_SYMLOOP_MAX: u32 = 744;
pub const _SC_THREAD_CPUTIME: u32 = 745;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 746;
pub const _SC_TIMEOUTS: u32 = 747;
pub const _SC_TRACE: u32 = 748;
pub const _SC_TRACE_EVENT_FILTER: u32 = 749;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 750;
pub const _SC_TRACE_INHERIT: u32 = 751;
pub const _SC_TRACE_LOG: u32 = 752;
pub const _SC_TRACE_NAME_MAX: u32 = 753;
pub const _SC_TRACE_SYS_MAX: u32 = 754;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 755;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 756;
pub const _SC_V6_ILP32_OFF32: u32 = 757;
pub const _SC_V6_ILP32_OFFBIG: u32 = 758;
pub const _SC_V6_LP64_OFF64: u32 = 759;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 760;
pub const _SC_XOPEN_STREAMS: u32 = 761;
pub const _SC_IPV6: u32 = 762;
pub const _SC_RAW_SOCKETS: u32 = 763;
pub const _PC_LINK_MAX: u32 = 1;
pub const _PC_MAX_CANON: u32 = 2;
pub const _PC_MAX_INPUT: u32 = 3;
pub const _PC_NAME_MAX: u32 = 4;
pub const _PC_PATH_MAX: u32 = 5;
pub const _PC_PIPE_BUF: u32 = 6;
pub const _PC_NO_TRUNC: u32 = 7;
pub const _PC_VDISABLE: u32 = 8;
pub const _PC_CHOWN_RESTRICTED: u32 = 9;
pub const _PC_ASYNC_IO: u32 = 10;
pub const _PC_PRIO_IO: u32 = 11;
pub const _PC_SYNC_IO: u32 = 12;
pub const _PC_ALLOC_SIZE_MIN: u32 = 13;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 14;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 15;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 16;
pub const _PC_REC_XFER_ALIGN: u32 = 17;
pub const _PC_SYMLINK_MAX: u32 = 18;
pub const _PC_2_SYMLINKS: u32 = 19;
pub const _PC_ACL_ENABLED: u32 = 20;
pub const _PC_MIN_HOLE_SIZE: u32 = 21;
pub const _PC_CASE_BEHAVIOR: u32 = 22;
pub const _PC_SATTR_ENABLED: u32 = 23;
pub const _PC_SATTR_EXISTS: u32 = 24;
pub const _PC_ACCESS_FILTERING: u32 = 25;
pub const _PC_TIMESTAMP_RESOLUTION: u32 = 26;
pub const _PC_FILESIZEBITS: u32 = 67;
pub const _PC_XATTR_ENABLED: u32 = 100;
pub const _PC_XATTR_EXISTS: u32 = 101;
pub const _PC_LAST: u32 = 101;
pub const _CASE_SENSITIVE: u32 = 1;
pub const _CASE_INSENSITIVE: u32 = 2;
pub const _ACL_ACLENT_ENABLED: u32 = 1;
pub const _ACL_ACE_ENABLED: u32 = 2;
pub const _POSIX_VERSION: u32 = 199506;
pub const _POSIX2_VERSION: u32 = 199209;
pub const _POSIX2_C_VERSION: u32 = 199209;
pub const _XOPEN_UNIX: u32 = 0;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX2_CHAR_TERM: u32 = 1;
pub const _POSIX2_C_BIND: u32 = 1;
pub const _POSIX2_C_DEV: u32 = 1;
pub const _POSIX2_FORT_RUN: u32 = 1;
pub const _POSIX2_LOCALEDEF: u32 = 1;
pub const _POSIX2_SW_DEV: u32 = 1;
pub const _POSIX2_UPE: u32 = 1;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_SHELL: u32 = 1;
pub const _XOPEN_STREAMS: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGIOT: u32 = 6;
pub const SIGABRT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGUSR1: u32 = 16;
pub const SIGUSR2: u32 = 17;
pub const SIGCLD: u32 = 18;
pub const SIGCHLD: u32 = 18;
pub const SIGPWR: u32 = 19;
pub const SIGWINCH: u32 = 20;
pub const SIGURG: u32 = 21;
pub const SIGPOLL: u32 = 22;
pub const SIGIO: u32 = 22;
pub const SIGSTOP: u32 = 23;
pub const SIGTSTP: u32 = 24;
pub const SIGCONT: u32 = 25;
pub const SIGTTIN: u32 = 26;
pub const SIGTTOU: u32 = 27;
pub const SIGVTALRM: u32 = 28;
pub const SIGPROF: u32 = 29;
pub const SIGXCPU: u32 = 30;
pub const SIGXFSZ: u32 = 31;
pub const SIGWAITING: u32 = 32;
pub const SIGLWP: u32 = 33;
pub const SIGFREEZE: u32 = 34;
pub const SIGTHAW: u32 = 35;
pub const SIGCANCEL: u32 = 36;
pub const SIGLOST: u32 = 37;
pub const SIGXRES: u32 = 38;
pub const SIGJVM1: u32 = 39;
pub const SIGJVM2: u32 = 40;
pub const SIGINFO: u32 = 41;
pub const _SIGRTMIN: u32 = 42;
pub const _SIGRTMAX: u32 = 73;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 2;
pub const SIGEV_THREAD: u32 = 3;
pub const SIGEV_PORT: u32 = 4;
pub const SI_NOINFO: u32 = 32767;
pub const SI_DTRACE: u32 = 2050;
pub const SI_RCTL: u32 = 2049;
pub const SI_USER: u32 = 0;
pub const SI_LWP: i32 = -1;
pub const SI_QUEUE: i32 = -2;
pub const SI_TIMER: i32 = -3;
pub const SI_ASYNCIO: i32 = -4;
pub const SI_MESGQ: i32 = -5;
pub const FC_HWERR: u32 = 1;
pub const FC_ALIGN: u32 = 2;
pub const FC_OBJERR: u32 = 3;
pub const FC_PROT: u32 = 4;
pub const FC_NOMAP: u32 = 5;
pub const FC_NOSUPPORT: u32 = 6;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLOPN: u32 = 2;
pub const ILL_ILLADR: u32 = 3;
pub const ILL_ILLTRP: u32 = 4;
pub const ILL_PRVOPC: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const NSIGILL: u32 = 8;
pub const EMT_CPCOVF: u32 = 1;
pub const NSIGEMT: u32 = 1;
pub const FPE_INTDIV: u32 = 1;
pub const FPE_INTOVF: u32 = 2;
pub const FPE_FLTDIV: u32 = 3;
pub const FPE_FLTOVF: u32 = 4;
pub const FPE_FLTUND: u32 = 5;
pub const FPE_FLTRES: u32 = 6;
pub const FPE_FLTINV: u32 = 7;
pub const FPE_FLTSUB: u32 = 8;
pub const FPE_FLTDEN: u32 = 9;
pub const NSIGFPE: u32 = 9;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const NSIGSEGV: u32 = 2;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const NSIGBUS: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const TRAP_RWATCH: u32 = 3;
pub const TRAP_WWATCH: u32 = 4;
pub const TRAP_XWATCH: u32 = 5;
pub const TRAP_DTRACE: u32 = 6;
pub const NSIGTRAP: u32 = 6;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const NSIGCLD: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const NSIGPOLL: u32 = 6;
pub const PROF_SIG: u32 = 1;
pub const NSIGPROF: u32 = 1;
pub const SI_MAXSZ: u32 = 256;
pub const SA_NOCLDSTOP: u32 = 131072;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESETHAND: u32 = 2;
pub const SA_RESTART: u32 = 4;
pub const SA_SIGINFO: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 65536;
pub const NSIG: u32 = 74;
pub const MAXSIG: u32 = 73;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SN_PROC: u32 = 1;
pub const SN_CANCEL: u32 = 2;
pub const SN_SEND: u32 = 3;
pub const FILLSET0: u32 = 4294967295;
pub const FILLSET1: u32 = 4294967295;
pub const FILLSET2: u32 = 511;
pub const CANTMASK1: u32 = 0;
pub const CANTMASK2: u32 = 0;
pub const _SIGQUEUE_SIZE_BASIC: u32 = 128;
pub const _SIGQUEUE_SIZE_PRIVILEGED: u32 = 512;
pub const _SIGNOTIFY_MAX: u32 = 32;
pub const _NGREG: u32 = 28;
pub const REG_GSBASE: u32 = 27;
pub const REG_FSBASE: u32 = 26;
pub const REG_DS: u32 = 25;
pub const REG_ES: u32 = 24;
pub const REG_GS: u32 = 23;
pub const REG_FS: u32 = 22;
pub const REG_SS: u32 = 21;
pub const REG_RSP: u32 = 20;
pub const REG_RFL: u32 = 19;
pub const REG_CS: u32 = 18;
pub const REG_RIP: u32 = 17;
pub const REG_ERR: u32 = 16;
pub const REG_TRAPNO: u32 = 15;
pub const REG_RAX: u32 = 14;
pub const REG_RCX: u32 = 13;
pub const REG_RDX: u32 = 12;
pub const REG_RBX: u32 = 11;
pub const REG_RBP: u32 = 10;
pub const REG_RSI: u32 = 9;
pub const REG_RDI: u32 = 8;
pub const REG_R8: u32 = 7;
pub const REG_R9: u32 = 6;
pub const REG_R10: u32 = 5;
pub const REG_R11: u32 = 4;
pub const REG_R12: u32 = 3;
pub const REG_R13: u32 = 2;
pub const REG_R14: u32 = 1;
pub const REG_R15: u32 = 0;
pub const SS: u32 = 18;
pub const UESP: u32 = 17;
pub const EFL: u32 = 16;
pub const CS: u32 = 15;
pub const EIP: u32 = 14;
pub const ERR: u32 = 13;
pub const TRAPNO: u32 = 12;
pub const EAX: u32 = 11;
pub const ECX: u32 = 10;
pub const EDX: u32 = 9;
pub const EBX: u32 = 8;
pub const ESP: u32 = 7;
pub const EBP: u32 = 6;
pub const ESI: u32 = 5;
pub const EDI: u32 = 4;
pub const DS: u32 = 3;
pub const ES: u32 = 2;
pub const FS: u32 = 1;
pub const GS: u32 = 0;
pub const REG_PC: u32 = 17;
pub const REG_FP: u32 = 10;
pub const REG_SP: u32 = 20;
pub const REG_PS: u32 = 19;
pub const REG_R0: u32 = 14;
pub const REG_R1: u32 = 12;
pub const NGREG: u32 = 28;
pub const _NDEBUGREG: u32 = 16;
pub const MAXTSSIOADDR: u32 = 1023;
pub const SEL_KPL: u32 = 0;
pub const TRP_KPL: u32 = 0;
pub const IST_DF: u32 = 1;
pub const IST_NMI: u32 = 2;
pub const IST_MCE: u32 = 3;
pub const IST_DBG: u32 = 4;
pub const IST_NESTABLE: u32 = 5;
pub const IST_DEFAULT: u32 = 6;
pub const IST_NONE: u32 = 0;
pub const SEL_UPL: u32 = 3;
pub const TRP_UPL: u32 = 3;
pub const SEL_TI_LDT: u32 = 4;
pub const CPL_MASK: u32 = 3;
pub const USD_TYPESHIFT: u32 = 5;
pub const SDP_BYTES: u32 = 0;
pub const SDP_PAGES: u32 = 1;
pub const SDP_OP32: u32 = 1;
pub const SDP_LONG: u32 = 1;
pub const SDP_SHORT: u32 = 0;
pub const SDP_LIMIT_MAX: u32 = 1048575;
pub const SDT_SYSNULL: u32 = 0;
pub const SDT_SYS286TSS: u32 = 1;
pub const SDT_SYSLDT: u32 = 2;
pub const SDT_SYS286BSY: u32 = 3;
pub const SDT_SYS286CGT: u32 = 4;
pub const SDT_SYSTASKGT: u32 = 5;
pub const SDT_SYS286IGT: u32 = 6;
pub const SDT_SYS286TGT: u32 = 7;
pub const SDT_SYSNULL2: u32 = 8;
pub const SDT_SYSTSS: u32 = 9;
pub const SDT_SYSNULL3: u32 = 10;
pub const SDT_SYSTSSBSY: u32 = 11;
pub const SDT_SYSCGT: u32 = 12;
pub const SDT_SYSNULL4: u32 = 13;
pub const SDT_SYSIGT: u32 = 14;
pub const SDT_SYSTGT: u32 = 15;
pub const SDT_MEMRO: u32 = 16;
pub const SDT_MEMROA: u32 = 17;
pub const SDT_MEMRW: u32 = 18;
pub const SDT_MEMRWA: u32 = 19;
pub const SDT_MEMROD: u32 = 20;
pub const SDT_MEMRODA: u32 = 21;
pub const SDT_MEMRWD: u32 = 22;
pub const SDT_MEMRWDA: u32 = 23;
pub const SDT_MEME: u32 = 24;
pub const SDT_MEMEA: u32 = 25;
pub const SDT_MEMER: u32 = 26;
pub const SDT_MEMERA: u32 = 27;
pub const SDT_MEMEC: u32 = 28;
pub const SDT_MEMEAC: u32 = 29;
pub const SDT_MEMERC: u32 = 30;
pub const SDT_MEMERAC: u32 = 31;
pub const SDT_A: u32 = 1;
pub const SDT_S: u32 = 16;
pub const IDT_DE: u32 = 0;
pub const IDT_DB: u32 = 1;
pub const IDT_NMI: u32 = 2;
pub const IDT_BP: u32 = 3;
pub const IDT_OF: u32 = 4;
pub const IDT_BR: u32 = 5;
pub const IDT_UD: u32 = 6;
pub const IDT_NM: u32 = 7;
pub const IDT_DF: u32 = 8;
pub const IDT_FPUGP: u32 = 9;
pub const IDT_TS: u32 = 10;
pub const IDT_NP: u32 = 11;
pub const IDT_SS: u32 = 12;
pub const IDT_GP: u32 = 13;
pub const IDT_PF: u32 = 14;
pub const IDT_MF: u32 = 16;
pub const IDT_AC: u32 = 17;
pub const IDT_MC: u32 = 18;
pub const IDT_XF: u32 = 19;
pub const NIDT: u32 = 256;
pub const GDT_NULL: u32 = 0;
pub const GDT_B32DATA: u32 = 1;
pub const GDT_B32CODE: u32 = 2;
pub const GDT_B16CODE: u32 = 3;
pub const GDT_B16DATA: u32 = 4;
pub const GDT_B64CODE: u32 = 5;
pub const GDT_BGSTMP: u32 = 7;
pub const GDT_CPUID: u32 = 16;
pub const LEN_MIN_GDT_BOOT: u32 = 6;
pub const GDT_KCODE: u32 = 6;
pub const GDT_KDATA: u32 = 7;
pub const GDT_U32CODE: u32 = 8;
pub const GDT_UDATA: u32 = 9;
pub const GDT_UCODE: u32 = 10;
pub const GDT_LDT: u32 = 12;
pub const GDT_KTSS: u32 = 14;
pub const GDT_FS: u32 = 0;
pub const GDT_GS: u32 = 0;
pub const GDT_LWPFS: u32 = 55;
pub const GDT_LWPGS: u32 = 56;
pub const GDT_BRANDMIN: u32 = 57;
pub const GDT_BRANDMAX: u32 = 61;
pub const NGDT: u32 = 62;
pub const TEMPGDT_KCODE64: u32 = 1;
pub const TEMPGDT_KCODE32: u32 = 2;
pub const TEMPGDT_KDATA32: u32 = 3;
pub const KFS_SEL: u32 = 0;
pub const LDT_SYSCALL: u32 = 0;
pub const LDT_SIGCALL: u32 = 1;
pub const LDT_RESVD1: u32 = 2;
pub const LDT_RESVD2: u32 = 3;
pub const LDT_ALTSYSCALL: u32 = 4;
pub const LDT_ALTSIGCALL: u32 = 5;
pub const LDT_UDBASE: u32 = 6;
pub const MINNLDT: u32 = 512;
pub const MAXNLDT: u32 = 8192;
pub const LDT_CPU_SIZE: u32 = 65536;
pub const FP_NO: u32 = 0;
pub const FP_SW: u32 = 1;
pub const FP_HW: u32 = 2;
pub const FP_287: u32 = 2;
pub const FP_387: u32 = 3;
pub const FP_487: u32 = 6;
pub const FP_486: u32 = 6;
pub const __FP_SSE: u32 = 256;
pub const __FP_AVX: u32 = 512;
pub const FP_FNSAVE: u32 = 1;
pub const FP_FXSAVE: u32 = 2;
pub const FP_XSAVE: u32 = 3;
pub const FPIM: u32 = 1;
pub const FPDM: u32 = 2;
pub const FPZM: u32 = 4;
pub const FPOM: u32 = 8;
pub const FPUM: u32 = 16;
pub const FPPM: u32 = 32;
pub const FPPC: u32 = 768;
pub const FPRC: u32 = 3072;
pub const FPIC: u32 = 4096;
pub const WFPDE: u32 = 128;
pub const FPINV: u32 = 1;
pub const FPDNO: u32 = 2;
pub const FPZDIV: u32 = 4;
pub const FPOVR: u32 = 8;
pub const FPUNR: u32 = 16;
pub const FPPRE: u32 = 32;
pub const FPSIG24: u32 = 0;
pub const FPSIG53: u32 = 512;
pub const FPSIG64: u32 = 768;
pub const FPRTN: u32 = 0;
pub const FPRD: u32 = 1024;
pub const FPRU: u32 = 2048;
pub const FPCHOP: u32 = 3072;
pub const FPP: u32 = 0;
pub const FPA: u32 = 4096;
pub const WFPB17: u32 = 131072;
pub const WFPB24: u32 = 262144;
pub const FPS_IE: u32 = 1;
pub const FPS_DE: u32 = 2;
pub const FPS_ZE: u32 = 4;
pub const FPS_OE: u32 = 8;
pub const FPS_UE: u32 = 16;
pub const FPS_PE: u32 = 32;
pub const FPS_SF: u32 = 64;
pub const FPS_ES: u32 = 128;
pub const FPS_C0: u32 = 256;
pub const FPS_C1: u32 = 512;
pub const FPS_C2: u32 = 1024;
pub const FPS_TOP: u32 = 14336;
pub const FPS_C3: u32 = 16384;
pub const FPS_B: u32 = 32768;
pub const FPS_SW_EFLAGS: u32 = 33023;
pub const FPU_CW_INIT: u32 = 4991;
pub const FPU_CW_INIT_HW: u32 = 895;
pub const SSE_IE: u32 = 1;
pub const SSE_DE: u32 = 2;
pub const SSE_ZE: u32 = 4;
pub const SSE_OE: u32 = 8;
pub const SSE_UE: u32 = 16;
pub const SSE_PE: u32 = 32;
pub const SSE_DAZ: u32 = 64;
pub const SSE_IM: u32 = 128;
pub const SSE_DM: u32 = 256;
pub const SSE_ZM: u32 = 512;
pub const SSE_OM: u32 = 1024;
pub const SSE_UM: u32 = 2048;
pub const SSE_PM: u32 = 4096;
pub const SSE_RC: u32 = 24576;
pub const SSE_RD: u32 = 8192;
pub const SSE_RU: u32 = 16384;
pub const SSE_FZ: u32 = 32768;
pub const SSE_MXCSR_EFLAGS: u32 = 63;
pub const SSE_MXCSR_INIT: u32 = 8064;
pub const SSE_MXCSR_MASK_DEFAULT: u32 = 65471;
pub const SSE_FMT_MXCSR : & [u8 ; 51] = b"\x10\x10fz\x0Fru\x0Erd\rpm\x0Cum\x0Bom\nzm\tdm\x08im\x07daz\x06pe\x05ue\x04oe\x03ze\x02de\x01ie\0" ;
pub const DEBUG_PENDING: u32 = 2;
pub const PRSTOP_CALLED: u32 = 4;
pub const INSTR_VALID: u32 = 8;
pub const NORMAL_STEP: u32 = 16;
pub const WATCH_STEP: u32 = 32;
pub const CPC_OVERFLOW: u32 = 64;
pub const REQUEST_STEP: u32 = 256;
pub const REQUEST_NOSTEP: u32 = 512;
pub const ASYNC_HWERR: u32 = 1024;
pub const PCB_UPDATE_SEGS: u32 = 1;
pub const PCB_UPDATE_FPU: u32 = 2;
pub const FPU_EN: u32 = 1;
pub const FPU_VALID: u32 = 2;
pub const FPU_MODIFIED: u32 = 4;
pub const FPU_KERNEL: u32 = 8;
pub const FPU_INVALID: u32 = 0;
pub const LMS_USER: u32 = 0;
pub const LMS_SYSTEM: u32 = 1;
pub const LMS_TRAP: u32 = 2;
pub const LMS_TFAULT: u32 = 3;
pub const LMS_DFAULT: u32 = 4;
pub const LMS_KFAULT: u32 = 5;
pub const LMS_USER_LOCK: u32 = 6;
pub const LMS_SLEEP: u32 = 7;
pub const LMS_WAIT_CPU: u32 = 8;
pub const LMS_STOPPED: u32 = 9;
pub const NMSTATES: u32 = 10;
pub const CMS_USER: u32 = 0;
pub const CMS_SYSTEM: u32 = 1;
pub const CMS_IDLE: u32 = 2;
pub const CMS_DISABLED: u32 = 3;
pub const NCMSTATES: u32 = 3;
pub const GETCONTEXT: u32 = 0;
pub const SETCONTEXT: u32 = 1;
pub const GETUSTACK: u32 = 2;
pub const SETUSTACK: u32 = 3;
pub const GETCONTEXT_EXTD: u32 = 4;
pub const UC_SIGMASK: u32 = 1;
pub const UC_STACK: u32 = 2;
pub const UC_CPU: u32 = 4;
pub const UC_MAU: u32 = 8;
pub const UC_FPU: u32 = 8;
pub const UC_XSAVE: u32 = 16;
pub const UC_MCONTEXT: u32 = 12;
pub const UC_ALL: u32 = 15;
pub const USYNC_THREAD: u32 = 0;
pub const USYNC_PROCESS: u32 = 1;
pub const LOCK_NORMAL: u32 = 0;
pub const LOCK_SHARED: u32 = 1;
pub const LOCK_ERRORCHECK: u32 = 2;
pub const LOCK_RECURSIVE: u32 = 4;
pub const LOCK_PRIO_INHERIT: u32 = 16;
pub const LOCK_PRIO_PROTECT: u32 = 32;
pub const LOCK_ROBUST: u32 = 64;
pub const USYNC_PROCESS_ROBUST: u32 = 8;
pub const LOCK_OWNERDEAD: u32 = 1;
pub const LOCK_NOTRECOVERABLE: u32 = 2;
pub const LOCK_INITED: u32 = 4;
pub const LOCK_UNMAPPED: u32 = 8;
pub const LOCK_DEADLOCK: u32 = 16;
pub const LWP_DAEMON: u32 = 32;
pub const LWP_DETACHED: u32 = 64;
pub const LWP_SUSPENDED: u32 = 128;
pub const _LWP_FSBASE: u32 = 0;
pub const _LWP_GSBASE: u32 = 1;
pub const _LWP_SETPRIVATE: u32 = 0;
pub const _LWP_GETPRIVATE: u32 = 1;
pub const CT_PARAM_MAX_SIZE: u32 = 8192;
pub const CT_EV_NEGEND: u32 = 0;
pub const CTD_COMMON: u32 = 0;
pub const CTD_FIXED: u32 = 1;
pub const CTD_ALL: u32 = 2;
pub const CTE_ACK: u32 = 1;
pub const CTE_INFO: u32 = 2;
pub const CTE_NEG: u32 = 4;
pub const CTP_EV_CRITICAL: u32 = 100;
pub const CTP_EV_INFO: u32 = 101;
pub const CTP_COOKIE: u32 = 102;
pub const CTS_NEWCT: &[u8; 10] = b"cts_newct\0";
pub const CTS_NEVID: &[u8; 10] = b"cts_nevid\0";
pub const MAXSYSARGS: u32 = 8;
pub const NORMALRETURN: u32 = 0;
pub const JUSTRETURN: u32 = 1;
pub const LWP_USER: u32 = 1;
pub const LWP_SYS: u32 = 2;
pub const CPC_BIND_LWP_INHERIT: u32 = 1;
pub const CPC_BIND_EMT_OVF: u32 = 2;
pub const CPC_MAX_IMPL_NAME: u32 = 512;
pub const CPC_MAX_CPUREF: u32 = 1024;
pub const CPC_OVF_NOTIFY_EMT: u32 = 1;
pub const CPC_COUNT_USER: u32 = 2;
pub const CPC_COUNT_SYSTEM: u32 = 4;
pub const CPC_COUNT_HV: u32 = 8;
pub const CPC_COUNT_SAMPLE_MODE: u32 = 16;
pub const KCPC_REQ_ALL_FLAGS: u32 = 31;
pub const CPC_CAP_OVERFLOW_INTERRUPT: u32 = 1;
pub const CPC_CAP_OVERFLOW_PRECISE: u32 = 2;
pub const CPC_SET_ALL_FLAGS: u32 = 1;
pub const CPC_BIND: u32 = 0;
pub const CPC_SAMPLE: u32 = 1;
pub const CPC_INVALIDATE: u32 = 2;
pub const CPC_RELE: u32 = 3;
pub const CPC_EVLIST_SIZE: u32 = 4;
pub const CPC_LIST_EVENTS: u32 = 5;
pub const CPC_ATTRLIST_SIZE: u32 = 6;
pub const CPC_LIST_ATTRS: u32 = 7;
pub const CPC_IMPL_NAME: u32 = 8;
pub const CPC_CPUREF: u32 = 9;
pub const CPC_USR_EVENTS: u32 = 10;
pub const CPC_SYS_EVENTS: u32 = 11;
pub const CPC_NPIC: u32 = 12;
pub const CPC_CAPS: u32 = 13;
pub const CPC_ENABLE: u32 = 14;
pub const CPC_DISABLE: u32 = 15;
pub const CPC_PRESET: u32 = 16;
pub const CPC_RESTART: u32 = 17;
pub const CPC_MAX_EVENT_LEN: u32 = 512;
pub const CPC_MAX_ATTR_LEN: u32 = 32;
pub const KCPC_LOG2_HASH_BUCKETS: u32 = 6;
pub const CPC_HASH_BUCKETS: u32 = 64;
pub const KCPC_CTX_FREEZE: u32 = 1;
pub const KCPC_CTX_SIGOVF: u32 = 2;
pub const KCPC_CTX_NONPRIV: u32 = 4;
pub const KCPC_CTX_LWPINHERIT: u32 = 8;
pub const KCPC_CTX_INVALID: u32 = 256;
pub const KCPC_CTX_INVALID_STOPPED: u32 = 512;
pub const KCPC_CTX_RESTORE: u32 = 1024;
pub const KCPC_PIC_OVERFLOWED: u32 = 1;
pub const PCBE_NAMELEN: u32 = 30;
pub const CPC_INVALID_EVENT: u32 = 1;
pub const CPC_INVALID_PICNUM: u32 = 2;
pub const CPC_INVALID_ATTRIBUTE: u32 = 3;
pub const CPC_ATTRIBUTE_OUT_OF_RANGE: u32 = 4;
pub const CPC_RESOURCE_UNAVAIL: u32 = 5;
pub const CPC_PIC_NOT_CAPABLE: u32 = 6;
pub const CPC_REQ_INVALID_FLAGS: u32 = 7;
pub const CPC_CONFLICTING_REQS: u32 = 8;
pub const CPC_ATTR_REQUIRES_PRIVILEGE: u32 = 9;
pub const CPC_PBIND_FAILED: u32 = 10;
pub const CPC_HV_NO_ACCESS: u32 = 11;
pub const KCPC_SET_BOUND: u32 = 1;
pub const TS_FREE: u32 = 0;
pub const TS_SLEEP: u32 = 1;
pub const TS_RUN: u32 = 2;
pub const TS_ONPROC: u32 = 4;
pub const TS_ZOMB: u32 = 8;
pub const TS_STOPPED: u32 = 16;
pub const TS_WAIT: u32 = 32;
pub const T_INTR_THREAD: u32 = 1;
pub const T_WAKEABLE: u32 = 2;
pub const T_TOMASK: u32 = 4;
pub const T_TALLOCSTK: u32 = 8;
pub const T_FORKALL: u32 = 16;
pub const T_WOULDBLOCK: u32 = 32;
pub const T_DONTBLOCK: u32 = 64;
pub const T_DONTPEND: u32 = 128;
pub const T_SYS_PROF: u32 = 256;
pub const T_WAITCVSEM: u32 = 512;
pub const T_WATCHPT: u32 = 1024;
pub const T_PANIC: u32 = 2048;
pub const T_LWPREUSE: u32 = 4096;
pub const T_CAPTURING: u32 = 8192;
pub const T_VFPARENT: u32 = 16384;
pub const T_DONTDTRACE: u32 = 32768;
pub const T_KFPU: u32 = 65536;
pub const T_PUSHPAGE: u32 = 131072;
pub const TP_DAEMON: u32 = 1;
pub const TP_HOLDLWP: u32 = 2;
pub const TP_TWAIT: u32 = 4;
pub const TP_LWPEXIT: u32 = 8;
pub const TP_PRSTOP: u32 = 16;
pub const TP_CHKPT: u32 = 32;
pub const TP_EXITLWP: u32 = 64;
pub const TP_PRVSTOP: u32 = 128;
pub const TP_MSACCT: u32 = 256;
pub const TP_STOPPING: u32 = 512;
pub const TP_WATCHPT: u32 = 1024;
pub const TP_PAUSE: u32 = 2048;
pub const TP_CHANGEBIND: u32 = 4096;
pub const TP_ZTHREAD: u32 = 8192;
pub const TP_WATCHSTOP: u32 = 16384;
pub const TP_KTHREAD: u32 = 32768;
pub const TS_LOAD: u32 = 1;
pub const TS_DONT_SWAP: u32 = 2;
pub const TS_SWAPENQ: u32 = 4;
pub const TS_ON_SWAPQ: u32 = 8;
pub const TS_SIGNALLED: u32 = 16;
pub const TS_PROJWAITQ: u32 = 32;
pub const TS_ZONEWAITQ: u32 = 64;
pub const TS_VCPU: u32 = 128;
pub const TS_CSTART: u32 = 256;
pub const TS_UNPAUSE: u32 = 512;
pub const TS_XSTART: u32 = 1024;
pub const TS_PSTART: u32 = 2048;
pub const TS_RESUME: u32 = 4096;
pub const TS_CREATE: u32 = 8192;
pub const TS_RUNQMATCH: u32 = 16384;
pub const TS_ALLSTART: u32 = 16128;
pub const TS_ANYWAITQ: u32 = 96;
pub const TB_ALLHARD: u32 = 0;
pub const TB_CPU_SOFT: u32 = 1;
pub const TB_PSET_SOFT: u32 = 2;
pub const THREAD_FREE_BITS: u32 = 10;
pub const THREAD_FREE_NUM: u32 = 1024;
pub const THREAD_FREE_MASK: u32 = 1023;
pub const THREAD_FREE_1: u32 = 5;
pub const THREAD_FREE_2: u32 = 15;
pub const THREAD_NAME_MAX: u32 = 32;
pub const KMEM_STKINFO_PATTERN: i64 = -4981901630588011812;
pub const KMEM_STKINFO_LOG_SIZE: u32 = 16;
pub const KMEM_STKINFO_STR_SIZE: u32 = 64;
pub const NO_LOCKS_HELD: u32 = 1;
pub const NO_COMPETING_THREADS: u32 = 1;
pub const GLOBAL_NETSTACKID: u32 = 0;
pub const NS_ALL: i32 = -1;
pub const NS_DLS: u32 = 0;
pub const NS_IPTUN: u32 = 1;
pub const NS_STR: u32 = 2;
pub const NS_HOOK: u32 = 3;
pub const NS_NETI: u32 = 4;
pub const NS_ARP: u32 = 5;
pub const NS_IP: u32 = 6;
pub const NS_ICMP: u32 = 7;
pub const NS_UDP: u32 = 8;
pub const NS_TCP: u32 = 9;
pub const NS_SCTP: u32 = 10;
pub const NS_RTS: u32 = 11;
pub const NS_IPSEC: u32 = 12;
pub const NS_KEYSOCK: u32 = 13;
pub const NS_SPDSOCK: u32 = 14;
pub const NS_IPSECAH: u32 = 15;
pub const NS_IPSECESP: u32 = 16;
pub const NS_IPNET: u32 = 17;
pub const NS_ILB: u32 = 18;
pub const NS_MAX: u32 = 19;
pub const NSS_CREATE_NEEDED: u32 = 1;
pub const NSS_CREATE_INPROGRESS: u32 = 2;
pub const NSS_CREATE_COMPLETED: u32 = 4;
pub const NSS_SHUTDOWN_NEEDED: u32 = 16;
pub const NSS_SHUTDOWN_INPROGRESS: u32 = 32;
pub const NSS_SHUTDOWN_COMPLETED: u32 = 64;
pub const NSS_DESTROY_NEEDED: u32 = 256;
pub const NSS_DESTROY_INPROGRESS: u32 = 512;
pub const NSS_DESTROY_COMPLETED: u32 = 1024;
pub const NSS_CREATE_ALL: u32 = 7;
pub const NSS_SHUTDOWN_ALL: u32 = 112;
pub const NSS_DESTROY_ALL: u32 = 1792;
pub const NSS_ALL_INPROGRESS: u32 = 546;
pub const NSF_UNINIT: u32 = 1;
pub const NSF_CLOSING: u32 = 2;
pub const NSF_ZONE_CREATE: u32 = 4;
pub const NSF_ZONE_SHUTDOWN: u32 = 8;
pub const NSF_ZONE_DESTROY: u32 = 16;
pub const NSF_ZONE_INPROGRESS: u32 = 28;
pub const NRF_REGISTERED: u32 = 1;
pub const NRF_DYING: u32 = 2;
pub const _SS_MAXSIZE: u32 = 256;
pub const LINUX_SLL_HOST: u32 = 0;
pub const LINUX_SLL_BROADCAST: u32 = 1;
pub const LINUX_SLL_MULTICAST: u32 = 2;
pub const LINUX_SLL_OTHERHOST: u32 = 3;
pub const LINUX_SLL_OUTGOING: u32 = 4;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_HOPOPTS: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_IGMP: u32 = 2;
pub const IPPROTO_GGP: u32 = 3;
pub const IPPROTO_ENCAP: u32 = 4;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_EGP: u32 = 8;
pub const IPPROTO_PUP: u32 = 12;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_IDP: u32 = 22;
pub const IPPROTO_IPV6: u32 = 41;
pub const IPPROTO_ROUTING: u32 = 43;
pub const IPPROTO_FRAGMENT: u32 = 44;
pub const IPPROTO_RSVP: u32 = 46;
pub const IPPROTO_ESP: u32 = 50;
pub const IPPROTO_AH: u32 = 51;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_NONE: u32 = 59;
pub const IPPROTO_DSTOPTS: u32 = 60;
pub const IPPROTO_HELLO: u32 = 63;
pub const IPPROTO_ND: u32 = 77;
pub const IPPROTO_EON: u32 = 80;
pub const IPPROTO_OSPF: u32 = 89;
pub const IPPROTO_PIM: u32 = 103;
pub const IPPROTO_SCTP: u32 = 132;
pub const IPPROTO_MH: u32 = 135;
pub const IPPROTO_HIP: u32 = 139;
pub const IPPROTO_SHIM6: u32 = 140;
pub const IPPROTO_RAW: u32 = 255;
pub const IPPROTO_MAX: u32 = 256;
pub const PROTO_SDP: u32 = 257;
pub const IPPORT_ECHO: u32 = 7;
pub const IPPORT_DISCARD: u32 = 9;
pub const IPPORT_SYSTAT: u32 = 11;
pub const IPPORT_DAYTIME: u32 = 13;
pub const IPPORT_NETSTAT: u32 = 15;
pub const IPPORT_CHARGEN: u32 = 19;
pub const IPPORT_FTP: u32 = 21;
pub const IPPORT_TELNET: u32 = 23;
pub const IPPORT_SMTP: u32 = 25;
pub const IPPORT_TIMESERVER: u32 = 37;
pub const IPPORT_NAMESERVER: u32 = 42;
pub const IPPORT_WHOIS: u32 = 43;
pub const IPPORT_DOMAIN: u32 = 53;
pub const IPPORT_MDNS: u32 = 5353;
pub const IPPORT_MTP: u32 = 57;
pub const IPPORT_BOOTPS: u32 = 67;
pub const IPPORT_BOOTPC: u32 = 68;
pub const IPPORT_TFTP: u32 = 69;
pub const IPPORT_RJE: u32 = 77;
pub const IPPORT_FINGER: u32 = 79;
pub const IPPORT_HTTP: u32 = 80;
pub const IPPORT_HTTP_ALT: u32 = 8080;
pub const IPPORT_TTYLINK: u32 = 87;
pub const IPPORT_SUPDUP: u32 = 95;
pub const IPPORT_NTP: u32 = 123;
pub const IPPORT_NETBIOS_NS: u32 = 137;
pub const IPPORT_NETBIOS_DGM: u32 = 138;
pub const IPPORT_NETBIOS_SSN: u32 = 139;
pub const IPPORT_LDAP: u32 = 389;
pub const IPPORT_SLP: u32 = 427;
pub const IPPORT_MIP: u32 = 434;
pub const IPPORT_SMB: u32 = 445;
pub const IPPORT_VXLAN: u32 = 4789;
pub const IPPORT_IKE: u32 = 500;
pub const IPPORT_IKE_NATT: u32 = 4500;
pub const IPPORT_EXECSERVER: u32 = 512;
pub const IPPORT_LOGINSERVER: u32 = 513;
pub const IPPORT_CMDSERVER: u32 = 514;
pub const IPPORT_PRINTER: u32 = 515;
pub const IPPORT_EFSSERVER: u32 = 520;
pub const IPPORT_BIFFUDP: u32 = 512;
pub const IPPORT_WHOSERVER: u32 = 513;
pub const IPPORT_SYSLOG: u32 = 514;
pub const IPPORT_TALK: u32 = 517;
pub const IPPORT_ROUTESERVER: u32 = 520;
pub const IPPORT_RIPNG: u32 = 521;
pub const IPPORT_DHCPV6C: u32 = 546;
pub const IPPORT_DHCPV6S: u32 = 547;
pub const IPPORT_SOCKS: u32 = 1080;
pub const IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_USERRESERVED: u32 = 5000;
pub const IPPORT_DYNAMIC_MIN: u32 = 49152;
pub const IPPORT_DYNAMIC_MAX: u32 = 65535;
pub const IMPLINK_IP: u32 = 155;
pub const IMPLINK_LOWEXPER: u32 = 156;
pub const IMPLINK_HIGHEXPER: u32 = 158;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_CLASSD_NET: u32 = 4026531840;
pub const IN_CLASSD_NSHIFT: u32 = 28;
pub const IN_CLASSD_HOST: u32 = 268435455;
pub const IN_CLASSE_NET: u32 = 4294967295;
pub const INADDR_ANY: u32 = 0;
pub const INADDR_LOOPBACK: u32 = 2130706433;
pub const INADDR_BROADCAST: u32 = 4294967295;
pub const INADDR_NONE: u32 = 4294967295;
pub const INADDR_UNSPEC_GROUP: u32 = 3758096384;
pub const INADDR_ALLHOSTS_GROUP: u32 = 3758096385;
pub const INADDR_ALLRTRS_GROUP: u32 = 3758096386;
pub const INADDR_ALLRPTS_GROUP: u32 = 3758096406;
pub const INADDR_MAX_LOCAL_GROUP: u32 = 3758096639;
pub const IN_AUTOCONF_NET: u32 = 2851995648;
pub const IN_AUTOCONF_MASK: u32 = 4294901760;
pub const IN_PRIVATE8_NET: u32 = 167772160;
pub const IN_PRIVATE8_MASK: u32 = 4278190080;
pub const IN_PRIVATE12_NET: u32 = 2886729728;
pub const IN_PRIVATE12_MASK: u32 = 4293918720;
pub const IN_PRIVATE16_NET: u32 = 3232235520;
pub const IN_PRIVATE16_MASK: u32 = 4294901760;
pub const INADDR_6TO4RRANYCAST: u32 = 3227017985;
pub const IN_LOOPBACKNET: u32 = 127;
pub const IPV6_FLOWINFO_FLOWLABEL: u32 = 4294905600;
pub const IPV6_FLOWINFO_TCLASS: u32 = 61455;
pub const IP_OPTIONS: u32 = 1;
pub const IP_HDRINCL: u32 = 2;
pub const IP_TOS: u32 = 3;
pub const IP_TTL: u32 = 4;
pub const IP_RECVOPTS: u32 = 5;
pub const IP_RECVRETOPTS: u32 = 6;
pub const IP_RECVDSTADDR: u32 = 7;
pub const IP_RETOPTS: u32 = 8;
pub const IP_RECVIF: u32 = 9;
pub const IP_RECVSLLA: u32 = 10;
pub const IP_RECVTTL: u32 = 11;
pub const IP_RECVTOS: u32 = 12;
pub const IP_MULTICAST_IF: u32 = 16;
pub const IP_MULTICAST_TTL: u32 = 17;
pub const IP_MULTICAST_LOOP: u32 = 18;
pub const IP_ADD_MEMBERSHIP: u32 = 19;
pub const IP_DROP_MEMBERSHIP: u32 = 20;
pub const IP_BLOCK_SOURCE: u32 = 21;
pub const IP_UNBLOCK_SOURCE: u32 = 22;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 23;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 24;
pub const IP_NEXTHOP: u32 = 25;
pub const IP_PKTINFO: u32 = 26;
pub const IP_RECVPKTINFO: u32 = 26;
pub const IP_DONTFRAG: u32 = 27;
pub const IP_MINTTL: u32 = 28;
pub const IP_SEC_OPT: u32 = 34;
pub const IPSEC_PREF_NEVER: u32 = 1;
pub const IPSEC_PREF_REQUIRED: u32 = 2;
pub const IPSEC_PREF_UNIQUE: u32 = 4;
pub const IP_BOUND_IF: u32 = 65;
pub const IP_UNSPEC_SRC: u32 = 66;
pub const IP_BROADCAST_TTL: u32 = 67;
pub const IP_DHCPINIT_IF: u32 = 69;
pub const IP_REUSEADDR: u32 = 260;
pub const IP_DONTROUTE: u32 = 261;
pub const IP_BROADCAST: u32 = 262;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const MCAST_INCLUDE: u32 = 1;
pub const MCAST_EXCLUDE: u32 = 2;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IPV6_UNICAST_HOPS: u32 = 5;
pub const IPV6_MULTICAST_IF: u32 = 6;
pub const IPV6_MULTICAST_HOPS: u32 = 7;
pub const IPV6_MULTICAST_LOOP: u32 = 8;
pub const IPV6_JOIN_GROUP: u32 = 9;
pub const IPV6_LEAVE_GROUP: u32 = 10;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const IPV6_ADD_MEMBERSHIP: u32 = 9;
pub const IPV6_DROP_MEMBERSHIP: u32 = 10;
pub const IPV6_PKTINFO: u32 = 11;
pub const IPV6_HOPLIMIT: u32 = 12;
pub const IPV6_NEXTHOP: u32 = 13;
pub const IPV6_HOPOPTS: u32 = 14;
pub const IPV6_DSTOPTS: u32 = 15;
pub const IPV6_RTHDR: u32 = 16;
pub const IPV6_RTHDRDSTOPTS: u32 = 17;
pub const IPV6_RECVPKTINFO: u32 = 18;
pub const IPV6_RECVHOPLIMIT: u32 = 19;
pub const IPV6_RECVHOPOPTS: u32 = 20;
pub const _OLD_IPV6_RECVDSTOPTS: u32 = 21;
pub const IPV6_RECVRTHDR: u32 = 22;
pub const IPV6_RECVRTHDRDSTOPTS: u32 = 23;
pub const IPV6_CHECKSUM: u32 = 24;
pub const IPV6_RECVTCLASS: u32 = 25;
pub const IPV6_USE_MIN_MTU: u32 = 32;
pub const IPV6_DONTFRAG: u32 = 33;
pub const IPV6_SEC_OPT: u32 = 34;
pub const IPV6_SRC_PREFERENCES: u32 = 35;
pub const IPV6_RECVPATHMTU: u32 = 36;
pub const IPV6_PATHMTU: u32 = 37;
pub const IPV6_TCLASS: u32 = 38;
pub const IPV6_V6ONLY: u32 = 39;
pub const IPV6_RECVDSTOPTS: u32 = 40;
pub const MCAST_JOIN_GROUP: u32 = 41;
pub const MCAST_LEAVE_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 45;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 46;
pub const IPV6_PREFER_SRC_HOME: u32 = 1;
pub const IPV6_PREFER_SRC_COA: u32 = 2;
pub const IPV6_PREFER_SRC_PUBLIC: u32 = 4;
pub const IPV6_PREFER_SRC_TMP: u32 = 8;
pub const IPV6_PREFER_SRC_NONCGA: u32 = 16;
pub const IPV6_PREFER_SRC_CGA: u32 = 32;
pub const IPV6_PREFER_SRC_MIPMASK: u32 = 3;
pub const IPV6_PREFER_SRC_MIPDEFAULT: u32 = 1;
pub const IPV6_PREFER_SRC_TMPMASK: u32 = 12;
pub const IPV6_PREFER_SRC_TMPDEFAULT: u32 = 4;
pub const IPV6_PREFER_SRC_CGAMASK: u32 = 48;
pub const IPV6_PREFER_SRC_CGADEFAULT: u32 = 16;
pub const IPV6_PREFER_SRC_MASK: u32 = 63;
pub const IPV6_PREFER_SRC_DEFAULT: u32 = 21;
pub const IPV6_MINHOPCOUNT: u32 = 47;
pub const IPV6_BOUND_IF: u32 = 65;
pub const IPV6_UNSPEC_SRC: u32 = 66;
pub const IPV6_PAD1_OPT: u32 = 0;
pub const IPVERSION: u32 = 4;
pub const IP_DF: u32 = 16384;
pub const IP_MF: u32 = 8192;
pub const IP_MAXPACKET: u32 = 65535;
pub const IPTOS_LOWDELAY: u32 = 16;
pub const IPTOS_THROUGHPUT: u32 = 8;
pub const IPTOS_RELIABILITY: u32 = 4;
pub const IPTOS_ECT: u32 = 2;
pub const IPTOS_CE: u32 = 1;
pub const IPTOS_PREC_NETCONTROL: u32 = 224;
pub const IPTOS_PREC_INTERNETCONTROL: u32 = 192;
pub const IPTOS_PREC_CRITIC_ECP: u32 = 160;
pub const IPTOS_PREC_FLASHOVERRIDE: u32 = 128;
pub const IPTOS_PREC_FLASH: u32 = 96;
pub const IPTOS_PREC_IMMEDIATE: u32 = 64;
pub const IPTOS_PREC_PRIORITY: u32 = 32;
pub const IPTOS_PREC_ROUTINE: u32 = 0;
pub const IPOPT_COPY: u32 = 128;
pub const IPOPT_CONTROL: u32 = 0;
pub const IPOPT_RESERVED1: u32 = 32;
pub const IPOPT_DEBMEAS: u32 = 64;
pub const IPOPT_RESERVED2: u32 = 96;
pub const IPOPT_EOL: u32 = 0;
pub const IPOPT_NOP: u32 = 1;
pub const IPOPT_RR: u32 = 7;
pub const IPOPT_RTRALERT: u32 = 20;
pub const IPOPT_TS: u32 = 68;
pub const IPOPT_SECURITY: u32 = 130;
pub const IPOPT_LSRR: u32 = 131;
pub const IPOPT_EXTSEC: u32 = 133;
pub const IPOPT_COMSEC: u32 = 134;
pub const IPOPT_SATID: u32 = 136;
pub const IPOPT_SSRR: u32 = 137;
pub const IPOPT_RA: u32 = 148;
pub const IPOPT_SDMDD: u32 = 149;
pub const IPOPT_OPTVAL: u32 = 0;
pub const IPOPT_OLEN: u32 = 1;
pub const IPOPT_OFFSET: u32 = 2;
pub const IPOPT_POS_OV_FLG: u32 = 3;
pub const IPOPT_MINOFF: u32 = 4;
pub const IPOPT_MINOFF_SR: u32 = 4;
pub const IPOPT_TS_TSONLY: u32 = 0;
pub const IPOPT_TS_TSANDADDR: u32 = 1;
pub const IPOPT_TS_PRESPEC: u32 = 2;
pub const IPOPT_TS_PRESPEC_RFC791: u32 = 3;
pub const IPOPT_MINOFF_IT: u32 = 5;
pub const IPOPT_MINLEN_IT: u32 = 5;
pub const IPOPT_TS_TIMELEN: u32 = 4;
pub const IPOPT_SECUR_UNCLASS: u32 = 0;
pub const IPOPT_SECUR_CONFID: u32 = 61749;
pub const IPOPT_SECUR_EFTO: u32 = 30874;
pub const IPOPT_SECUR_MMMM: u32 = 48205;
pub const IPOPT_SECUR_RESTR: u32 = 44819;
pub const IPOPT_SECUR_SECRET: u32 = 55176;
pub const IPOPT_SECUR_TOPSECRET: u32 = 27589;
pub const MAXTTL: u32 = 255;
pub const IPFRAGTTL: u32 = 60;
pub const IPTTLDEC: u32 = 1;
pub const IP_MSS: u32 = 576;
pub const RWST_TRYENTER: u32 = 1;
pub const RWST_SIG: u32 = 2;
pub const UIOA_IOV_MAX: u32 = 16;
pub const UIOA_ALLOC: u32 = 1;
pub const UIOA_INIT: u32 = 2;
pub const UIOA_ENABLED: u32 = 4;
pub const UIOA_FINI: u32 = 8;
pub const UIOA_CLR: i32 = -16;
pub const UIOA_POLL: u32 = 16;
pub const UIO_COPY_DEFAULT: u32 = 0;
pub const UIO_COPY_CACHED: u32 = 1;
pub const UIO_ASYNC: u32 = 2;
pub const UIO_XUIO: u32 = 4;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_GROUP: u32 = 3;
pub const PRIO_SESSION: u32 = 4;
pub const PRIO_LWP: u32 = 5;
pub const PRIO_TASK: u32 = 6;
pub const PRIO_PROJECT: u32 = 7;
pub const PRIO_ZONE: u32 = 8;
pub const PRIO_CONTRACT: u32 = 9;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_NOFILE: u32 = 5;
pub const RLIMIT_VMEM: u32 = 6;
pub const RLIMIT_AS: u32 = 6;
pub const RLIM_NLIMITS: u32 = 7;
pub const RLIM_NSAVED: u32 = 7;
pub const _RUSAGESYS_GETRUSAGE: u32 = 0;
pub const _RUSAGESYS_GETRUSAGE_CHLD: u32 = 1;
pub const _RUSAGESYS_GETRUSAGE_LWP: u32 = 2;
pub const _RUSAGESYS_GETVMUSAGE: u32 = 3;
pub const DATAMODEL_MASK: u32 = 267386880;
pub const DATAMODEL_ILP32: u32 = 1048576;
pub const DATAMODEL_LP64: u32 = 2097152;
pub const DATAMODEL_NONE: u32 = 0;
pub const DATAMODEL_NATIVE: u32 = 2097152;
pub const VM_SLEEP: u32 = 0;
pub const VM_NOSLEEP: u32 = 1;
pub const VM_PANIC: u32 = 2;
pub const VM_PUSHPAGE: u32 = 4;
pub const VM_NORMALPRI: u32 = 8;
pub const VM_KMFLAGS: u32 = 255;
pub const VM_BESTFIT: u32 = 256;
pub const VM_FIRSTFIT: u32 = 512;
pub const VM_NEXTFIT: u32 = 1024;
pub const VM_MEMLOAD: u32 = 2048;
pub const VM_NORELOC: u32 = 4096;
pub const VM_ABORT: u32 = 8192;
pub const VM_ENDALLOC: u32 = 16384;
pub const VM_FLAGS: u32 = 65535;
pub const VMC_POPULATOR: u32 = 65536;
pub const VMC_NO_QCACHE: u32 = 131072;
pub const VMC_IDENTIFIER: u32 = 262144;
pub const VMC_DUMPSAFE: u32 = 2097152;
pub const VMC_XALLOC: u32 = 524288;
pub const VMC_XALIGN: u32 = 1048576;
pub const VMC_FLAGS: u32 = 4294901760;
pub const VMEM_ALLOC: u32 = 1;
pub const VMEM_FREE: u32 = 2;
pub const VMEM_SPAN: u32 = 16;
pub const VMEM_ROTOR: u32 = 32;
pub const VMEM_WALKER: u32 = 64;
pub const VMEM_REENTRANT: u32 = 2147483648;
pub const KM_SLEEP: u32 = 0;
pub const KM_NOSLEEP: u32 = 1;
pub const KM_PANIC: u32 = 2;
pub const KM_PUSHPAGE: u32 = 4;
pub const KM_NORMALPRI: u32 = 8;
pub const KM_NOSLEEP_LAZY: u32 = 9;
pub const KM_VMFLAGS: u32 = 255;
pub const KM_FLAGS: u32 = 65535;
pub const KMC_NOTOUCH: u32 = 65536;
pub const KMC_NODEBUG: u32 = 131072;
pub const KMC_NOMAGAZINE: u32 = 262144;
pub const KMC_NOHASH: u32 = 524288;
pub const KMC_QCACHE: u32 = 1048576;
pub const KMC_KMEM_ALLOC: u32 = 2097152;
pub const KMC_IDENTIFIER: u32 = 4194304;
pub const KMC_PREFILL: u32 = 8388608;
pub const B_BUSY: u32 = 1;
pub const B_DONE: u32 = 2;
pub const B_ERROR: u32 = 4;
pub const B_PAGEIO: u32 = 16;
pub const B_PHYS: u32 = 32;
pub const B_READ: u32 = 64;
pub const B_WRITE: u32 = 256;
pub const B_WANTED: u32 = 128;
pub const B_AGE: u32 = 512;
pub const B_ASYNC: u32 = 1024;
pub const B_DELWRI: u32 = 2048;
pub const B_STALE: u32 = 4096;
pub const B_DONTNEED: u32 = 8192;
pub const B_REMAPPED: u32 = 16384;
pub const B_FREE: u32 = 32768;
pub const B_INVAL: u32 = 65536;
pub const B_FORCE: u32 = 131072;
pub const B_NOCACHE: u32 = 524288;
pub const B_TRUNC: u32 = 1048576;
pub const B_SHADOW: u32 = 2097152;
pub const B_RETRYWRI: u32 = 4194304;
pub const B_FAILFAST: u32 = 16777216;
pub const B_STARTED: u32 = 33554432;
pub const B_ABRWRITE: u32 = 67108864;
pub const B_PAGE_NOWAIT: u32 = 134217728;
pub const VOPSTATS_STR: &[u8; 10] = b"vopstats_\0";
pub const VNODE_ALIGN: u32 = 64;
pub const VNODE_ALIGN_LOG2: u32 = 8;
pub const VROOT: u32 = 1;
pub const VNOCACHE: u32 = 2;
pub const VNOMAP: u32 = 4;
pub const VDUP: u32 = 8;
pub const VNOSWAP: u32 = 16;
pub const VNOMOUNT: u32 = 32;
pub const VISSWAP: u32 = 64;
pub const VSWAPLIKE: u32 = 128;
pub const VVFSLOCK: u32 = 256;
pub const VVFSWAIT: u32 = 512;
pub const VVMLOCK: u32 = 1024;
pub const VDIROPEN: u32 = 2048;
pub const VVMEXEC: u32 = 4096;
pub const VPXFS: u32 = 8192;
pub const V_XATTRDIR: u32 = 16384;
pub const V_LOCALITY: u32 = 32768;
pub const VMODSORT: u32 = 65536;
pub const VISSWAPFS: u32 = 131072;
pub const V_SYSATTR: u32 = 262144;
pub const VTRAVERSE: u32 = 524288;
pub const AV_SCANSTAMP_SZ: u32 = 32;
pub const XVA_MAPSIZE: u32 = 3;
pub const XVA_MAGIC: u32 = 2021024116;
pub const AT_TYPE: u32 = 1;
pub const AT_MODE: u32 = 2;
pub const AT_UID: u32 = 4;
pub const AT_GID: u32 = 8;
pub const AT_FSID: u32 = 16;
pub const AT_NODEID: u32 = 32;
pub const AT_NLINK: u32 = 64;
pub const AT_SIZE: u32 = 128;
pub const AT_ATIME: u32 = 256;
pub const AT_MTIME: u32 = 512;
pub const AT_CTIME: u32 = 1024;
pub const AT_RDEV: u32 = 2048;
pub const AT_BLKSIZE: u32 = 4096;
pub const AT_NBLOCKS: u32 = 8192;
pub const AT_SEQ: u32 = 32768;
pub const AT_XVATTR: u32 = 65536;
pub const AT_ALL: u32 = 49151;
pub const AT_STAT: u32 = 4095;
pub const AT_TIMES: u32 = 1792;
pub const AT_NOSET: u32 = 47217;
pub const XAT0_INDEX: u32 = 0;
pub const XAT0_CREATETIME: u32 = 1;
pub const XAT0_ARCHIVE: u32 = 2;
pub const XAT0_SYSTEM: u32 = 4;
pub const XAT0_READONLY: u32 = 8;
pub const XAT0_HIDDEN: u32 = 16;
pub const XAT0_NOUNLINK: u32 = 32;
pub const XAT0_IMMUTABLE: u32 = 64;
pub const XAT0_APPENDONLY: u32 = 128;
pub const XAT0_NODUMP: u32 = 256;
pub const XAT0_OPAQUE: u32 = 512;
pub const XAT0_AV_QUARANTINED: u32 = 1024;
pub const XAT0_AV_MODIFIED: u32 = 2048;
pub const XAT0_AV_SCANSTAMP: u32 = 4096;
pub const XAT0_REPARSE: u32 = 8192;
pub const XAT0_GEN: u32 = 16384;
pub const XAT0_OFFLINE: u32 = 32768;
pub const XAT0_SPARSE: u32 = 65536;
pub const XAT0_PROJINHERIT: u32 = 131072;
pub const XAT0_PROJID: u32 = 262144;
pub const XVA_MASK: u32 = 4294967295;
pub const XVA_SHFT: u32 = 32;
pub const XAT_CREATETIME: u32 = 1;
pub const XAT_ARCHIVE: u32 = 2;
pub const XAT_SYSTEM: u32 = 4;
pub const XAT_READONLY: u32 = 8;
pub const XAT_HIDDEN: u32 = 16;
pub const XAT_NOUNLINK: u32 = 32;
pub const XAT_IMMUTABLE: u32 = 64;
pub const XAT_APPENDONLY: u32 = 128;
pub const XAT_NODUMP: u32 = 256;
pub const XAT_OPAQUE: u32 = 512;
pub const XAT_AV_QUARANTINED: u32 = 1024;
pub const XAT_AV_MODIFIED: u32 = 2048;
pub const XAT_AV_SCANSTAMP: u32 = 4096;
pub const XAT_REPARSE: u32 = 8192;
pub const XAT_GEN: u32 = 16384;
pub const XAT_OFFLINE: u32 = 32768;
pub const XAT_SPARSE: u32 = 65536;
pub const XAT_PROJINHERIT: u32 = 131072;
pub const XAT_PROJID: u32 = 262144;
pub const VSUID: u32 = 2048;
pub const VSGID: u32 = 1024;
pub const VSVTX: u32 = 512;
pub const VREAD: u32 = 256;
pub const VWRITE: u32 = 128;
pub const VEXEC: u32 = 64;
pub const MODEMASK: u32 = 4095;
pub const PERMMASK: u32 = 511;
pub const V_ACE_MASK: u32 = 1;
pub const V_APPEND: u32 = 2;
pub const V_TRUE: u32 = 1;
pub const V_FALSE: u32 = 0;
pub const VSA_ACL: u32 = 1;
pub const VSA_ACLCNT: u32 = 2;
pub const VSA_DFACL: u32 = 4;
pub const VSA_DFACLCNT: u32 = 8;
pub const VSA_ACE: u32 = 16;
pub const VSA_ACECNT: u32 = 32;
pub const VSA_ACE_ALLTYPES: u32 = 64;
pub const VSA_ACE_ACLFLAGS: u32 = 128;
pub const CC_WOULDBLOCK: u32 = 1;
pub const CC_DONTBLOCK: u32 = 2;
pub const VOPNAME_OPEN: &[u8; 5] = b"open\0";
pub const VOPNAME_CLOSE: &[u8; 6] = b"close\0";
pub const VOPNAME_READ: &[u8; 5] = b"read\0";
pub const VOPNAME_WRITE: &[u8; 6] = b"write\0";
pub const VOPNAME_IOCTL: &[u8; 6] = b"ioctl\0";
pub const VOPNAME_SETFL: &[u8; 6] = b"setfl\0";
pub const VOPNAME_GETATTR: &[u8; 8] = b"getattr\0";
pub const VOPNAME_SETATTR: &[u8; 8] = b"setattr\0";
pub const VOPNAME_ACCESS: &[u8; 7] = b"access\0";
pub const VOPNAME_LOOKUP: &[u8; 7] = b"lookup\0";
pub const VOPNAME_CREATE: &[u8; 7] = b"create\0";
pub const VOPNAME_REMOVE: &[u8; 7] = b"remove\0";
pub const VOPNAME_LINK: &[u8; 5] = b"link\0";
pub const VOPNAME_RENAME: &[u8; 7] = b"rename\0";
pub const VOPNAME_MKDIR: &[u8; 6] = b"mkdir\0";
pub const VOPNAME_RMDIR: &[u8; 6] = b"rmdir\0";
pub const VOPNAME_READDIR: &[u8; 8] = b"readdir\0";
pub const VOPNAME_SYMLINK: &[u8; 8] = b"symlink\0";
pub const VOPNAME_READLINK: &[u8; 9] = b"readlink\0";
pub const VOPNAME_FSYNC: &[u8; 6] = b"fsync\0";
pub const VOPNAME_INACTIVE: &[u8; 9] = b"inactive\0";
pub const VOPNAME_FID: &[u8; 4] = b"fid\0";
pub const VOPNAME_RWLOCK: &[u8; 7] = b"rwlock\0";
pub const VOPNAME_RWUNLOCK: &[u8; 9] = b"rwunlock\0";
pub const VOPNAME_SEEK: &[u8; 5] = b"seek\0";
pub const VOPNAME_CMP: &[u8; 4] = b"cmp\0";
pub const VOPNAME_FRLOCK: &[u8; 7] = b"frlock\0";
pub const VOPNAME_SPACE: &[u8; 6] = b"space\0";
pub const VOPNAME_REALVP: &[u8; 7] = b"realvp\0";
pub const VOPNAME_GETPAGE: &[u8; 8] = b"getpage\0";
pub const VOPNAME_PUTPAGE: &[u8; 8] = b"putpage\0";
pub const VOPNAME_MAP: &[u8; 4] = b"map\0";
pub const VOPNAME_ADDMAP: &[u8; 7] = b"addmap\0";
pub const VOPNAME_DELMAP: &[u8; 7] = b"delmap\0";
pub const VOPNAME_POLL: &[u8; 5] = b"poll\0";
pub const VOPNAME_DUMP: &[u8; 5] = b"dump\0";
pub const VOPNAME_PATHCONF: &[u8; 9] = b"pathconf\0";
pub const VOPNAME_PAGEIO: &[u8; 7] = b"pageio\0";
pub const VOPNAME_DUMPCTL: &[u8; 8] = b"dumpctl\0";
pub const VOPNAME_DISPOSE: &[u8; 8] = b"dispose\0";
pub const VOPNAME_GETSECATTR: &[u8; 11] = b"getsecattr\0";
pub const VOPNAME_SETSECATTR: &[u8; 11] = b"setsecattr\0";
pub const VOPNAME_SHRLOCK: &[u8; 8] = b"shrlock\0";
pub const VOPNAME_VNEVENT: &[u8; 8] = b"vnevent\0";
pub const VOPNAME_REQZCBUF: &[u8; 9] = b"reqzcbuf\0";
pub const VOPNAME_RETZCBUF: &[u8; 9] = b"retzcbuf\0";
pub const LOOKUP_DIR: u32 = 1;
pub const LOOKUP_XATTR: u32 = 2;
pub const CREATE_XATTR_DIR: u32 = 4;
pub const LOOKUP_HAVE_SYSATTR_DIR: u32 = 8;
pub const LOOKUP_NOACLCHECK: u32 = 32;
pub const V_RDDIR_ENTFLAGS: u32 = 1;
pub const V_RDDIR_ACCFILTER: u32 = 2;
pub const V_WRITELOCK_TRUE: u32 = 1;
pub const V_WRITELOCK_FALSE: u32 = 0;
pub const DUMP_ALLOC: u32 = 0;
pub const DUMP_FREE: u32 = 1;
pub const DUMP_SCAN: u32 = 2;
pub const ATTR_UTIME: u32 = 1;
pub const ATTR_EXEC: u32 = 2;
pub const ATTR_COMM: u32 = 4;
pub const ATTR_HINT: u32 = 8;
pub const ATTR_REAL: u32 = 16;
pub const ATTR_NOACLCHECK: u32 = 32;
pub const ATTR_TRIGGER: u32 = 64;
pub const ATTR_NOIMPLICIT: u32 = 128;
pub const NMLP_MAX: u32 = 16;
pub const NSLS_MAX: u32 = 4;
pub const SUN_MAC_ID: u32 = 65;
pub const SUN_UCLR_ID: u32 = 73;
pub const _C_LEN: u32 = 8;
pub const SUN_INVALID_ID: u32 = 0;
pub const SUN_CMW_ID: u32 = 131;
pub const SUN_SL_ID: u32 = 65;
pub const SUN_SL_UN: u32 = 241;
pub const SUN_IL_ID: u32 = 66;
pub const SUN_IL_UN: u32 = 115;
pub const SUN_CLR_ID: u32 = 73;
pub const SUN_CLR_UN: u32 = 249;
pub const LOW_CLASS: u32 = 0;
pub const HIGH_CLASS: u32 = 32767;
pub const EMPTY_SET: u32 = 0;
pub const UNIVERSAL_SET: u32 = 4294967295;
pub const EQUALITY_CHECK: u32 = 0;
pub const DOMINANCE_CHECK: u32 = 1;
pub const ADMIN_LOW: &[u8; 10] = b"ADMIN_LOW\0";
pub const ADMIN_HIGH: &[u8; 11] = b"ADMIN_HIGH\0";
pub const DEFAULT_DOI: u32 = 1;
pub const TSLF_UNLABELED: u32 = 1;
pub const TSLF_IMPLICIT_IN: u32 = 2;
pub const TSLF_IMPLICIT_OUT: u32 = 4;
pub const MIB2_SYSTEM: u32 = 257;
pub const MIB2_INTERFACES: u32 = 258;
pub const MIB2_AT: u32 = 259;
pub const MIB2_IP: u32 = 260;
pub const MIB2_ICMP: u32 = 261;
pub const MIB2_TCP: u32 = 262;
pub const MIB2_UDP: u32 = 263;
pub const MIB2_EGP: u32 = 264;
pub const MIB2_CMOT: u32 = 265;
pub const MIB2_TRANSMISSION: u32 = 266;
pub const MIB2_SNMP: u32 = 267;
pub const MIB2_IP6: u32 = 268;
pub const MIB2_ICMP6: u32 = 269;
pub const MIB2_TCP6: u32 = 270;
pub const MIB2_UDP6: u32 = 271;
pub const MIB2_SCTP: u32 = 272;
pub const MIB2_RANGE_START: u32 = 257;
pub const MIB2_RANGE_END: u32 = 272;
pub const EXPER: u32 = 1024;
pub const EXPER_IGMP: u32 = 1025;
pub const EXPER_DVMRP: u32 = 1026;
pub const EXPER_RAWIP: u32 = 1027;
pub const EXPER_IP_AND_ALL_IRES: u32 = 1028;
pub const EXPER_RANGE_START: u32 = 1025;
pub const EXPER_RANGE_END: u32 = 1028;
pub const OCTET_LENGTH: u32 = 32;
pub const MIB2_UNKNOWN_INTERFACE: u32 = 0;
pub const MIB2_UNKNOWN_PROCESS: u32 = 0;
pub const MIB2_IP_ADDR: u32 = 20;
pub const MIB2_IP_ROUTE: u32 = 21;
pub const MIB2_IP_MEDIA: u32 = 22;
pub const MIB2_IP6_ROUTE: u32 = 23;
pub const MIB2_IP6_MEDIA: u32 = 24;
pub const MIB2_IP6_ADDR: u32 = 25;
pub const MIB2_IP_TRAFFIC_STATS: u32 = 31;
pub const EXPER_IP_GROUP_MEMBERSHIP: u32 = 100;
pub const EXPER_IP6_GROUP_MEMBERSHIP: u32 = 101;
pub const EXPER_IP_GROUP_SOURCES: u32 = 102;
pub const EXPER_IP6_GROUP_SOURCES: u32 = 103;
pub const EXPER_IP_RTATTR: u32 = 104;
pub const EXPER_IP_DCE: u32 = 105;
pub const EXPER_XPORT_MLP: u32 = 105;
pub const EXPER_SOCK_INFO: u32 = 106;
pub const MIB2_IP_20: u32 = 20;
pub const MIB2_IP_21: u32 = 21;
pub const MIB2_IP_22: u32 = 22;
pub const MIB2_INETADDRESSTYPE_unknown: u32 = 0;
pub const MIB2_INETADDRESSTYPE_ipv4: u32 = 1;
pub const MIB2_INETADDRESSTYPE_ipv6: u32 = 2;
pub const MIB2_SOCKINFO_STREAM: u32 = 1;
pub const MIB2_SOCKINFO_IPV6: u32 = 2;
pub const MIB2_TMEF_PRIVATE: u32 = 1;
pub const MIB2_TMEF_SHARED: u32 = 2;
pub const MIB2_TMEF_ANONMLP: u32 = 4;
pub const MIB2_TMEF_MACEXEMPT: u32 = 8;
pub const MIB2_TMEF_IS_LABELED: u32 = 16;
pub const MIB2_TMEF_MACIMPLICIT: u32 = 32;
pub const MIB2_TCP_CONN: u32 = 13;
pub const MIB2_TCP6_CONN: u32 = 14;
pub const MIB2_TCP_13: u32 = 13;
pub const MIB2_TCP_closed: u32 = 1;
pub const MIB2_TCP_listen: u32 = 2;
pub const MIB2_TCP_synSent: u32 = 3;
pub const MIB2_TCP_synReceived: u32 = 4;
pub const MIB2_TCP_established: u32 = 5;
pub const MIB2_TCP_finWait1: u32 = 6;
pub const MIB2_TCP_finWait2: u32 = 7;
pub const MIB2_TCP_closeWait: u32 = 8;
pub const MIB2_TCP_lastAck: u32 = 9;
pub const MIB2_TCP_closing: u32 = 10;
pub const MIB2_TCP_timeWait: u32 = 11;
pub const MIB2_TCP_deleteTCB: u32 = 12;
pub const MIB2_UDP_ENTRY: u32 = 5;
pub const MIB2_UDP6_ENTRY: u32 = 6;
pub const MIB2_UDP_5: u32 = 5;
pub const MIB2_UDP_unbound: u32 = 1;
pub const MIB2_UDP_idle: u32 = 2;
pub const MIB2_UDP_connected: u32 = 3;
pub const MIB2_UDP_unknown: u32 = 4;
pub const EXPER_DVMRP_VIF: u32 = 1;
pub const EXPER_DVMRP_MRT: u32 = 2;
pub const MIB2_SCTP_CONN: u32 = 15;
pub const MIB2_SCTP_CONN_LOCAL: u32 = 16;
pub const MIB2_SCTP_CONN_REMOTE: u32 = 17;
pub const MIB2_SCTP_closed: u32 = 1;
pub const MIB2_SCTP_cookieWait: u32 = 2;
pub const MIB2_SCTP_cookieEchoed: u32 = 3;
pub const MIB2_SCTP_established: u32 = 4;
pub const MIB2_SCTP_shutdownPending: u32 = 5;
pub const MIB2_SCTP_shutdownSent: u32 = 6;
pub const MIB2_SCTP_shutdownReceived: u32 = 7;
pub const MIB2_SCTP_shutdownAckSent: u32 = 8;
pub const MIB2_SCTP_deleteTCB: u32 = 9;
pub const MIB2_SCTP_listen: u32 = 10;
pub const MIB2_SCTP_ACTIVE: u32 = 1;
pub const MIB2_SCTP_INACTIVE: u32 = 2;
pub const MIB2_SCTP_ADDR_V4: u32 = 1;
pub const MIB2_SCTP_ADDR_V6: u32 = 2;
pub const MIB2_SCTP_RTOALGO_OTHER: u32 = 1;
pub const MIB2_SCTP_RTOALGO_VANJ: u32 = 2;
pub const O_BITSMAJOR: u32 = 7;
pub const O_BITSMINOR: u32 = 8;
pub const O_MAXMAJ: u32 = 127;
pub const O_MAXMIN: u32 = 255;
pub const L_BITSMAJOR32: u32 = 14;
pub const L_BITSMINOR32: u32 = 18;
pub const L_MAXMAJ32: u32 = 16383;
pub const L_MAXMIN32: u32 = 262143;
pub const L_BITSMAJOR: u32 = 32;
pub const L_BITSMINOR: u32 = 32;
pub const L_MAXMAJ: u32 = 4294967295;
pub const L_MAXMIN: u32 = 4294967295;
pub const ONBITSMAJOR: u32 = 7;
pub const ONBITSMINOR: u32 = 8;
pub const OMAXMAJ: u32 = 127;
pub const OMAXMIN: u32 = 255;
pub const NBITSMAJOR32: u32 = 14;
pub const NBITSMINOR32: u32 = 18;
pub const MAXMAJ32: u32 = 16383;
pub const MAXMIN32: u32 = 262143;
pub const NBITSMAJOR64: u32 = 32;
pub const NBITSMINOR64: u32 = 32;
pub const MAXMAJ64: u32 = 4294967295;
pub const MAXMIN64: u32 = 4294967295;
pub const NBITSMAJOR: u32 = 32;
pub const NBITSMINOR: u32 = 32;
pub const MAXMAJ: u32 = 4294967295;
pub const MAXMIN: u32 = 4294967295;
pub const INET_MIN_DEV: u32 = 2;
pub const POLLIN: u32 = 1;
pub const POLLPRI: u32 = 2;
pub const POLLOUT: u32 = 4;
pub const POLLRDNORM: u32 = 64;
pub const POLLWRNORM: u32 = 4;
pub const POLLRDBAND: u32 = 128;
pub const POLLWRBAND: u32 = 256;
pub const POLLRDHUP: u32 = 16384;
pub const POLLNORM: u32 = 64;
pub const POLLERR: u32 = 8;
pub const POLLHUP: u32 = 16;
pub const POLLNVAL: u32 = 32;
pub const POLLREMOVE: u32 = 2048;
pub const POLLONESHOT: u32 = 4096;
pub const POLLET: u32 = 8192;
pub const POLLRDDATA: u32 = 512;
pub const POLLNOERR: u32 = 1024;
pub const POLLCLOSED: u32 = 32768;
pub const QENAB: u32 = 1;
pub const QWANTR: u32 = 2;
pub const QWANTW: u32 = 4;
pub const QFULL: u32 = 8;
pub const QREADR: u32 = 16;
pub const QUSE: u32 = 32;
pub const QNOENB: u32 = 64;
pub const QWANTRMQSYNC: u32 = 128;
pub const QBACK: u32 = 256;
pub const QPAIR: u32 = 2048;
pub const QPERQ: u32 = 4096;
pub const QPERMOD: u32 = 8192;
pub const QMTSAFE: u32 = 16384;
pub const QMTOUTPERIM: u32 = 32768;
pub const QMT_TYPEMASK: u32 = 63488;
pub const QINSERVICE: u32 = 65536;
pub const QWCLOSE: u32 = 131072;
pub const QEND: u32 = 262144;
pub const QWANTWSYNC: u32 = 524288;
pub const QSYNCSTR: u32 = 1048576;
pub const QISDRV: u32 = 2097152;
pub const _QINSERTING: u32 = 67108864;
pub const _QREMOVING: u32 = 134217728;
pub const _QASSOCIATED: u32 = 268435456;
pub const _QDIRECT: u32 = 536870912;
pub const _QSINGLE_INSTANCE: u32 = 1073741824;
pub const Q_SQQUEUED: u32 = 1;
pub const Q_SQDRAINING: u32 = 2;
pub const QB_FULL: u32 = 1;
pub const QB_WANTW: u32 = 2;
pub const QB_BACK: u32 = 4;
pub const NBAND: u32 = 256;
pub const STRUIOT_NONE: i32 = -1;
pub const STRUIOT_DONTCARE: u32 = 0;
pub const STRUIOT_STANDARD: u32 = 1;
pub const DBLK_REFMAX: u32 = 255;
pub const DBLK_REFMIN: u32 = 1;
pub const DBLK_COOKED: u32 = 2;
pub const DBLK_UIOA: u32 = 4;
pub const STRUIO_SPEC: u32 = 1;
pub const STRUIO_DONE: u32 = 2;
pub const STRUIO_IP: u32 = 4;
pub const STRUIO_ZC: u32 = 8;
pub const STRUIO_ZCNOTIFY: u32 = 16;
pub const MSGMARK: u32 = 1;
pub const MSGNOLOOP: u32 = 2;
pub const MSGDELIM: u32 = 4;
pub const MSGMARKNEXT: u32 = 16;
pub const MSGNOTMARKNEXT: u32 = 32;
pub const MSGWAITSYNC: u32 = 64;
pub const M_DATA: u32 = 0;
pub const M_PROTO: u32 = 1;
pub const M_MULTIDATA: u32 = 2;
pub const M_BREAK: u32 = 8;
pub const M_PASSFP: u32 = 9;
pub const M_EVENT: u32 = 10;
pub const M_SIG: u32 = 11;
pub const M_DELAY: u32 = 12;
pub const M_CTL: u32 = 13;
pub const M_IOCTL: u32 = 14;
pub const M_SETOPTS: u32 = 16;
pub const M_RSE: u32 = 17;
pub const M_IOCACK: u32 = 129;
pub const M_IOCNAK: u32 = 130;
pub const M_PCPROTO: u32 = 131;
pub const M_PCSIG: u32 = 132;
pub const M_READ: u32 = 133;
pub const M_FLUSH: u32 = 134;
pub const M_STOP: u32 = 135;
pub const M_START: u32 = 136;
pub const M_HANGUP: u32 = 137;
pub const M_ERROR: u32 = 138;
pub const M_COPYIN: u32 = 139;
pub const M_COPYOUT: u32 = 140;
pub const M_IOCDATA: u32 = 141;
pub const M_PCRSE: u32 = 142;
pub const M_STOPI: u32 = 143;
pub const M_STARTI: u32 = 144;
pub const M_PCEVENT: u32 = 145;
pub const M_UNHANGUP: u32 = 146;
pub const M_CMD: u32 = 147;
pub const QNORM: u32 = 0;
pub const QPCTL: u32 = 128;
pub const IOC_MODELS: u32 = 267386880;
pub const IOC_ILP32: u32 = 1048576;
pub const IOC_LP64: u32 = 2097152;
pub const IOC_NATIVE: u32 = 2097152;
pub const IOC_NONE: u32 = 0;
pub const SO_ALL: u32 = 63;
pub const SO_READOPT: u32 = 1;
pub const SO_WROFF: u32 = 2;
pub const SO_MINPSZ: u32 = 4;
pub const SO_MAXPSZ: u32 = 8;
pub const SO_HIWAT: u32 = 16;
pub const SO_LOWAT: u32 = 32;
pub const SO_MREADON: u32 = 64;
pub const SO_MREADOFF: u32 = 128;
pub const SO_NDELON: u32 = 256;
pub const SO_NDELOFF: u32 = 512;
pub const SO_ISTTY: u32 = 1024;
pub const SO_ISNTTY: u32 = 2048;
pub const SO_TOSTOP: u32 = 4096;
pub const SO_TONSTOP: u32 = 8192;
pub const SO_BAND: u32 = 16384;
pub const SO_DELIM: u32 = 32768;
pub const SO_NODELIM: u32 = 65536;
pub const SO_STRHOLD: u32 = 131072;
pub const SO_ERROPT: u32 = 262144;
pub const SO_COPYOPT: u32 = 524288;
pub const SO_MAXBLK: u32 = 1048576;
pub const SO_TAIL: u32 = 2097152;
pub const INFOD_FIRSTBYTES: u32 = 2;
pub const INFOD_BYTES: u32 = 4;
pub const INFOD_COUNT: u32 = 8;
pub const INFOD_COPYOUT: u32 = 16;
pub const MODOPEN: u32 = 1;
pub const CLONEOPEN: u32 = 2;
pub const OPENFAIL: i32 = -1;
pub const BPRI_LO: u32 = 1;
pub const BPRI_MED: u32 = 2;
pub const BPRI_HI: u32 = 3;
pub const INFPSZ: i32 = -1;
pub const FLUSHALL: u32 = 1;
pub const FLUSHDATA: u32 = 0;
pub const STRHIGH: u32 = 5120;
pub const STRLOW: u32 = 1024;
pub const PERIM_INNER: u32 = 1;
pub const PERIM_OUTER: u32 = 2;
pub const NDE_ALLOC_COUNT: u32 = 32;
pub const ND_MAX_BUF_LEN: u32 = 65303;
pub const NC_TPI_CLTS: u32 = 1;
pub const NC_TPI_COTS: u32 = 2;
pub const NC_TPI_COTS_ORD: u32 = 3;
pub const NC_TPI_RAW: u32 = 4;
pub const SOCK_STREAM: u32 = 2;
pub const SOCK_DGRAM: u32 = 1;
pub const SOCK_RAW: u32 = 4;
pub const SOCK_RDM: u32 = 5;
pub const SOCK_SEQPACKET: u32 = 6;
pub const SOCK_TYPE_MASK: u32 = 65535;
pub const SOCK_CLOEXEC: u32 = 524288;
pub const SOCK_NONBLOCK: u32 = 1048576;
pub const SOCK_NDELAY: u32 = 2097152;
pub const SOCK_CLOFORK: u32 = 4194304;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_DGRAM_ERRIND: u32 = 512;
pub const SO_RECVUCRED: u32 = 1024;
pub const SO_ATTACH_FILTER: u32 = 1073741825;
pub const SO_DETACH_FILTER: u32 = 1073741826;
pub const SO_SND_COPYAVOID: u32 = 2048;
pub const SO_SND_BUFINFO: u32 = 4096;
pub const SO_DONTLINGER: i32 = -129;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_PROTOTYPE: u32 = 4105;
pub const SO_PROTOCOL: u32 = 4105;
pub const SO_ANON_MLP: u32 = 4106;
pub const SO_MAC_EXEMPT: u32 = 4107;
pub const SO_DOMAIN: u32 = 4108;
pub const SO_RCVPSH: u32 = 4109;
pub const SCM_RIGHTS: u32 = 4112;
pub const SO_SECATTR: u32 = 4113;
pub const SCM_UCRED: u32 = 4114;
pub const SO_TIMESTAMP: u32 = 4115;
pub const SCM_TIMESTAMP: u32 = 4115;
pub const SO_ALLZONES: u32 = 4116;
pub const SO_EXCLBIND: u32 = 4117;
pub const SO_MAC_IMPLICIT: u32 = 4118;
pub const SO_VRRP: u32 = 4119;
pub const SO_SRCADDR: u32 = 8193;
pub const SO_FILEP: u32 = 8194;
pub const SO_UNIX_CLOSE: u32 = 8195;
pub const FIL_ATTACH: u32 = 1;
pub const FIL_DETACH: u32 = 2;
pub const FIL_LIST: u32 = 3;
pub const FILNAME_MAX: u32 = 32;
pub const FILF_PROG: u32 = 1;
pub const FILF_AUTO: u32 = 2;
pub const FILF_BYPASS: u32 = 4;
pub const SO_ACCEPTOR: u32 = 131072;
pub const SO_SOCKSTR: u32 = 262144;
pub const SO_FALLBACK: u32 = 524288;
pub const SOCKET_SLEEP: u32 = 0;
pub const SOCKET_NOSLEEP: u32 = 1;
pub const SOL_SOCKET: u32 = 65535;
pub const SOL_ROUTE: u32 = 65534;
pub const SOL_PACKET: u32 = 65533;
pub const SOL_FILTER: u32 = 65532;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_IMPLINK: u32 = 3;
pub const AF_PUP: u32 = 4;
pub const AF_CHAOS: u32 = 5;
pub const AF_NS: u32 = 6;
pub const AF_NBS: u32 = 7;
pub const AF_ECMA: u32 = 8;
pub const AF_DATAKIT: u32 = 9;
pub const AF_CCITT: u32 = 10;
pub const AF_SNA: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_DLI: u32 = 13;
pub const AF_LAT: u32 = 14;
pub const AF_HYLINK: u32 = 15;
pub const AF_APPLETALK: u32 = 16;
pub const AF_NIT: u32 = 17;
pub const AF_802: u32 = 18;
pub const AF_OSI: u32 = 19;
pub const AF_X25: u32 = 20;
pub const AF_OSINET: u32 = 21;
pub const AF_GOSIP: u32 = 22;
pub const AF_IPX: u32 = 23;
pub const AF_ROUTE: u32 = 24;
pub const AF_LINK: u32 = 25;
pub const AF_INET6: u32 = 26;
pub const AF_KEY: u32 = 27;
pub const AF_NCA: u32 = 28;
pub const AF_POLICY: u32 = 29;
pub const AF_INET_OFFLOAD: u32 = 30;
pub const AF_TRILL: u32 = 31;
pub const AF_PACKET: u32 = 32;
pub const AF_MAX: u32 = 32;
pub const PF_UNSPEC: u32 = 0;
pub const PF_UNIX: u32 = 1;
pub const PF_LOCAL: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_NBS: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_NIT: u32 = 17;
pub const PF_802: u32 = 18;
pub const PF_OSI: u32 = 19;
pub const PF_X25: u32 = 20;
pub const PF_OSINET: u32 = 21;
pub const PF_GOSIP: u32 = 22;
pub const PF_IPX: u32 = 23;
pub const PF_ROUTE: u32 = 24;
pub const PF_LINK: u32 = 25;
pub const PF_INET6: u32 = 26;
pub const PF_KEY: u32 = 27;
pub const PF_NCA: u32 = 28;
pub const PF_POLICY: u32 = 29;
pub const PF_INET_OFFLOAD: u32 = 30;
pub const PF_TRILL: u32 = 31;
pub const PF_PACKET: u32 = 32;
pub const PF_MAX: u32 = 32;
pub const SOMAXCONN: u32 = 128;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_EOR: u32 = 8;
pub const MSG_CTRUNC: u32 = 16;
pub const MSG_TRUNC: u32 = 32;
pub const MSG_WAITALL: u32 = 64;
pub const MSG_DONTWAIT: u32 = 128;
pub const MSG_NOTIFICATION: u32 = 256;
pub const MSG_NOSIGNAL: u32 = 512;
pub const MSG_DUPCTRL: u32 = 2048;
pub const MSG_CMSG_CLOEXEC: u32 = 4096;
pub const MSG_CMSG_CLOFORK: u32 = 8192;
pub const MSG_XPG4_2: u32 = 32768;
pub const MSG_MAXIOVLEN: u32 = 16;
pub const MSG_SENDTO_NOXLATE: u32 = 134217728;
pub const MSG_MBLK_QUICKRELE: u32 = 268435456;
pub const MSG_USERSPACE: u32 = 536870912;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const _CMSG_HDR_ALIGNMENT: u32 = 4;
pub const IFF_UP: u32 = 1;
pub const IFF_BROADCAST: u32 = 2;
pub const IFF_DEBUG: u32 = 4;
pub const IFF_LOOPBACK: u32 = 8;
pub const IFF_POINTOPOINT: u32 = 16;
pub const IFF_NOTRAILERS: u32 = 32;
pub const IFF_RUNNING: u32 = 64;
pub const IFF_NOARP: u32 = 128;
pub const IFF_PROMISC: u32 = 256;
pub const IFF_ALLMULTI: u32 = 512;
pub const IFF_INTELLIGENT: u32 = 1024;
pub const IFF_MULTICAST: u32 = 2048;
pub const IFF_MULTI_BCAST: u32 = 4096;
pub const IFF_UNNUMBERED: u32 = 8192;
pub const IFF_DHCPRUNNING: u32 = 16384;
pub const IFF_PRIVATE: u32 = 32768;
pub const IFF_NOXMIT: u32 = 65536;
pub const IFF_NOLOCAL: u32 = 131072;
pub const IFF_DEPRECATED: u32 = 262144;
pub const IFF_ADDRCONF: u32 = 524288;
pub const IFF_ROUTER: u32 = 1048576;
pub const IFF_NONUD: u32 = 2097152;
pub const IFF_ANYCAST: u32 = 4194304;
pub const IFF_NORTEXCH: u32 = 8388608;
pub const IFF_IPV4: u32 = 16777216;
pub const IFF_IPV6: u32 = 33554432;
pub const IFF_NOACCEPT: u32 = 67108864;
pub const IFF_NOFAILOVER: u32 = 134217728;
pub const IFF_FAILED: u32 = 268435456;
pub const IFF_STANDBY: u32 = 536870912;
pub const IFF_INACTIVE: u32 = 1073741824;
pub const IFF_OFFLINE: u32 = 2147483648;
pub const IFF_XRESOLV: u64 = 4294967296;
pub const IFF_COS_ENABLED: u64 = 8589934592;
pub const IFF_PREFERRED: u64 = 17179869184;
pub const IFF_TEMPORARY: u64 = 34359738368;
pub const IFF_FIXEDMTU: u64 = 68719476736;
pub const IFF_VIRTUAL: u64 = 137438953472;
pub const IFF_DUPLICATE: u64 = 274877906944;
pub const IFF_IPMP: u64 = 549755813888;
pub const IFF_VRRP: u64 = 1099511627776;
pub const IFF_NOLINKLOCAL: u64 = 2199023255552;
pub const IFF_L3PROTECT: u64 = 4398046511104;
pub const IFF_CANTCHANGE: u64 = 8736013826906;
pub const IFF_IPMP_CANTCHANGE: u32 = 268435456;
pub const IFF_IPMP_INVALID: u64 = 8256487552;
pub const IFQ_MAXLEN: u32 = 50;
pub const IFNET_SLOWHZ: u32 = 1;
pub const ND_MAX_HDW_LEN: u32 = 64;
pub const ND_UNCHANGED: u32 = 0;
pub const ND_INCOMPLETE: u32 = 1;
pub const ND_REACHABLE: u32 = 2;
pub const ND_STALE: u32 = 3;
pub const ND_DELAY: u32 = 4;
pub const ND_PROBE: u32 = 5;
pub const ND_UNREACHABLE: u32 = 6;
pub const ND_INITIAL: u32 = 7;
pub const ND_STATE_VALID_MIN: u32 = 0;
pub const ND_STATE_VALID_MAX: u32 = 7;
pub const NDF_ISROUTER_ON: u32 = 1;
pub const NDF_ISROUTER_OFF: u32 = 2;
pub const NDF_ANYCAST_ON: u32 = 4;
pub const NDF_ANYCAST_OFF: u32 = 8;
pub const NDF_PROXY_ON: u32 = 16;
pub const NDF_PROXY_OFF: u32 = 32;
pub const NDF_STATIC: u32 = 64;
pub const _LIFNAMSIZ: u32 = 32;
pub const LIFNAMSIZ: u32 = 32;
pub const LIFGRNAMSIZ: u32 = 32;
pub const IFNAMSIZ: u32 = 16;
pub const LIFC_NOXMIT: u32 = 1;
pub const LIFC_EXTERNAL_SOURCE: u32 = 2;
pub const LIFC_TEMPORARY: u32 = 4;
pub const LIFC_ALLZONES: u32 = 8;
pub const LIFC_UNDER_IPMP: u32 = 16;
pub const LIFC_ENABLED: u32 = 32;
pub const IF_NAMESIZE: u32 = 32;
pub const IF_INDEX_MAX: u32 = 65535;
pub const IGMP_MINLEN: u32 = 8;
pub const IGMP_V3_QUERY_MINLEN: u32 = 12;
pub const IGMP_MEMBERSHIP_QUERY: u32 = 17;
pub const IGMP_V1_MEMBERSHIP_REPORT: u32 = 18;
pub const IGMP_V2_MEMBERSHIP_REPORT: u32 = 22;
pub const IGMP_V3_MEMBERSHIP_REPORT: u32 = 34;
pub const IGMP_V2_LEAVE_GROUP: u32 = 23;
pub const IGMP_DVMRP: u32 = 19;
pub const IGMP_PIM: u32 = 20;
pub const IGMP_MTRACE_RESP: u32 = 30;
pub const IGMP_MTRACE: u32 = 31;
pub const IGMP_MAX_HOST_REPORT_DELAY: u32 = 10;
pub const IGMP_V3_MAXRT_FPMIN: u32 = 128;
pub const IGMP_V3_MAXRT_MANT_MASK: u32 = 15;
pub const IGMP_V3_MAXRT_EXP_MASK: u32 = 112;
pub const IGMP_V3_SFLAG_MASK: u32 = 8;
pub const IGMP_V3_RV_MASK: u32 = 7;
pub const IGMP_V3_QQI_FPMIN: u32 = 128;
pub const IGMP_V3_QQI_MANT_MASK: u32 = 15;
pub const IGMP_V3_QQI_EXP_MASK: u32 = 112;
pub const RTRALERT_LEN: u32 = 4;
pub const RTRALERT_LEN_IN_WORDS: u32 = 1;
pub const IGMP_HOST_MEMBERSHIP_QUERY: u32 = 17;
pub const IGMP_HOST_MEMBERSHIP_REPORT: u32 = 18;
pub const IGMP_HOST_NEW_MEMBERSHIP_REPORT: u32 = 22;
pub const IGMP_HOST_LEAVE_MESSAGE: u32 = 23;
pub const HOOK_VERSION: u32 = 1;
pub const HOOK_RDONLY: u32 = 1;
pub const Hn_ARP: &[u8; 4] = b"arp\0";
pub const Hn_IPV4: &[u8; 5] = b"inet\0";
pub const Hn_IPV6: &[u8; 6] = b"inet6\0";
pub const Hn_VIONA: &[u8; 11] = b"viona_inet\0";
pub const NETINFO_VERSION: u32 = 1;
pub const NHF_INET: &[u8; 9] = b"NHF_INET\0";
pub const NHF_INET6: &[u8; 10] = b"NHF_INET6\0";
pub const NHF_ARP: &[u8; 8] = b"NHF_ARP\0";
pub const NHF_VIONA: &[u8; 10] = b"NHF_VIONA\0";
pub const NH_PHYSICAL_IN: &[u8; 12] = b"PHYSICAL_IN\0";
pub const NH_PHYSICAL_OUT: &[u8; 13] = b"PHYSICAL_OUT\0";
pub const NH_FORWARDING: &[u8; 11] = b"FORWARDING\0";
pub const NH_LOOPBACK_IN: &[u8; 12] = b"LOOPBACK_IN\0";
pub const NH_LOOPBACK_OUT: &[u8; 13] = b"LOOPBACK_OUT\0";
pub const NH_NIC_EVENTS: &[u8; 11] = b"NIC_EVENTS\0";
pub const NH_OBSERVE: &[u8; 10] = b"OBSERVING\0";
pub const NET_HCK_NONE: u32 = 0;
pub const NET_HCK_L3_FULL: u32 = 1;
pub const NET_HCK_L3_PART: u32 = 2;
pub const NET_HCK_L4_FULL: u32 = 16;
pub const NET_HCK_L4_PART: u32 = 32;
pub const HPE_MULTICAST: u32 = 1;
pub const HPE_BROADCAST: u32 = 2;
pub const MCAST_SLOWTIMO_INTERVAL: u32 = 10000;
pub const GRND_NONBLOCK: u32 = 1;
pub const GRND_RANDOM: u32 = 2;
pub const IGMP_OTHERMEMBER: u32 = 0;
pub const IGMP_IREPORTEDLAST: u32 = 1;
pub const IGMP_V1_ROUTER: u32 = 0;
pub const IGMP_V2_ROUTER: u32 = 1;
pub const IGMP_V3_ROUTER: u32 = 2;
pub const MLD_V1_ROUTER: u32 = 1;
pub const MLD_V2_ROUTER: u32 = 2;
pub const MCAST_DEF_ROBUSTNESS: u32 = 2;
pub const MCAST_QUERY_RESP_INTERVAL: u32 = 10;
pub const MCAST_DEF_QUERY_INTERVAL: u32 = 125;
pub const MCAST_DEF_QUERY_RESP_INTERVAL: u32 = 100;
pub const MCAST_DEF_UNSOL_RPT_INTERVAL: u32 = 1;
pub const IGMP_TTL: u32 = 1;
pub const MLD_HOP_LIMIT: u32 = 1;
pub const MH_ERR_NOMEM: i32 = -1;
pub const MH_ERR_DUPLICATE: i32 = -2;
pub const MH_ERR_NOTFOUND: i32 = -3;
pub const MH_WALK_CONTINUE: u32 = 0;
pub const MH_WALK_TERMINATE: u32 = 1;
pub const TX_FANOUT_SIZE: u32 = 128;
pub const IPV6_ABITS: u32 = 128;
pub const IP6_MASK_TABLE_SIZE: u32 = 129;
pub const IP6F_OFF_MASK: u32 = 63743;
pub const IP6F_RESERVED_MASK: u32 = 1536;
pub const IP6F_MORE_FRAG: u32 = 256;
pub const IP6OPT_TYPE_SKIP: u32 = 0;
pub const IP6OPT_TYPE_DISCARD: u32 = 64;
pub const IP6OPT_TYPE_FORCEICMP: u32 = 128;
pub const IP6OPT_TYPE_ICMP: u32 = 192;
pub const IP6OPT_MUTABLE: u32 = 32;
pub const IP6OPT_PAD1: u32 = 0;
pub const IP6OPT_PADN: u32 = 1;
pub const IP6OPT_JUMBO: u32 = 194;
pub const IP6OPT_NSAP_ADDR: u32 = 195;
pub const IP6OPT_TUNNEL_LIMIT: u32 = 4;
pub const IP6OPT_ROUTER_ALERT: u32 = 5;
pub const IP6OPT_BINDING_UPDATE: u32 = 198;
pub const IP6OPT_BINDING_ACK: u32 = 7;
pub const IP6OPT_BINDING_REQ: u32 = 8;
pub const IP6OPT_HOME_ADDRESS: u32 = 201;
pub const IP6OPT_EID: u32 = 138;
pub const IP6OPT_LS: u32 = 10;
pub const IP6_MAX_OPT_LENGTH: u32 = 255;
pub const IP6OPT_JUMBO_LEN: u32 = 6;
pub const IP6_ALERT_MLD: u32 = 0;
pub const IP6_ALERT_RSVP: u32 = 256;
pub const IP6_ALERT_AN: u32 = 512;
pub const IP6_BUF_ACK: u32 = 128;
pub const IP6_BUF_HOME: u32 = 64;
pub const IP6_BUF_COA: u32 = 32;
pub const IP6_BUF_ROUTER: u32 = 16;
pub const IP6LS_DOI_V4: u32 = 0;
pub const IP6LS_TT_LEVEL: u32 = 1;
pub const IP6LS_TT_VECTOR: u32 = 2;
pub const IP6LS_TT_ENUM: u32 = 3;
pub const IP6LS_TT_RANGES: u32 = 4;
pub const IP6LS_TT_V4: u32 = 5;
pub const IP6LS_TT_DEST: u32 = 6;
pub const AVL_BEFORE: u32 = 0;
pub const AVL_AFTER: u32 = 1;
pub const P_INITPID: u32 = 1;
pub const P_INITUID: u32 = 0;
pub const P_INITPGID: u32 = 0;
pub const P_OFFLINE: u32 = 1;
pub const P_ONLINE: u32 = 2;
pub const P_STATUS: u32 = 3;
pub const P_FAULTED: u32 = 4;
pub const P_POWEROFF: u32 = 5;
pub const P_NOINTR: u32 = 6;
pub const P_SPARE: u32 = 7;
pub const P_DISABLED: u32 = 8;
pub const P_BAD: u32 = 4;
pub const P_FORCED: u32 = 268435456;
pub const PS_OFFLINE: &[u8; 9] = b"off-line\0";
pub const PS_ONLINE: &[u8; 8] = b"on-line\0";
pub const PS_FAULTED: &[u8; 8] = b"faulted\0";
pub const PS_POWEROFF: &[u8; 12] = b"powered-off\0";
pub const PS_NOINTR: &[u8; 8] = b"no-intr\0";
pub const PS_SPARE: &[u8; 6] = b"spare\0";
pub const PS_DISABLED: &[u8; 9] = b"disabled\0";
pub const PI_TYPELEN: u32 = 16;
pub const PI_FPUTYPE: u32 = 32;
pub const PBIND_NONE: i32 = -1;
pub const PBIND_QUERY: i32 = -2;
pub const PBIND_HARD: i32 = -3;
pub const PBIND_SOFT: i32 = -4;
pub const PBIND_QUERY_TYPE: i32 = -5;
pub const P_ALL_SIBLINGS: i32 = -1;
pub const SQ_FILL: u32 = 1;
pub const SQ_NODRAIN: u32 = 2;
pub const SQ_PROCESS: u32 = 4;
pub const RTF_UP: u32 = 1;
pub const RTF_GATEWAY: u32 = 2;
pub const RTF_HOST: u32 = 4;
pub const RTF_REJECT: u32 = 8;
pub const RTF_DYNAMIC: u32 = 16;
pub const RTF_MODIFIED: u32 = 32;
pub const RTF_DONE: u32 = 64;
pub const RTF_MASK: u32 = 128;
pub const RTF_CLONING: u32 = 256;
pub const RTF_XRESOLVE: u32 = 512;
pub const RTF_LLINFO: u32 = 1024;
pub const RTF_STATIC: u32 = 2048;
pub const RTF_BLACKHOLE: u32 = 4096;
pub const RTF_PRIVATE: u32 = 8192;
pub const RTF_PROTO2: u32 = 16384;
pub const RTF_PROTO1: u32 = 32768;
pub const RTF_MULTIRT: u32 = 65536;
pub const RTF_SETSRC: u32 = 131072;
pub const RTF_INDIRECT: u32 = 262144;
pub const RTF_KERNEL: u32 = 524288;
pub const RTF_ZONE: u32 = 1048576;
pub const RTM_VERSION: u32 = 3;
pub const RTM_ADD: u32 = 1;
pub const RTM_DELETE: u32 = 2;
pub const RTM_CHANGE: u32 = 3;
pub const RTM_GET: u32 = 4;
pub const RTM_LOSING: u32 = 5;
pub const RTM_REDIRECT: u32 = 6;
pub const RTM_MISS: u32 = 7;
pub const RTM_LOCK: u32 = 8;
pub const RTM_OLDADD: u32 = 9;
pub const RTM_OLDDEL: u32 = 10;
pub const RTM_RESOLVE: u32 = 11;
pub const RTM_NEWADDR: u32 = 12;
pub const RTM_DELADDR: u32 = 13;
pub const RTM_IFINFO: u32 = 14;
pub const RTM_CHGADDR: u32 = 15;
pub const RTM_FREEADDR: u32 = 16;
pub const RTV_MTU: u32 = 1;
pub const RTV_HOPCOUNT: u32 = 2;
pub const RTV_EXPIRE: u32 = 4;
pub const RTV_RPIPE: u32 = 8;
pub const RTV_SPIPE: u32 = 16;
pub const RTV_SSTHRESH: u32 = 32;
pub const RTV_RTT: u32 = 64;
pub const RTV_RTTVAR: u32 = 128;
pub const RTA_DST: u32 = 1;
pub const RTA_GATEWAY: u32 = 2;
pub const RTA_NETMASK: u32 = 4;
pub const RTA_GENMASK: u32 = 8;
pub const RTA_IFP: u32 = 16;
pub const RTA_IFA: u32 = 32;
pub const RTA_AUTHOR: u32 = 64;
pub const RTA_BRD: u32 = 128;
pub const RTA_SRC: u32 = 256;
pub const RTA_NUMBITS: u32 = 9;
pub const RTAX_DST: u32 = 0;
pub const RTAX_GATEWAY: u32 = 1;
pub const RTAX_NETMASK: u32 = 2;
pub const RTAX_GENMASK: u32 = 3;
pub const RTAX_IFP: u32 = 4;
pub const RTAX_IFA: u32 = 5;
pub const RTAX_AUTHOR: u32 = 6;
pub const RTAX_BRD: u32 = 7;
pub const RTAX_SRC: u32 = 8;
pub const RTAX_MAX: u32 = 9;
pub const RTMEX_GATEWAY_SECATTR: u32 = 1;
pub const RTMEX_MAX: u32 = 1;
pub const RTSA_MINSL: u32 = 1;
pub const RTSA_MAXSL: u32 = 2;
pub const RTSA_DOI: u32 = 4;
pub const RTSA_CIPSO: u32 = 256;
pub const RTSA_SLRANGE: u32 = 3;
pub const RT_AWARE: u32 = 1;
pub const RTAW_DEFAULT: u32 = 0;
pub const RTAW_UNDER_IPMP: u32 = 16;
pub const AT_NULL: u32 = 0;
pub const AT_IGNORE: u32 = 1;
pub const AT_EXECFD: u32 = 2;
pub const AT_PHDR: u32 = 3;
pub const AT_PHENT: u32 = 4;
pub const AT_PHNUM: u32 = 5;
pub const AT_PAGESZ: u32 = 6;
pub const AT_BASE: u32 = 7;
pub const AT_FLAGS: u32 = 8;
pub const AT_ENTRY: u32 = 9;
pub const AT_SUN_UID: u32 = 2000;
pub const AT_SUN_RUID: u32 = 2001;
pub const AT_SUN_GID: u32 = 2002;
pub const AT_SUN_RGID: u32 = 2003;
pub const AT_SUN_LDELF: u32 = 2004;
pub const AT_SUN_LDSHDR: u32 = 2005;
pub const AT_SUN_LDNAME: u32 = 2006;
pub const AT_SUN_LPAGESZ: u32 = 2007;
pub const AT_SUN_PLATFORM: u32 = 2008;
pub const AT_SUN_HWCAP: u32 = 2009;
pub const AT_SUN_HWCAP2: u32 = 2023;
pub const AT_SUN_HWCAP3: u32 = 2029;
pub const AT_SUN_IFLUSH: u32 = 2010;
pub const AT_SUN_CPU: u32 = 2011;
pub const AT_SUN_EXECNAME: u32 = 2014;
pub const AT_SUN_MMU: u32 = 2015;
pub const AT_SUN_LDDATA: u32 = 2016;
pub const AT_SUN_AUXFLAGS: u32 = 2017;
pub const AT_SUN_EMULATOR: u32 = 2018;
pub const AT_SUN_BRANDNAME: u32 = 2019;
pub const AT_SUN_BRAND_AUX1: u32 = 2020;
pub const AT_SUN_BRAND_AUX2: u32 = 2021;
pub const AT_SUN_BRAND_AUX3: u32 = 2022;
pub const AT_SUN_COMMPAGE: u32 = 2026;
pub const AT_SUN_FPTYPE: u32 = 2027;
pub const AT_SUN_FPSIZE: u32 = 2028;
pub const AF_SUN_SETUGID: u32 = 1;
pub const AF_SUN_HWCAPVERIFY: u32 = 2;
pub const AF_SUN_NOPLM: u32 = 4;
pub const AV_386_FPU: u32 = 1;
pub const AV_386_TSC: u32 = 2;
pub const AV_386_CX8: u32 = 4;
pub const AV_386_SEP: u32 = 8;
pub const AV_386_AMD_SYSC: u32 = 16;
pub const AV_386_CMOV: u32 = 32;
pub const AV_386_MMX: u32 = 64;
pub const AV_386_AMD_MMX: u32 = 128;
pub const AV_386_AMD_3DNow: u32 = 256;
pub const AV_386_AMD_3DNowx: u32 = 512;
pub const AV_386_FXSR: u32 = 1024;
pub const AV_386_SSE: u32 = 2048;
pub const AV_386_SSE2: u32 = 4096;
pub const AV_386_SSE3: u32 = 16384;
pub const AV_386_CX16: u32 = 65536;
pub const AV_386_AHF: u32 = 131072;
pub const AV_386_TSCP: u32 = 262144;
pub const AV_386_AMD_SSE4A: u32 = 524288;
pub const AV_386_POPCNT: u32 = 1048576;
pub const AV_386_AMD_LZCNT: u32 = 2097152;
pub const AV_386_SSSE3: u32 = 4194304;
pub const AV_386_SSE4_1: u32 = 8388608;
pub const AV_386_SSE4_2: u32 = 16777216;
pub const AV_386_MOVBE: u32 = 33554432;
pub const AV_386_AES: u32 = 67108864;
pub const AV_386_PCLMULQDQ: u32 = 134217728;
pub const AV_386_XSAVE: u32 = 268435456;
pub const AV_386_AVX: u32 = 536870912;
pub const AV_386_VMX: u32 = 1073741824;
pub const AV_386_AMD_SVM: u32 = 2147483648;
pub const FMT_AV_386 : & [u8 ; 173] = b"\x10 svm\x1Fvmx\x1Eavx\x1Dxsave\x1Cpclmulqdq\x1Baes\x1Amovbe\x19sse4.2\x18sse4.1\x17ssse3\x16amd_lzcnt\x15popcnt\x14amd_sse4a\x13tscp\x12ahf\x11cx16\x0Fsse3\rsse2\x0Csse\x0Bfxsr\namd3dx\tamd3d\x08amdmmx\x07mmx\x06cmov\x05amdsysc\x04sep\x03cx8\x02tsc\x01fpu\0" ;
pub const AV_386_2_F16C: u32 = 1;
pub const AV_386_2_RDRAND: u32 = 2;
pub const AV_386_2_BMI1: u32 = 4;
pub const AV_386_2_BMI2: u32 = 8;
pub const AV_386_2_FMA: u32 = 16;
pub const AV_386_2_AVX2: u32 = 32;
pub const AV_386_2_ADX: u32 = 64;
pub const AV_386_2_RDSEED: u32 = 128;
pub const AV_386_2_AVX512F: u32 = 256;
pub const AV_386_2_AVX512DQ: u32 = 512;
pub const AV_386_2_AVX512IFMA: u32 = 1024;
pub const AV_386_2_AVX512PF: u32 = 2048;
pub const AV_386_2_AVX512ER: u32 = 4096;
pub const AV_386_2_AVX512CD: u32 = 8192;
pub const AV_386_2_AVX512BW: u32 = 16384;
pub const AV_386_2_AVX512VL: u32 = 32768;
pub const AV_386_2_AVX512VBMI: u32 = 65536;
pub const AV_386_2_AVX512VPOPCDQ: u32 = 131072;
pub const AV_386_2_AVX512_4NNIW: u32 = 262144;
pub const AV_386_2_AVX512_4FMAPS: u32 = 524288;
pub const AV_386_2_SHA: u32 = 1048576;
pub const AV_386_2_FSGSBASE: u32 = 2097152;
pub const AV_386_2_CLFLUSHOPT: u32 = 4194304;
pub const AV_386_2_CLWB: u32 = 8388608;
pub const AV_386_2_MONITORX: u32 = 16777216;
pub const AV_386_2_CLZERO: u32 = 33554432;
pub const AV_386_2_AVX512_VNNI: u32 = 67108864;
pub const AV_386_2_VPCLMULQDQ: u32 = 134217728;
pub const AV_386_2_VAES: u32 = 268435456;
pub const AV_386_2_GFNI: u32 = 536870912;
pub const AV_386_2_AVX512_VP2INT: u32 = 1073741824;
pub const AV_386_2_AVX512_BITALG: u32 = 2147483648;
pub const FMT_AV_386_2 : & [u8 ; 281] = b" avx512_vbmi2\x1Favx512_vp2intersect\x1Egfni\x1Dvaes\x1Cvpclmulqdq\x1Bavx512_vnni\x1Aclzero\x19monitorx\x18clwb\x17clflushopt\x16fsgsbase\x15sha\x14avx512_4fmaps\x13avx512_4nniw\x12avx512vpopcntdq\x11avx512vbmi\x10avx512vl\x0Favx512bw\x0Eavx512cd\ravx512er\x0Cavx512pf\x0Bavx512ifma\navx512dq\tavx512f\x08rdseed\x07adx\x06avx2\x05fma\x04bmi2\x03bmi1\x02rdrand\x01f16c\0" ;
pub const AV_386_3_AVX512_VBMI2: u32 = 1;
pub const AV_386_3_AVX512_BF16: u32 = 2;
pub const FMT_AV_386_3: &[u8; 26] = b"\x02avx512_bf16\x01avx512_vbmi2\0";
pub const AT_386_FPINFO_NONE: u32 = 0;
pub const AT_386_FPINFO_FXSAVE: u32 = 1;
pub const AT_386_FPINFO_XSAVE: u32 = 2;
pub const AT_386_FPINFO_XSAVE_AMD: u32 = 3;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const ENOMSG: u32 = 35;
pub const EIDRM: u32 = 36;
pub const ECHRNG: u32 = 37;
pub const EL2NSYNC: u32 = 38;
pub const EL3HLT: u32 = 39;
pub const EL3RST: u32 = 40;
pub const ELNRNG: u32 = 41;
pub const EUNATCH: u32 = 42;
pub const ENOCSI: u32 = 43;
pub const EL2HLT: u32 = 44;
pub const EDEADLK: u32 = 45;
pub const ENOLCK: u32 = 46;
pub const ECANCELED: u32 = 47;
pub const ENOTSUP: u32 = 48;
pub const EDQUOT: u32 = 49;
pub const EBADE: u32 = 50;
pub const EBADR: u32 = 51;
pub const EXFULL: u32 = 52;
pub const ENOANO: u32 = 53;
pub const EBADRQC: u32 = 54;
pub const EBADSLT: u32 = 55;
pub const EDEADLOCK: u32 = 56;
pub const EBFONT: u32 = 57;
pub const EOWNERDEAD: u32 = 58;
pub const ENOTRECOVERABLE: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const ELOCKUNMAPPED: u32 = 72;
pub const ENOTACTIVE: u32 = 73;
pub const EMULTIHOP: u32 = 74;
pub const EBADMSG: u32 = 77;
pub const ENAMETOOLONG: u32 = 78;
pub const EOVERFLOW: u32 = 79;
pub const ENOTUNIQ: u32 = 80;
pub const EBADFD: u32 = 81;
pub const EREMCHG: u32 = 82;
pub const ELIBACC: u32 = 83;
pub const ELIBBAD: u32 = 84;
pub const ELIBSCN: u32 = 85;
pub const ELIBMAX: u32 = 86;
pub const ELIBEXEC: u32 = 87;
pub const EILSEQ: u32 = 88;
pub const ENOSYS: u32 = 89;
pub const ELOOP: u32 = 90;
pub const ERESTART: u32 = 91;
pub const ESTRPIPE: u32 = 92;
pub const ENOTEMPTY: u32 = 93;
pub const EUSERS: u32 = 94;
pub const ENOTSOCK: u32 = 95;
pub const EDESTADDRREQ: u32 = 96;
pub const EMSGSIZE: u32 = 97;
pub const EPROTOTYPE: u32 = 98;
pub const ENOPROTOOPT: u32 = 99;
pub const EPROTONOSUPPORT: u32 = 120;
pub const ESOCKTNOSUPPORT: u32 = 121;
pub const EOPNOTSUPP: u32 = 122;
pub const EPFNOSUPPORT: u32 = 123;
pub const EAFNOSUPPORT: u32 = 124;
pub const EADDRINUSE: u32 = 125;
pub const EADDRNOTAVAIL: u32 = 126;
pub const ENETDOWN: u32 = 127;
pub const ENETUNREACH: u32 = 128;
pub const ENETRESET: u32 = 129;
pub const ECONNABORTED: u32 = 130;
pub const ECONNRESET: u32 = 131;
pub const ENOBUFS: u32 = 132;
pub const EISCONN: u32 = 133;
pub const ENOTCONN: u32 = 134;
pub const ESHUTDOWN: u32 = 143;
pub const ETOOMANYREFS: u32 = 144;
pub const ETIMEDOUT: u32 = 145;
pub const ECONNREFUSED: u32 = 146;
pub const EHOSTDOWN: u32 = 147;
pub const EHOSTUNREACH: u32 = 148;
pub const EWOULDBLOCK: u32 = 11;
pub const EALREADY: u32 = 149;
pub const EINPROGRESS: u32 = 150;
pub const ESTALE: u32 = 151;
pub const PSARGSZ: u32 = 80;
pub const MAXCOMLEN: u32 = 16;
pub const __KERN_NAUXV_IMPL: u32 = 26;
pub const WP_NOWATCH: u32 = 1;
pub const WP_SETPROT: u32 = 2;
pub const _TIMER_MAX: u32 = 32;
pub const _TIMER_ALLOC_INIT: u32 = 8;
pub const ITLK_LOCKED: u32 = 1;
pub const ITLK_WANTED: u32 = 2;
pub const ITLK_REMOVE: u32 = 4;
pub const IT_SIGNAL: u32 = 1;
pub const IT_PORT: u32 = 2;
pub const RCTL_LOCAL_NOACTION: u32 = 0;
pub const RCTL_LOCAL_SIGNAL: u32 = 1;
pub const RCTL_LOCAL_DENY: u32 = 2;
pub const RCTL_LOCAL_MAXIMAL: u32 = 2147483648;
pub const RCTL_LOCAL_PROJDB: u32 = 1073741824;
pub const RCTL_LOCAL_ACTION_MASK: u32 = 4294901760;
pub const RCTL_LOCAL_MASK: u32 = 3221225475;
pub const RCTL_GLOBAL_NOACTION: u32 = 0;
pub const RCTL_GLOBAL_SYSLOG: u32 = 1;
pub const RCTL_GLOBAL_NOBASIC: u32 = 2147483648;
pub const RCTL_GLOBAL_LOWERABLE: u32 = 1073741824;
pub const RCTL_GLOBAL_DENY_ALWAYS: u32 = 536870912;
pub const RCTL_GLOBAL_DENY_NEVER: u32 = 268435456;
pub const RCTL_GLOBAL_FILE_SIZE: u32 = 134217728;
pub const RCTL_GLOBAL_CPU_TIME: u32 = 67108864;
pub const RCTL_GLOBAL_SIGNAL_NEVER: u32 = 33554432;
pub const RCTL_GLOBAL_NOLOCALACTION: u32 = 33554432;
pub const RCTL_GLOBAL_INFINITE: u32 = 16777216;
pub const RCTL_GLOBAL_UNOBSERVABLE: u32 = 8388608;
pub const RCTL_GLOBAL_SYSLOG_NEVER: u32 = 524288;
pub const RCTL_GLOBAL_BYTES: u32 = 4194304;
pub const RCTL_GLOBAL_SECONDS: u32 = 2097152;
pub const RCTL_GLOBAL_COUNT: u32 = 1048576;
pub const RCTL_GLOBAL_ACTION_MASK: u32 = 4294901760;
pub const RCTL_GLOBAL_MASK: u32 = 4294443009;
pub const RCTL_FIRST: u32 = 0;
pub const RCTL_NEXT: u32 = 1;
pub const RCTL_USAGE: u32 = 2;
pub const RCTL_INSERT: u32 = 0;
pub const RCTL_DELETE: u32 = 1;
pub const RCTL_REPLACE: u32 = 2;
pub const RCTL_USE_RECIPIENT_PID: u32 = 268435456;
pub const RCTLSYS_ACTION_MASK: u32 = 4294901760;
pub const RCTLSYS_MASK: u32 = 268435459;
pub const RCPRIV_BASIC: u32 = 16777216;
pub const RCPRIV_PRIVILEGED: u32 = 67108864;
pub const RCPRIV_SYSTEM: u32 = 117440512;
pub const RCT_NONE: u32 = 0;
pub const RCT_DENY: u32 = 1;
pub const RCT_SIGNAL: u32 = 2;
pub const RCT_STRLOG: u32 = 4;
pub const RCT_LK_ABANDONED: u32 = 2147483648;
pub const RCD_DUP: u32 = 1;
pub const RCD_CALLBACK: u32 = 2;
pub const RCA_SAFE: u32 = 0;
pub const RCA_UNSAFE_SIGINFO: u32 = 1;
pub const RCA_UNSAFE_ALL: u32 = 2;
pub const SFD_CLOEXEC: u32 = 524288;
pub const SFD_NONBLOCK: u32 = 2048;
pub const SIGNALFDMNRN_SIGNALFD: u32 = 0;
pub const SIGNALFDMNRN_CLONE: u32 = 1;
pub const PID_ALLOC_PROC: u32 = 1;
pub const SSLEEP: u32 = 1;
pub const SRUN: u32 = 2;
pub const SZOMB: u32 = 3;
pub const SSTOP: u32 = 4;
pub const SIDL: u32 = 5;
pub const SONPROC: u32 = 6;
pub const SWAIT: u32 = 7;
pub const CLDPEND: u32 = 1;
pub const CLDCONT: u32 = 2;
pub const CLDNOSIGCHLD: u32 = 4;
pub const CLDWAITPID: u32 = 8;
pub const P_PR_TRACE: u32 = 1;
pub const P_PR_PTRACE: u32 = 2;
pub const P_PR_FORK: u32 = 4;
pub const P_PR_LOCK: u32 = 8;
pub const P_PR_ASYNC: u32 = 16;
pub const P_PR_EXEC: u32 = 32;
pub const P_PR_BPTADJ: u32 = 64;
pub const P_PR_RUNLCL: u32 = 128;
pub const P_PR_KILLCL: u32 = 256;
pub const SSYS: u32 = 1;
pub const SEXITING: u32 = 2;
pub const SITBUSY: u32 = 4;
pub const SFORKING: u32 = 8;
pub const SWATCHOK: u32 = 16;
pub const SKILLED: u32 = 256;
pub const SSCONT: u32 = 512;
pub const SZONETOP: u32 = 1024;
pub const SEXTKILLED: u32 = 2048;
pub const SUGID: u32 = 8192;
pub const SEXECED: u32 = 16384;
pub const SJCTL: u32 = 65536;
pub const SNOWAIT: u32 = 131072;
pub const SVFORK: u32 = 262144;
pub const SVFWAIT: u32 = 524288;
pub const SEXITLWPS: u32 = 1048576;
pub const SHOLDFORK: u32 = 2097152;
pub const SHOLDFORK1: u32 = 8388608;
pub const SCOREDUMP: u32 = 16777216;
pub const SMSACCT: u32 = 33554432;
pub const SLWPWRAP: u32 = 67108864;
pub const SAUTOLPG: u32 = 134217728;
pub const SNOCD: u32 = 268435456;
pub const SHOLDWATCH: u32 = 536870912;
pub const SMSFORK: u32 = 1073741824;
pub const SDOCORE: u32 = 2147483648;
pub const PBWAIT: u32 = 1;
pub const PEXITED: u32 = 2;
pub const P_UPF_PANICKED: u32 = 1;
pub const P_UPF_HAVEMSG: u32 = 2;
pub const P_UPF_TRUNCMSG: u32 = 4;
pub const P_UPF_INVALMSG: u32 = 8;
pub const FORREAL: u32 = 0;
pub const JUSTLOOKING: u32 = 1;
pub const SUSPEND_NORMAL: u32 = 0;
pub const SUSPEND_PAUSE: u32 = 1;
pub const NOCLASS: i32 = -1;
pub const CLASS_UNUSED: i32 = -2;
pub const CTXOP_TPL_REV: u32 = 1;
pub const DEVID_NONE: u32 = 0;
pub const DEVID_SCSI3_WWN: u32 = 1;
pub const DEVID_SCSI_SERIAL: u32 = 2;
pub const DEVID_FAB: u32 = 3;
pub const DEVID_ENCAP: u32 = 4;
pub const DEVID_ATA_SERIAL: u32 = 5;
pub const DEVID_SCSI3_VPD_T10: u32 = 6;
pub const DEVID_SCSI3_VPD_EUI: u32 = 7;
pub const DEVID_SCSI3_VPD_NAA: u32 = 8;
pub const DEVID_NVME_NSID: u32 = 9;
pub const DEVID_NVME_EUI64: u32 = 10;
pub const DEVID_NVME_NGUID: u32 = 11;
pub const DEVID_MAXTYPE: u32 = 11;
pub const DEVID_SCSI_ENCODE_VERSION1: u32 = 0;
pub const DEVID_SCSI_ENCODE_VERSION2: u32 = 1;
pub const DEVID_SCSI_ENCODE_VERSION_LATEST: u32 = 1;
pub const DEVID_SMP_ENCODE_VERSION1: u32 = 0;
pub const DEVID_SMP_ENCODE_VERSION_LATEST: u32 = 0;
pub const DDI_DEVICE_ATTR_V0: u32 = 1;
pub const DDI_DEVICE_ATTR_V1: u32 = 2;
pub const DDI_NEVERSWAP_ACC: u32 = 0;
pub const DDI_STRUCTURE_LE_ACC: u32 = 1;
pub const DDI_STRUCTURE_BE_ACC: u32 = 2;
pub const DDI_STRICTORDER_ACC: u32 = 0;
pub const DDI_UNORDERED_OK_ACC: u32 = 1;
pub const DDI_MERGING_OK_ACC: u32 = 2;
pub const DDI_LOADCACHING_OK_ACC: u32 = 3;
pub const DDI_STORECACHING_OK_ACC: u32 = 4;
pub const DDI_DATA_SZ01_ACC: u32 = 1;
pub const DDI_DATA_SZ02_ACC: u32 = 2;
pub const DDI_DATA_SZ04_ACC: u32 = 4;
pub const DDI_DATA_SZ08_ACC: u32 = 8;
pub const VERS_ACCHDL: u32 = 1;
pub const DDI_DEFAULT_ACC: u32 = 1;
pub const DDI_FLAGERR_ACC: u32 = 2;
pub const DDI_CAUTIOUS_ACC: u32 = 3;
pub const A_REBOOT: u32 = 1;
pub const A_SHUTDOWN: u32 = 2;
pub const A_FREEZE: u32 = 3;
pub const A_REMOUNT: u32 = 4;
pub const A_DUMP: u32 = 5;
pub const A_FTRACE: u32 = 15;
pub const A_SWAPCTL: u32 = 16;
pub const A_SDTTEST: u32 = 22;
pub const A_CONFIG: u32 = 23;
pub const AD_UNKNOWN: i32 = -1;
pub const AD_HALT: u32 = 0;
pub const AD_BOOT: u32 = 1;
pub const AD_IBOOT: u32 = 2;
pub const AD_SBOOT: u32 = 3;
pub const AD_SIBOOT: u32 = 4;
pub const AD_POWEROFF: u32 = 6;
pub const AD_NOSYNC: u32 = 7;
pub const AD_FASTREBOOT: u32 = 8;
pub const AD_FASTREBOOT_DRYRUN: u32 = 9;
pub const AD_COMPRESS: u32 = 0;
pub const AD_FORCE: u32 = 1;
pub const AD_CHECK: u32 = 2;
pub const AD_SUSPEND_TO_DISK: u32 = 0;
pub const AD_CHECK_SUSPEND_TO_DISK: u32 = 2;
pub const AD_SUSPEND_TO_RAM: u32 = 20;
pub const AD_CHECK_SUSPEND_TO_RAM: u32 = 21;
pub const AD_REUSEINIT: u32 = 3;
pub const AD_REUSABLE: u32 = 4;
pub const AD_REUSEFINI: u32 = 5;
pub const AD_FTRACE_START: u32 = 1;
pub const AD_FTRACE_STOP: u32 = 2;
pub const AD_UPDATE_BOOT_CONFIG: u32 = 1;
pub const BOOTARGS_MAX: u32 = 256;
pub const UA_FASTREBOOT_DEFAULT: u32 = 1;
pub const UA_FASTREBOOT_ONPANIC: u32 = 2;
pub const FASTREBOOT_DEFAULT: &[u8; 19] = b"fastreboot_default\0";
pub const FASTREBOOT_ONPANIC: &[u8; 19] = b"fastreboot_onpanic\0";
pub const FASTREBOOT_ONPANIC_CMDLINE: &[u8; 27] =
    b"fastreboot_onpanic_cmdline\0";
pub const TOD_GET_FAILED: u32 = 1;
pub const TOD_SET_DONE: u32 = 2;
pub const TOD_CPR_RESUME_DONE: u32 = 4;
pub const TOD_DR_RESUME_DONE: u32 = 8;
pub const NSYSCALL: u32 = 256;
pub const SE_32RVAL1: u32 = 0;
pub const SE_32RVAL2: u32 = 1;
pub const SE_64RVAL: u32 = 2;
pub const SE_RVAL_MASK: u32 = 3;
pub const SE_LOADABLE: u32 = 8;
pub const SE_LOADED: u32 = 16;
pub const SE_NOUNLOAD: u32 = 32;
pub const SE_ARGC: u32 = 64;
pub const INITNAME_SZ: u32 = 32;
pub const __lintzero: u32 = 0;
pub const RNF_NORMAL: u32 = 1;
pub const RNF_ROOT: u32 = 2;
pub const RNF_ACTIVE: u32 = 4;
pub const IP_MOD_NAME: &[u8; 3] = b"ip\0";
pub const IP_DEV_NAME: &[u8; 8] = b"/dev/ip\0";
pub const IP6_DEV_NAME: &[u8; 9] = b"/dev/ip6\0";
pub const UDP_MOD_NAME: &[u8; 4] = b"udp\0";
pub const UDP_DEV_NAME: &[u8; 9] = b"/dev/udp\0";
pub const UDP6_DEV_NAME: &[u8; 10] = b"/dev/udp6\0";
pub const TCP_MOD_NAME: &[u8; 4] = b"tcp\0";
pub const TCP_DEV_NAME: &[u8; 9] = b"/dev/tcp\0";
pub const TCP6_DEV_NAME: &[u8; 10] = b"/dev/tcp6\0";
pub const SCTP_MOD_NAME: &[u8; 5] = b"sctp\0";
pub const IP_ABITS: u32 = 32;
pub const IPV4_ABITS: u32 = 32;
pub const IP_MAX_HW_LEN: u32 = 40;
pub const IPV4_ADDR_LEN: u32 = 4;
pub const IP_ADDR_LEN: u32 = 4;
pub const IP_ARP_PROTO_TYPE: u32 = 2048;
pub const IPV4_VERSION: u32 = 4;
pub const IP_VERSION: u32 = 4;
pub const IP_SIMPLE_HDR_LENGTH_IN_WORDS: u32 = 5;
pub const IP_SIMPLE_HDR_LENGTH: u32 = 20;
pub const IP_MAX_HDR_LENGTH: u32 = 60;
pub const IP_MAX_OPT_LENGTH: u32 = 40;
pub const IP_MIN_MTU: u32 = 68;
pub const IP_SIMPLE_HDR_VERSION: u32 = 69;
pub const UDPH_SIZE: u32 = 8;
pub const IP_IOC_IRE_DELETE: u32 = 4;
pub const IP_IOC_IRE_DELETE_NO_REPLY: u32 = 5;
pub const IP_IOC_RTS_REQUEST: u32 = 7;
pub const IPOPTP_ERROR: u32 = 1;
pub const IP_FORWARD_NEVER: u32 = 0;
pub const IP_FORWARD_ALWAYS: u32 = 1;
pub const IP_REASS_COMPLETE: u32 = 1;
pub const IP_REASS_PARTIAL: u32 = 2;
pub const IP_REASS_FAILED: u32 = 4;
pub const IP_SQUEUE_ENTER_NODRAIN: u32 = 1;
pub const IP_SQUEUE_ENTER: u32 = 2;
pub const IP_SQUEUE_FILL: u32 = 3;
pub const ICMP_ECHO_REPLY: u32 = 0;
pub const ICMP_DEST_UNREACHABLE: u32 = 3;
pub const ICMP_SOURCE_QUENCH: u32 = 4;
pub const ICMP_REDIRECT: u32 = 5;
pub const ICMP_ECHO_REQUEST: u32 = 8;
pub const ICMP_ROUTER_ADVERTISEMENT: u32 = 9;
pub const ICMP_ROUTER_SOLICITATION: u32 = 10;
pub const ICMP_TIME_EXCEEDED: u32 = 11;
pub const ICMP_PARAM_PROBLEM: u32 = 12;
pub const ICMP_TIME_STAMP_REQUEST: u32 = 13;
pub const ICMP_TIME_STAMP_REPLY: u32 = 14;
pub const ICMP_INFO_REQUEST: u32 = 15;
pub const ICMP_INFO_REPLY: u32 = 16;
pub const ICMP_ADDRESS_MASK_REQUEST: u32 = 17;
pub const ICMP_ADDRESS_MASK_REPLY: u32 = 18;
pub const ICMP_TTL_EXCEEDED: u32 = 0;
pub const ICMP_REASSEMBLY_TIME_EXCEEDED: u32 = 1;
pub const ICMP_NET_UNREACHABLE: u32 = 0;
pub const ICMP_HOST_UNREACHABLE: u32 = 1;
pub const ICMP_PROTOCOL_UNREACHABLE: u32 = 2;
pub const ICMP_PORT_UNREACHABLE: u32 = 3;
pub const ICMP_FRAGMENTATION_NEEDED: u32 = 4;
pub const ICMP_SOURCE_ROUTE_FAILED: u32 = 5;
pub const ICMP_DEST_NET_UNKNOWN: u32 = 6;
pub const ICMP_DEST_HOST_UNKNOWN: u32 = 7;
pub const ICMP_SRC_HOST_ISOLATED: u32 = 8;
pub const ICMP_DEST_NET_UNREACH_ADMIN: u32 = 9;
pub const ICMP_DEST_HOST_UNREACH_ADMIN: u32 = 10;
pub const ICMP_DEST_NET_UNREACH_TOS: u32 = 11;
pub const ICMP_DEST_HOST_UNREACH_TOS: u32 = 12;
pub const ICMPH_SIZE: u32 = 8;
pub const ICMP_MIN_TP_HDR_LEN: u32 = 8;
pub const IPH_DF: u32 = 16384;
pub const IPH_MF: u32 = 8192;
pub const IPH_OFFSET: u32 = 8191;
pub const IPH_DF_HTONS: u32 = 64;
pub const IPH_MF_HTONS: u32 = 32;
pub const IPH_OFFSET_HTONS: u32 = 65311;
pub const IPH_ECN_NECT: u32 = 0;
pub const IPH_ECN_ECT1: u32 = 1;
pub const IPH_ECN_ECT0: u32 = 2;
pub const IPH_ECN_CE: u32 = 3;
pub const IRE_BROADCAST: u32 = 1;
pub const IRE_DEFAULT: u32 = 2;
pub const IRE_LOCAL: u32 = 4;
pub const IRE_LOOPBACK: u32 = 8;
pub const IRE_PREFIX: u32 = 16;
pub const IRE_IF_NORESOLVER: u32 = 64;
pub const IRE_IF_RESOLVER: u32 = 128;
pub const IRE_HOST: u32 = 256;
pub const IRE_HOST_REDIRECT: u32 = 512;
pub const IRE_IF_CLONE: u32 = 1024;
pub const IRE_MULTICAST: u32 = 2048;
pub const IRE_NOROUTE: u32 = 4096;
pub const IRE_INTERFACE: u32 = 192;
pub const IRE_IF_ALL: u32 = 1216;
pub const IRE_OFFSUBNET: u32 = 274;
pub const IRE_OFFLINK: u32 = 274;
pub const IRE_ONLINK: u32 = 7373;
pub const IRE_FLUSH_DELETE: u32 = 0;
pub const IRE_FLUSH_ADD: u32 = 1;
pub const IRE_FLUSH_GWCHANGE: u32 = 2;
pub const IRR_NONE: u32 = 0;
pub const IRR_ALLOCATE: u32 = 1;
pub const IRR_INCOMPLETE: u32 = 2;
pub const CONN_CLOSING: u32 = 1;
pub const CONN_CONDEMNED: u32 = 2;
pub const CONN_INCIPIENT: u32 = 4;
pub const CONN_QUIESCED: u32 = 8;
pub const CONN_UPDATE_ILL: u32 = 16;
pub const DCEF_DEFAULT: u32 = 1;
pub const DCEF_PMTU: u32 = 2;
pub const DCEF_UINFO: u32 = 4;
pub const DCEF_TOO_SMALL_PMTU: u32 = 8;
pub const MAX_FILTER_SIZE: u32 = 64;
pub const IPSEC_POLICY_NOT_NEEDED: u32 = 0;
pub const IPSEC_POLICY_MISMATCH: u32 = 1;
pub const IPSEC_POLICY_AUTH_NOT_NEEDED: u32 = 2;
pub const IPSEC_POLICY_ENCR_NOT_NEEDED: u32 = 3;
pub const IPSEC_POLICY_SE_NOT_NEEDED: u32 = 4;
pub const IPSEC_POLICY_MAX: u32 = 5;
pub const MAX_ADDRS_PER_IF: u32 = 8192;
pub const MAX_IPIF_SELECT_SOURCE: u32 = 50;
pub const TR_STACK_DEPTH: u32 = 14;
pub const TR_BUF_MAX: u32 = 38;
pub const IPIF_CONDEMNED: u32 = 1;
pub const IPIF_CHANGING: u32 = 2;
pub const IPIF_SET_LINKLOCAL: u32 = 16;
pub const SIOCLIFADDR_NDX: u32 = 112;
pub const CONN_CLOSE: u32 = 1;
pub const COPYOUT: u32 = 2;
pub const NO_COPYOUT: u32 = 3;
pub const CUR_OP: u32 = 0;
pub const NEW_OP: u32 = 1;
pub const SWITCH_OP: u32 = 2;
pub const CACHE_ALIGN_SIZE: u32 = 64;
pub const IRB_MARK_CONDEMNED: u32 = 1;
pub const IRB_MARK_DYNAMIC: u32 = 2;
pub const IP_V4_G_HEAD: u32 = 0;
pub const IP_V6_G_HEAD: u32 = 1;
pub const MAX_G_HEADS: u32 = 2;
pub const ILL_CAPAB_LSO: u32 = 4;
pub const ILL_CAPAB_HCKSUM: u32 = 8;
pub const ILL_CAPAB_ZEROCOPY: u32 = 16;
pub const ILL_CAPAB_DLD: u32 = 32;
pub const ILL_CAPAB_DLD_POLL: u32 = 64;
pub const ILL_CAPAB_DLD_DIRECT: u32 = 128;
pub const ILL_LL_SUBNET_PENDING: u32 = 1;
pub const ILL_CONDEMNED: u32 = 2;
pub const ILL_DL_UNBIND_IN_PROGRESS: u32 = 4;
pub const ILL_DOWN_IN_PROGRESS: u32 = 8;
pub const IPI_DONTCARE: u32 = 0;
pub const IPI_PRIV: u32 = 1;
pub const IPI_MODOK: u32 = 2;
pub const IPI_WR: u32 = 4;
pub const IPI_GET_CMD: u32 = 8;
pub const IPI_NULL_BCONT: u32 = 32;
pub const IDS_UNKNOWN: u32 = 0;
pub const IDS_INPROGRESS: u32 = 1;
pub const IDS_OK: u32 = 2;
pub const IDS_FAILED: u32 = 3;
pub const IAF_IS_IPV4: u32 = 2147483648;
pub const IAF_TRUSTED_ICMP: u32 = 1073741824;
pub const IAF_NO_LOOP_ZONEID_SET: u32 = 536870912;
pub const IAF_LOOPBACK_COPY: u32 = 268435456;
pub const IAF_MASK: u32 = 4026531840;
pub const IXA_MAX_ADDRLEN: u32 = 4;
pub const IXAF_REACH_CONF: u32 = 1;
pub const IXAF_BROADCAST_TTL_SET: u32 = 2;
pub const IXAF_SET_SOURCE: u32 = 4;
pub const IXAF_USE_MIN_MTU: u32 = 8;
pub const IXAF_DONTFRAG: u32 = 16;
pub const IXAF_VERIFY_PMTU: u32 = 32;
pub const IXAF_PMTU_DISCOVERY: u32 = 64;
pub const IXAF_MULTICAST_LOOP: u32 = 128;
pub const IXAF_IPSEC_SECURE: u32 = 256;
pub const IXAF_UCRED_TSL: u32 = 512;
pub const IXAF_DONTROUTE: u32 = 1024;
pub const IXAF_NO_IPSEC: u32 = 2048;
pub const IXAF_PMTU_TOO_SMALL: u32 = 4096;
pub const IXAF_SET_ULP_CKSUM: u32 = 8192;
pub const IXAF_VERIFY_SOURCE: u32 = 16384;
pub const IXAF_NEXTHOP_SET: u32 = 32768;
pub const IXAF_PMTU_IPV4_DF: u32 = 65536;
pub const IXAF_NO_DEV_FLOW_CTL: u32 = 131072;
pub const IXAF_NO_TTL_CHANGE: u32 = 262144;
pub const IXAF_IPV6_ADD_FRAGHDR: u32 = 524288;
pub const IXAF_IPSEC_TUNNEL: u32 = 1048576;
pub const IXAF_NO_PFHOOK: u32 = 2097152;
pub const IXAF_NO_TRACE: u32 = 4194304;
pub const IXAF_SCOPEID_SET: u32 = 8388608;
pub const IXAF_MULTIRT_MULTICAST: u32 = 16777216;
pub const IXAF_NO_HW_CKSUM: u32 = 33554432;
pub const IXAF_SET_RAW_CKSUM: u32 = 67108864;
pub const IXAF_IPSEC_GLOBAL_POLICY: u32 = 134217728;
pub const IXAF_IS_IPV4: u32 = 2147483648;
pub const IXAF_TRUSTED_ICMP: u32 = 1073741824;
pub const IXAF_NO_LOOP_ZONEID_SET: u32 = 536870912;
pub const IXAF_LOOPBACK_COPY: u32 = 268435456;
pub const IXAF_VERIFY_LSO: u64 = 4294967296;
pub const IXAF_LSO_CAPAB: u64 = 8589934592;
pub const IXAF_VERIFY_ZCOPY: u64 = 17179869184;
pub const IXAF_ZCOPY_CAPAB: u64 = 34359738368;
pub const IXAF_BASIC_SIMPLE_V4: u32 = 2147508224;
pub const IXAF_BASIC_SIMPLE_V6: u32 = 24576;
pub const IXA_FREE_CRED: u32 = 1;
pub const IXA_FREE_TSL: u32 = 2;
pub const IXATC_IDLE: u32 = 0;
pub const IXATC_INPROGRESS: u32 = 1;
pub const IXATC_COMPLETE: u32 = 2;
pub const IPDF_ALLOW_MCBC: u32 = 1;
pub const IPDF_VERIFY_DST: u32 = 2;
pub const IPDF_SELECT_SRC: u32 = 4;
pub const IPDF_LSO: u32 = 8;
pub const IPDF_IPSEC: u32 = 16;
pub const IPDF_ZONE_IS_GLOBAL: u32 = 32;
pub const IPDF_ZCOPY: u32 = 64;
pub const IPDF_UNIQUE_DCE: u32 = 128;
pub const IRA_L2SRC_SIZE: u32 = 244;
pub const IRAF_SYSTEM_LABELED: u32 = 1;
pub const IRAF_IPV4_OPTIONS: u32 = 2;
pub const IRAF_MULTICAST: u32 = 4;
pub const IRAF_BROADCAST: u32 = 8;
pub const IRAF_MULTIBROADCAST: u32 = 12;
pub const IRAF_LOOPBACK: u32 = 16;
pub const IRAF_VERIFY_IP_CKSUM: u32 = 32;
pub const IRAF_VERIFY_ULP_CKSUM: u32 = 64;
pub const IRAF_SCTP_CSUM_ERR: u32 = 128;
pub const IRAF_IPSEC_SECURE: u32 = 256;
pub const IRAF_DHCP_UNICAST: u32 = 512;
pub const IRAF_IPSEC_DECAPS: u32 = 1024;
pub const IRAF_TARGET_SQP: u32 = 2048;
pub const IRAF_VERIFIED_SRC: u32 = 4096;
pub const IRAF_RSVP: u32 = 8192;
pub const IRAF_MROUTE_TUNNEL_SET: u32 = 16384;
pub const IRAF_PIM_REGISTER: u32 = 32768;
pub const IRAF_TX_MAC_EXEMPTABLE: u32 = 65536;
pub const IRAF_TX_SHARED_ADDR: u32 = 131072;
pub const IRAF_ESP_UDP_PORTS: u32 = 262144;
pub const IRAF_NO_HW_CKSUM: u32 = 524288;
pub const IRAF_ICMP_ERROR: u32 = 1048576;
pub const IRAF_ROUTER_ALERT: u32 = 2097152;
pub const IRAF_L2SRC_SET: u32 = 4194304;
pub const IRAF_L2SRC_LOOPBACK: u32 = 8388608;
pub const IRAF_L2DST_MULTICAST: u32 = 16777216;
pub const IRAF_L2DST_BROADCAST: u32 = 33554432;
pub const IRAF_IS_IPV4: u32 = 2147483648;
pub const IRAF_TRUSTED_ICMP: u32 = 1073741824;
pub const IRAF_NO_LOOP_ZONEID_SET: u32 = 536870912;
pub const IRAF_LOOPBACK_COPY: u32 = 268435456;
pub const IRA_FREE_CRED: u32 = 1;
pub const IRA_FREE_TSL: u32 = 2;
pub const DCE_GENERATION_CONDEMNED: u32 = 0;
pub const DCE_GENERATION_VERIFY: u32 = 1;
pub const DCE_GENERATION_INITIAL: u32 = 2;
pub const SRC_GENERATION_VERIFY: u32 = 0;
pub const SRC_GENERATION_INITIAL: u32 = 1;
pub const IRE_GENERATION_CONDEMNED: u32 = 0;
pub const IRE_GENERATION_VERIFY: u32 = 1;
pub const IRE_GENERATION_INITIAL: u32 = 2;
pub const COMMON_IP_MTU: u32 = 1500;
pub const MAX_FRAG_MIN: u32 = 10;
pub const IPPF_ADDR: u32 = 1;
pub const IPPF_HOPLIMIT: u32 = 2;
pub const IPPF_TCLASS: u32 = 4;
pub const IPPF_HOPOPTS: u32 = 16;
pub const IPPF_RTHDR: u32 = 32;
pub const IPPF_RTHDRDSTOPTS: u32 = 64;
pub const IPPF_DSTOPTS: u32 = 128;
pub const IPPF_IPV4_OPTIONS: u32 = 256;
pub const IPPF_LABEL_V4: u32 = 512;
pub const IPPF_LABEL_V6: u32 = 1024;
pub const IPPF_FRAGHDR: u32 = 2048;
pub const COA_HEADER_CHANGED: u32 = 1;
pub const COA_ROUTE_CHANGED: u32 = 2;
pub const COA_RCVBUF_CHANGED: u32 = 4;
pub const COA_SNDBUF_CHANGED: u32 = 8;
pub const COA_WROFF_CHANGED: u32 = 16;
pub const COA_ICMP_BIND_NEEDED: u32 = 32;
pub const COA_OOBINLINE_CHANGED: u32 = 64;
pub const TCP_PORTS_OFFSET: u32 = 0;
pub const UDP_PORTS_OFFSET: u32 = 0;
pub const ILL_LOOKUP_FAILED: u32 = 1;
pub const IPIF_LOOKUP_FAILED: u32 = 2;
pub const OBP_NAME: &[u8; 5] = b"name\0";
pub const OBP_REG: &[u8; 4] = b"reg\0";
pub const OBP_INTR: &[u8; 5] = b"intr\0";
pub const OBP_RANGES: &[u8; 7] = b"ranges\0";
pub const OBP_INTERRUPTS: &[u8; 11] = b"interrupts\0";
pub const OBP_COMPATIBLE: &[u8; 11] = b"compatible\0";
pub const OBP_STATUS: &[u8; 7] = b"status\0";
pub const OBP_BOARDNUM: &[u8; 7] = b"board#\0";
pub const OBP_MAC_ADDR: &[u8; 12] = b"mac-address\0";
pub const OBP_STDINPATH: &[u8; 11] = b"stdin-path\0";
pub const OBP_STDOUTPATH: &[u8; 12] = b"stdout-path\0";
pub const OBP_IDPROM: &[u8; 7] = b"idprom\0";
pub const OBP_DEVICETYPE: &[u8; 12] = b"device_type\0";
pub const OBP_DISPLAY: &[u8; 8] = b"display\0";
pub const OBP_NETWORK: &[u8; 8] = b"network\0";
pub const OBP_BYTE: &[u8; 5] = b"byte\0";
pub const OBP_BLOCK: &[u8; 6] = b"block\0";
pub const OBP_SERIAL: &[u8; 7] = b"serial\0";
pub const OBP_HIERARCHICAL: &[u8; 13] = b"hierarchical\0";
pub const OBP_CPU: &[u8; 4] = b"cpu\0";
pub const OBP_ADDRESS: &[u8; 8] = b"address\0";
pub const OBP_ST_OKAY: &[u8; 5] = b"okay\0";
pub const OBP_ST_DISABLED: &[u8; 9] = b"disabled\0";
pub const OBP_ST_FAIL: &[u8; 5] = b"fail\0";
pub const OBP_MAXDRVNAME: u32 = 32;
pub const OBP_MAXPROPNAME: u32 = 32;
pub const OBP_MAXPATHLEN: u32 = 256;
pub const OBP_STACKDEPTH: u32 = 85;
pub const BLOCK: u32 = 0;
pub const NETWORK: u32 = 1;
pub const BYTE: u32 = 2;
pub const MAC_STR_LEN: u32 = 128;
pub const CGTP_FILTER_REV_1: u32 = 1;
pub const CGTP_FILTER_REV_2: u32 = 2;
pub const CGTP_FILTER_REV_3: u32 = 3;
pub const CGTP_FILTER_REV: u32 = 3;
pub const CGTP_IP_PKT_NOT_CGTP: u32 = 0;
pub const CGTP_IP_PKT_PREMIUM: u32 = 1;
pub const CGTP_IP_PKT_DUPLICATE: u32 = 2;
pub const CGTP_MCAST_SUCCESS: u32 = 1;
pub const ILL_MAX_RINGS: u32 = 256;
pub const ILL_POLLING: u32 = 1;
pub const SQTAG_IP_INPUT: u32 = 1;
pub const SQTAG_TCP_INPUT_ICMP_ERR: u32 = 2;
pub const SQTAG_TCP6_INPUT_ICMP_ERR: u32 = 3;
pub const SQTAG_IP_TCP_INPUT: u32 = 4;
pub const SQTAG_IP6_TCP_INPUT: u32 = 5;
pub const SQTAG_IP_TCP_CLOSE: u32 = 6;
pub const SQTAG_TCP_OUTPUT: u32 = 7;
pub const SQTAG_TCP_TIMER: u32 = 8;
pub const SQTAG_TCP_TIMEWAIT: u32 = 9;
pub const SQTAG_TCP_ACCEPT_FINISH: u32 = 10;
pub const SQTAG_TCP_ACCEPT_FINISH_Q0: u32 = 11;
pub const SQTAG_TCP_ACCEPT_PENDING: u32 = 12;
pub const SQTAG_TCP_LISTEN_DISCON: u32 = 13;
pub const SQTAG_TCP_CONN_REQ_1: u32 = 14;
pub const SQTAG_TCP_EAGER_BLOWOFF: u32 = 15;
pub const SQTAG_TCP_EAGER_CLEANUP: u32 = 16;
pub const SQTAG_TCP_EAGER_CLEANUP_Q0: u32 = 17;
pub const SQTAG_TCP_CONN_IND: u32 = 18;
pub const SQTAG_TCP_RSRV: u32 = 19;
pub const SQTAG_TCP_ABORT_BUCKET: u32 = 20;
pub const SQTAG_TCP_REINPUT: u32 = 21;
pub const SQTAG_TCP_REINPUT_EAGER: u32 = 22;
pub const SQTAG_TCP_INPUT_MCTL: u32 = 23;
pub const SQTAG_TCP_RPUTOTHER: u32 = 24;
pub const SQTAG_IP_PROTO_AGAIN: u32 = 25;
pub const SQTAG_IP_FANOUT_TCP: u32 = 26;
pub const SQTAG_IPSQ_CLEAN_RING: u32 = 27;
pub const SQTAG_TCP_WPUT_OTHER: u32 = 28;
pub const SQTAG_TCP_CONN_REQ_UNBOUND: u32 = 29;
pub const SQTAG_TCP_SEND_PENDING: u32 = 30;
pub const SQTAG_BIND_RETRY: u32 = 31;
pub const SQTAG_UDP_FANOUT: u32 = 32;
pub const SQTAG_UDP_INPUT: u32 = 33;
pub const SQTAG_UDP_WPUT: u32 = 34;
pub const SQTAG_UDP_OUTPUT: u32 = 35;
pub const SQTAG_TCP_KSSL_INPUT: u32 = 36;
pub const SQTAG_TCP_DROP_Q0: u32 = 37;
pub const SQTAG_TCP_CONN_REQ_2: u32 = 38;
pub const SQTAG_IP_INPUT_RX_RING: u32 = 39;
pub const SQTAG_SQUEUE_CHANGE: u32 = 40;
pub const SQTAG_CONNECT_FINISH: u32 = 41;
pub const SQTAG_SYNCHRONOUS_OP: u32 = 42;
pub const SQTAG_TCP_SHUTDOWN_OUTPUT: u32 = 43;
pub const SQTAG_TCP_IXA_CLEANUP: u32 = 44;
pub const SQTAG_TCP_SEND_SYNACK: u32 = 45;
pub const ICMP6_INFOMSG_MASK: u32 = 128;
pub const ICMP6_MINLEN: u32 = 8;
pub const MLD_MINLEN: u32 = 24;
pub const MLD_V2_QUERY_MINLEN: u32 = 28;
pub const MLD_V2_SFLAG_MASK: u32 = 8;
pub const MLD_V2_RV_MASK: u32 = 7;
pub const MLD_V2_MAXRT_FPMIN: u32 = 32768;
pub const MLD_V2_MAXRT_MANT_MASK: u32 = 4095;
pub const MLD_V2_MAXRT_EXP_MASK: u32 = 28672;
pub const MLD_V2_QQI_FPMIN: u32 = 128;
pub const MLD_V2_QQI_MANT_MASK: u32 = 15;
pub const MLD_V2_QQI_EXP_MASK: u32 = 112;
pub const ICMP6_RR_FLAGS_TEST: u32 = 128;
pub const ICMP6_RR_FLAGS_REQRESULT: u32 = 64;
pub const ICMP6_RR_FLAGS_FORCEAPPLY: u32 = 32;
pub const ICMP6_RR_FLAGS_SPECSITE: u32 = 16;
pub const ICMP6_RR_FLAGS_PREVDONE: u32 = 8;
pub const RPM_PCO_ADD: u32 = 1;
pub const RPM_PCO_CHANGE: u32 = 2;
pub const RPM_PCO_SETGLOBAL: u32 = 3;
pub const ICMP6_RR_PCOUSE_RAFLAGS_ONLINK: u32 = 32;
pub const ICMP6_RR_PCOUSE_RAFLAGS_AUTO: u32 = 16;
pub const ICMP_RR_PCOUSE_FLAGS_DECRVLTIME: u32 = 128;
pub const ICMP_RR_PCOUSE_FLAGS_DECRPLTIME: u32 = 64;
pub const ICMP6_RR_RESULT_FLAGS_OOB: u32 = 512;
pub const ICMP6_RR_RESULT_FLAGS_FORBIDDEN: u32 = 256;
pub const ICMP6_DST_UNREACH: u32 = 1;
pub const ICMP6_PACKET_TOO_BIG: u32 = 2;
pub const ICMP6_TIME_EXCEEDED: u32 = 3;
pub const ICMP6_PARAM_PROB: u32 = 4;
pub const ICMP6_ECHO_REQUEST: u32 = 128;
pub const ICMP6_ECHO_REPLY: u32 = 129;
pub const MLD_LISTENER_QUERY: u32 = 130;
pub const ICMP6_MEMBERSHIP_QUERY: u32 = 130;
pub const MLD_LISTENER_REPORT: u32 = 131;
pub const ICMP6_MEMBERSHIP_REPORT: u32 = 131;
pub const MLD_LISTENER_REDUCTION: u32 = 132;
pub const ICMP6_MEMBERSHIP_REDUCTION: u32 = 132;
pub const MLD_V2_LISTENER_REPORT: u32 = 143;
pub const ND_ROUTER_SOLICIT: u32 = 133;
pub const ND_ROUTER_ADVERT: u32 = 134;
pub const ND_NEIGHBOR_SOLICIT: u32 = 135;
pub const ND_NEIGHBOR_ADVERT: u32 = 136;
pub const ND_REDIRECT: u32 = 137;
pub const ICMP6_ROUTER_RENUMBERING: u32 = 138;
pub const ICMP6_MAX_INFO_TYPE: u32 = 138;
pub const ICMP6_DST_UNREACH_NOROUTE: u32 = 0;
pub const ICMP6_DST_UNREACH_ADMIN: u32 = 1;
pub const ICMP6_DST_UNREACH_NOTNEIGHBOR: u32 = 2;
pub const ICMP6_DST_UNREACH_BEYONDSCOPE: u32 = 2;
pub const ICMP6_DST_UNREACH_ADDR: u32 = 3;
pub const ICMP6_DST_UNREACH_NOPORT: u32 = 4;
pub const ICMP6_TIME_EXCEED_TRANSIT: u32 = 0;
pub const ICMP6_TIME_EXCEED_REASSEMBLY: u32 = 1;
pub const ICMP6_PARAMPROB_HEADER: u32 = 0;
pub const ICMP6_PARAMPROB_NEXTHEADER: u32 = 1;
pub const ICMP6_PARAMPROB_OPTION: u32 = 2;
pub const ICMP6_MAX_HOST_REPORT_DELAY: u32 = 10;
pub const ND_RA_FLAG_OTHER: u32 = 64;
pub const ND_RA_FLAG_MANAGED: u32 = 128;
pub const ND_NA_FLAG_ROUTER: u32 = 128;
pub const ND_NA_FLAG_SOLICITED: u32 = 64;
pub const ND_NA_FLAG_OVERRIDE: u32 = 32;
pub const ND_OPT_SOURCE_LINKADDR: u32 = 1;
pub const ND_OPT_TARGET_LINKADDR: u32 = 2;
pub const ND_OPT_PREFIX_INFORMATION: u32 = 3;
pub const ND_OPT_REDIRECTED_HEADER: u32 = 4;
pub const ND_OPT_MTU: u32 = 5;
pub const ND_OPT_DNS_RESOLVER: u32 = 25;
pub const ND_OPT_DNS_SEARCHLIST: u32 = 31;
pub const ND_OPT_PI_FLAG_AUTO: u32 = 64;
pub const ND_OPT_PI_FLAG_ONLINK: u32 = 128;
pub const ND_MAX_INITIAL_RTR_ADVERT_INTERVAL: u32 = 16000;
pub const ND_MAX_INITIAL_RTR_ADVERTISEMENTS: u32 = 3;
pub const ND_MAX_FINAL_RTR_ADVERTISEMENTS: u32 = 3;
pub const ND_MIN_DELAY_BETWEEN_RAS: u32 = 3000;
pub const ND_MAX_RA_DELAY_TIME: u32 = 500;
pub const ND_MAX_RTR_SOLICITATION_DELAY: u32 = 1000;
pub const ND_RTR_SOLICITATION_INTERVAL: u32 = 4000;
pub const ND_MAX_RTR_SOLICITATIONS: u32 = 3;
pub const ND_MAX_MULTICAST_SOLICIT: u32 = 3;
pub const ND_MAX_UNICAST_SOLICIT: u32 = 3;
pub const ND_MAX_ANYCAST_DELAY_TIME: u32 = 1000;
pub const ND_MAX_NEIGHBOR_ADVERTISEMENT: u32 = 3;
pub const ND_REACHABLE_TIME: u32 = 30000;
pub const ND_RETRANS_TIMER: u32 = 1000;
pub const ND_DELAY_FIRST_PROBE_TIME: u32 = 5000;
pub const ND_MIN_RANDOM_FACTOR: f64 = 0.5;
pub const ND_MAX_RANDOM_FACTOR: f64 = 1.5;
pub const ND_MAX_REACHTIME: u32 = 3600000;
pub const ND_MAX_REACHRETRANSTIME: u32 = 100000;
pub const ICMP6_FILTER: u32 = 1;
pub const IP2MAC_RESOLVE: u32 = 1;
pub const IP2MAC_LOOKUP: u32 = 2;
pub const NCE_TABLE_SIZE: u32 = 256;
pub const NCE_CB_DISPATCHED: u32 = 1;
pub const NCE_F_MYADDR: u32 = 1;
pub const NCE_F_UNVERIFIED: u32 = 2;
pub const NCE_F_ISROUTER: u32 = 4;
pub const NCE_F_FAST: u32 = 8;
pub const NCE_F_NONUD: u32 = 16;
pub const NCE_F_ANYCAST: u32 = 32;
pub const NCE_F_CONDEMNED: u32 = 64;
pub const NCE_F_UNSOL_ADV: u32 = 128;
pub const NCE_F_BCAST: u32 = 256;
pub const NCE_F_MCAST: u32 = 512;
pub const NCE_F_PUBLISH: u32 = 1024;
pub const NCE_F_AUTHORITY: u32 = 2048;
pub const NCE_F_DELAYED: u32 = 4096;
pub const NCE_F_STATIC: u32 = 8192;
pub const NDP_UNICAST: u32 = 1;
pub const NDP_ISROUTER: u32 = 2;
pub const NDP_SOLICITED: u32 = 4;
pub const NDP_ORIDE: u32 = 8;
pub const NDP_PROBE: u32 = 16;
pub const ND_MAX_Q: u32 = 4;
pub const IPV6_LL_PREFIXLEN: u32 = 10;
pub const IP_CACHE_TABLE_SIZE: u32 = 256;
pub const IP_MASK_TABLE_SIZE: u32 = 33;
pub const IP6_FTABLE_HASH_SIZE: u32 = 32;
pub const IP6_CACHE_TABLE_SIZE: u32 = 256;
pub const MATCH_IRE_DSTONLY: u32 = 0;
pub const MATCH_IRE_TYPE: u32 = 1;
pub const MATCH_IRE_MASK: u32 = 2;
pub const MATCH_IRE_SHORTERMASK: u32 = 4;
pub const MATCH_IRE_GW: u32 = 8;
pub const MATCH_IRE_ILL: u32 = 16;
pub const MATCH_IRE_ZONEONLY: u32 = 32;
pub const MATCH_IRE_SECATTR: u32 = 64;
pub const MATCH_IRE_TESTHIDDEN: u32 = 128;
pub const MATCH_IRE_SRC_ILL: u32 = 256;
pub const MATCH_IRE_DIRECT: u32 = 512;
pub const MAX_IRE_RECURSION: u32 = 4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _label_t {
    pub val: [illumos_sys_hdrs::c_long; 8usize],
}
pub type label_t = _label_t;
pub type lock_t = illumos_sys_hdrs::c_uchar;
pub type intmax_t = i64;
pub type uintmax_t = u64;
pub type int_fast8_t = illumos_sys_hdrs::c_char;
pub type int_fast16_t = illumos_sys_hdrs::c_int;
pub type int_fast32_t = illumos_sys_hdrs::c_int;
pub type int_fast64_t = illumos_sys_hdrs::c_long;
pub type uint_fast8_t = illumos_sys_hdrs::c_uchar;
pub type uint_fast16_t = illumos_sys_hdrs::c_uint;
pub type uint_fast32_t = illumos_sys_hdrs::c_uint;
pub type uint_fast64_t = illumos_sys_hdrs::c_ulong;
pub type int_least8_t = illumos_sys_hdrs::c_char;
pub type int_least16_t = illumos_sys_hdrs::c_short;
pub type int_least32_t = illumos_sys_hdrs::c_int;
pub type int_least64_t = illumos_sys_hdrs::c_long;
pub type uint_least8_t = illumos_sys_hdrs::c_uchar;
pub type uint_least16_t = illumos_sys_hdrs::c_ushort;
pub type uint_least32_t = illumos_sys_hdrs::c_uint;
pub type uint_least64_t = illumos_sys_hdrs::c_ulong;
pub type caddr32_t = u32;
pub type daddr32_t = i32;
pub type off32_t = i32;
pub type ino32_t = u32;
pub type blkcnt32_t = i32;
pub type fsblkcnt32_t = u32;
pub type fsfilcnt32_t = u32;
pub type id32_t = i32;
pub type major32_t = u32;
pub type minor32_t = u32;
pub type key32_t = i32;
pub type mode32_t = u32;
pub type uid32_t = u32;
pub type gid32_t = u32;
pub type nlink32_t = u32;
pub type dev32_t = u32;
pub type pid32_t = i32;
pub type size32_t = u32;
pub type ssize32_t = i32;
pub type time32_t = i32;
pub type clock32_t = i32;
pub type uintptr32_t = u32;
pub type intptr32_t = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval32 {
    pub tv_sec: time32_t,
    pub tv_usec: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec32 {
    pub tv_sec: time32_t,
    pub tv_nsec: i32,
}
pub type timespec32_t = timespec32;
pub type timestruc32_t = timespec32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec32 {
    pub it_interval: timespec32,
    pub it_value: timespec32,
}
pub type itimerspec32_t = itimerspec32;
pub type longlong_t = illumos_sys_hdrs::c_longlong;
pub type u_longlong_t = illumos_sys_hdrs::c_ulonglong;
pub type t_scalar_t = i32;
pub type t_uscalar_t = u32;
pub type uchar_t = illumos_sys_hdrs::c_uchar;
pub type ushort_t = illumos_sys_hdrs::c_ushort;
pub type uint_t = illumos_sys_hdrs::c_uint;
pub type ulong_t = illumos_sys_hdrs::c_ulong;
pub type caddr_t = *mut illumos_sys_hdrs::c_char;
pub type daddr_t = illumos_sys_hdrs::c_long;
pub type cnt_t = illumos_sys_hdrs::c_short;
pub type pfn_t = ulong_t;
pub type pgcnt_t = ulong_t;
pub type spgcnt_t = illumos_sys_hdrs::c_long;
pub type use_t = uchar_t;
pub type sysid_t = illumos_sys_hdrs::c_short;
pub type index_t = illumos_sys_hdrs::c_short;
pub type timeout_id_t = *mut illumos_sys_hdrs::c_void;
pub type bufcall_id_t = *mut illumos_sys_hdrs::c_void;
pub type off_t = illumos_sys_hdrs::c_long;
pub type off64_t = off_t;
pub type ino_t = ulong_t;
pub type blkcnt_t = illumos_sys_hdrs::c_long;
pub type fsblkcnt_t = ulong_t;
pub type fsfilcnt_t = ulong_t;
pub type ino64_t = ino_t;
pub type blkcnt64_t = blkcnt_t;
pub type fsblkcnt64_t = fsblkcnt_t;
pub type fsfilcnt64_t = fsfilcnt_t;
pub type blksize_t = illumos_sys_hdrs::c_int;
pub const boolean_t_B_FALSE: boolean_t = 0;
pub const boolean_t_B_TRUE: boolean_t = 1;
pub const boolean_t__B_FALSE: boolean_t = 0;
pub const boolean_t__B_TRUE: boolean_t = 1;
pub type boolean_t = illumos_sys_hdrs::c_uint;
pub type pad64_t = i64;
pub type upad64_t = u64;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union pad128_t {
    pub _q: u128,
    pub _l: [i32; 4usize],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union upad128_t {
    pub _q: u128,
    pub _l: [u32; 4usize],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union upad256_t {
    pub _q: [u128; 2usize],
    pub _l: [u32; 8usize],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union upad512_t {
    pub _q: [u128; 4usize],
    pub _l: [u32; 16usize],
}
pub type offset_t = longlong_t;
pub type u_offset_t = u_longlong_t;
pub type len_t = u_longlong_t;
pub type diskaddr_t = u_longlong_t;
pub type paddr_t = u64;
#[repr(C)]
#[derive(Copy, Clone)]
pub union lloff_t {
    pub _f: offset_t,
    pub _p: lloff_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lloff_t__bindgen_ty_1 {
    pub _l: i32,
    pub _u: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lldaddr_t {
    pub _f: longlong_t,
    pub _p: lldaddr_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldaddr_t__bindgen_ty_1 {
    pub _l: i32,
    pub _u: i32,
}
pub type k_fltset_t = uint_t;
pub type id_t = illumos_sys_hdrs::c_int;
pub type lgrp_id_t = id_t;
pub type useconds_t = uint_t;
pub type suseconds_t = illumos_sys_hdrs::c_long;
pub type major_t = uint_t;
pub type minor_t = uint_t;
pub type pri_t = illumos_sys_hdrs::c_short;
pub type cpu_flag_t = ushort_t;
pub type o_mode_t = ushort_t;
pub type o_dev_t = illumos_sys_hdrs::c_short;
pub type o_uid_t = ushort_t;
pub type o_gid_t = o_uid_t;
pub type o_nlink_t = illumos_sys_hdrs::c_short;
pub type o_pid_t = illumos_sys_hdrs::c_short;
pub type o_ino_t = ushort_t;
pub type key_t = illumos_sys_hdrs::c_int;
pub type mode_t = uint_t;
pub type uid_t = illumos_sys_hdrs::c_uint;
pub type gid_t = uid_t;
pub type datalink_id_t = u32;
pub type vrid_t = u32;
pub type taskid_t = id_t;
pub type projid_t = id_t;
pub type poolid_t = id_t;
pub type zoneid_t = id_t;
pub type ctid_t = id_t;
pub type pthread_t = uint_t;
pub type pthread_key_t = uint_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _pthread_mutex {
    pub __pthread_mutex_flags: _pthread_mutex__bindgen_ty_1,
    pub __pthread_mutex_lock: _pthread_mutex__bindgen_ty_2,
    pub __pthread_mutex_data: upad64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_mutex__bindgen_ty_1 {
    pub __pthread_mutex_flag1: u16,
    pub __pthread_mutex_flag2: u8,
    pub __pthread_mutex_ceiling: u8,
    pub __pthread_mutex_type: u16,
    pub __pthread_mutex_magic: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _pthread_mutex__bindgen_ty_2 {
    pub __pthread_mutex_lock64: _pthread_mutex__bindgen_ty_2__bindgen_ty_1,
    pub __pthread_mutex_lock32: _pthread_mutex__bindgen_ty_2__bindgen_ty_2,
    pub __pthread_mutex_owner64: upad64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_mutex__bindgen_ty_2__bindgen_ty_1 {
    pub __pthread_mutex_pad: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_mutex__bindgen_ty_2__bindgen_ty_2 {
    pub __pthread_ownerpid: u32,
    pub __pthread_lockword: u32,
}
pub type pthread_mutex_t = _pthread_mutex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cond {
    pub __pthread_cond_flags: _pthread_cond__bindgen_ty_1,
    pub __pthread_cond_data: upad64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cond__bindgen_ty_1 {
    pub __pthread_cond_flag: [u8; 4usize],
    pub __pthread_cond_type: u16,
    pub __pthread_cond_magic: u16,
}
pub type pthread_cond_t = _pthread_cond;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _pthread_rwlock {
    pub __pthread_rwlock_readers: i32,
    pub __pthread_rwlock_type: u16,
    pub __pthread_rwlock_magic: u16,
    pub __pthread_rwlock_mutex: pthread_mutex_t,
    pub __pthread_rwlock_readercv: pthread_cond_t,
    pub __pthread_rwlock_writercv: pthread_cond_t,
}
pub type pthread_rwlock_t = _pthread_rwlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_barrier_t {
    pub __pthread_barrier_count: u32,
    pub __pthread_barrier_current: u32,
    pub __pthread_barrier_cycle: upad64_t,
    pub __pthread_barrier_reserved: upad64_t,
    pub __pthread_barrier_lock: pthread_mutex_t,
    pub __pthread_barrier_cond: pthread_cond_t,
}
pub type pthread_spinlock_t = pthread_mutex_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_attr {
    pub __pthread_attrp: *mut illumos_sys_hdrs::c_void,
}
pub type pthread_attr_t = _pthread_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_mutexattr {
    pub __pthread_mutexattrp: *mut illumos_sys_hdrs::c_void,
}
pub type pthread_mutexattr_t = _pthread_mutexattr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_condattr {
    pub __pthread_condattrp: *mut illumos_sys_hdrs::c_void,
}
pub type pthread_condattr_t = _pthread_condattr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _once {
    pub __pthread_once_pad: [upad64_t; 4usize],
}
pub type pthread_once_t = _once;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_rwlockattr {
    pub __pthread_rwlockattrp: *mut illumos_sys_hdrs::c_void,
}
pub type pthread_rwlockattr_t = _pthread_rwlockattr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr_t {
    pub __pthread_barrierattrp: *mut illumos_sys_hdrs::c_void,
}
pub type dev_t = ulong_t;
pub type nlink_t = uint_t;
pub type pid_t = illumos_sys_hdrs::c_int;
pub type time_t = illumos_sys_hdrs::c_long;
pub type clock_t = illumos_sys_hdrs::c_long;
pub type clockid_t = illumos_sys_hdrs::c_int;
pub type timer_t = illumos_sys_hdrs::c_int;
pub type unchar = illumos_sys_hdrs::c_uchar;
pub type ushort = illumos_sys_hdrs::c_ushort;
pub type uint = illumos_sys_hdrs::c_uint;
pub type ulong = illumos_sys_hdrs::c_ulong;
pub type u_char = illumos_sys_hdrs::c_uchar;
pub type u_short = illumos_sys_hdrs::c_ushort;
pub type u_int = illumos_sys_hdrs::c_uint;
pub type u_long = illumos_sys_hdrs::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _quad {
    pub val: [illumos_sys_hdrs::c_int; 2usize],
}
pub type quad_t = _quad;
pub type quad = quad_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigset_t {
    pub __sigbits: [illumos_sys_hdrs::c_uint; 4usize],
}
pub type fd_mask = illumos_sys_hdrs::c_long;
pub type fds_mask = illumos_sys_hdrs::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [illumos_sys_hdrs::c_long; 1024usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: illumos_sys_hdrs::c_int,
    pub tz_dsttime: illumos_sys_hdrs::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
pub type hrtime_t = longlong_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: illumos_sys_hdrs::c_long,
}
pub type timespec_t = timespec;
pub type timestruc_t = timespec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type itimerspec_t = itimerspec;
pub const kmutex_type_t_MUTEX_ADAPTIVE: kmutex_type_t = 0;
pub const kmutex_type_t_MUTEX_SPIN: kmutex_type_t = 1;
pub const kmutex_type_t_MUTEX_DRIVER: kmutex_type_t = 4;
pub const kmutex_type_t_MUTEX_DEFAULT: kmutex_type_t = 6;
pub type kmutex_type_t = illumos_sys_hdrs::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mutex {
    pub _opaque: [*mut illumos_sys_hdrs::c_void; 1usize],
}
pub type kmutex_t = mutex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pad_mutex {
    pub pad_mutex: kmutex_t,
    pub pad_pad: [illumos_sys_hdrs::c_char; 56usize],
}
pub type pad_mutex_t = pad_mutex;
unsafe extern "C" {
    pub fn mutex_init(
        arg1: *mut kmutex_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: kmutex_type_t,
        arg4: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn mutex_destroy(arg1: *mut kmutex_t);
}
unsafe extern "C" {
    pub fn mutex_enter(arg1: *mut kmutex_t);
}
unsafe extern "C" {
    pub fn mutex_tryenter(arg1: *mut kmutex_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn mutex_exit(arg1: *mut kmutex_t);
}
unsafe extern "C" {
    pub fn mutex_owned(arg1: *const kmutex_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn mutex_owner(arg1: *const kmutex_t) -> *mut _kthread;
}
unsafe extern "C" {
    pub static mut mutex_backoff_base: ushort_t;
}
unsafe extern "C" {
    pub static mut mutex_backoff_cap: uint_t;
}
unsafe extern "C" {
    pub static mut mutex_cap_factor: ushort_t;
}
unsafe extern "C" {
    pub static mut mutex_backoff_shift: uchar_t;
}
unsafe extern "C" {
    pub static mut mutex_lock_delay:
        ::core::option::Option<unsafe extern "C" fn(arg1: uint_t)>;
}
unsafe extern "C" {
    pub static mut mutex_lock_backoff:
        ::core::option::Option<unsafe extern "C" fn(arg1: uint_t) -> uint_t>;
}
unsafe extern "C" {
    pub static mut mutex_delay: ::core::option::Option<unsafe extern "C" fn()>;
}
unsafe extern "C" {
    pub fn mutex_delay_default();
}
unsafe extern "C" {
    pub fn mutex_sync();
}
unsafe extern "C" {
    pub fn default_lock_delay(arg1: uint_t);
}
unsafe extern "C" {
    pub fn default_lock_backoff(arg1: uint_t) -> uint_t;
}
unsafe extern "C" {
    pub static mut tick_per_msec: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut msec_per_tick: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut usec_per_tick: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut nsec_per_tick: illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct todinfo {
    pub tod_sec: illumos_sys_hdrs::c_int,
    pub tod_min: illumos_sys_hdrs::c_int,
    pub tod_hour: illumos_sys_hdrs::c_int,
    pub tod_dow: illumos_sys_hdrs::c_int,
    pub tod_day: illumos_sys_hdrs::c_int,
    pub tod_month: illumos_sys_hdrs::c_int,
    pub tod_year: illumos_sys_hdrs::c_int,
}
pub type todinfo_t = todinfo;
unsafe extern "C" {
    pub static mut timedelta: i64;
}
unsafe extern "C" {
    pub static mut timechanged: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut tod_needsync: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut tod_lock: kmutex_t;
}
unsafe extern "C" {
    pub static mut have_hw_tod: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut hrestime: timestruc_t;
}
unsafe extern "C" {
    pub static mut hres_last_tick: hrtime_t;
}
unsafe extern "C" {
    pub static mut hrestime_adj: i64;
}
unsafe extern "C" {
    pub static mut adj_shift: uint_t;
}
unsafe extern "C" {
    pub fn tod_get() -> timestruc_t;
}
unsafe extern "C" {
    pub fn tod_set(arg1: timestruc_t);
}
unsafe extern "C" {
    pub fn set_hrestime(arg1: *mut timestruc_t);
}
unsafe extern "C" {
    pub fn utc_to_tod(arg1: time_t) -> todinfo_t;
}
unsafe extern "C" {
    pub fn tod_to_utc(arg1: todinfo_t) -> time_t;
}
unsafe extern "C" {
    pub fn hr_clock_lock() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn hr_clock_unlock(arg1: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn gethrtime() -> hrtime_t;
}
unsafe extern "C" {
    pub fn gethrtime_unscaled() -> hrtime_t;
}
unsafe extern "C" {
    pub fn gethrtime_max() -> hrtime_t;
}
unsafe extern "C" {
    pub fn gethrtime_waitfree() -> hrtime_t;
}
unsafe extern "C" {
    pub fn scalehrtime(arg1: *mut hrtime_t);
}
unsafe extern "C" {
    pub fn unscalehrtime(arg1: hrtime_t) -> u64;
}
unsafe extern "C" {
    pub fn gethrestime(arg1: *mut timespec_t);
}
unsafe extern "C" {
    pub fn gethrestime_sec() -> time_t;
}
unsafe extern "C" {
    pub fn gethrestime_lasttick(arg1: *mut timespec_t);
}
unsafe extern "C" {
    pub fn hrt2ts(arg1: hrtime_t, arg2: *mut timestruc_t);
}
unsafe extern "C" {
    pub fn ts2hrt(arg1: *const timestruc_t) -> hrtime_t;
}
unsafe extern "C" {
    pub fn hrt2tv(arg1: hrtime_t, arg2: *mut timeval);
}
unsafe extern "C" {
    pub fn tv2hrt(arg1: *mut timeval) -> hrtime_t;
}
unsafe extern "C" {
    pub fn itimerfix(
        arg1: *mut timeval,
        arg2: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn itimerdecr(
        arg1: *mut itimerval,
        arg2: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn timevaladd(arg1: *mut timeval, arg2: *mut timeval);
}
unsafe extern "C" {
    pub fn timevalsub(arg1: *mut timeval, arg2: *mut timeval);
}
unsafe extern "C" {
    pub fn timevalfix(arg1: *mut timeval);
}
unsafe extern "C" {
    pub fn dtrace_hres_tick();
}
unsafe extern "C" {
    pub fn ddi_get_lbolt() -> clock_t;
}
unsafe extern "C" {
    pub fn ddi_get_lbolt64() -> i64;
}
pub type kid_t = illumos_sys_hdrs::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kstat {
    pub ks_crtime: hrtime_t,
    pub ks_next: *mut kstat,
    pub ks_kid: kid_t,
    pub ks_module: [illumos_sys_hdrs::c_char; 31usize],
    pub ks_resv: uchar_t,
    pub ks_instance: illumos_sys_hdrs::c_int,
    pub ks_name: [illumos_sys_hdrs::c_char; 31usize],
    pub ks_type: uchar_t,
    pub ks_class: [illumos_sys_hdrs::c_char; 31usize],
    pub ks_flags: uchar_t,
    pub ks_data: *mut illumos_sys_hdrs::c_void,
    pub ks_ndata: uint_t,
    pub ks_data_size: usize,
    pub ks_snaptime: hrtime_t,
    pub ks_update: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kstat,
            arg2: illumos_sys_hdrs::c_int,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub ks_private: *mut illumos_sys_hdrs::c_void,
    pub ks_snapshot: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kstat,
            arg2: *mut illumos_sys_hdrs::c_void,
            arg3: illumos_sys_hdrs::c_int,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub ks_lock: *mut illumos_sys_hdrs::c_void,
}
pub type kstat_t = kstat;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kstat_named {
    pub name: [illumos_sys_hdrs::c_char; 31usize],
    pub data_type: uchar_t,
    pub value: kstat_named__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kstat_named__bindgen_ty_1 {
    pub c: [illumos_sys_hdrs::c_char; 16usize],
    pub i32_: i32,
    pub ui32: u32,
    pub str_: kstat_named__bindgen_ty_1__bindgen_ty_1,
    pub i64_: i64,
    pub ui64: u64,
    pub l: illumos_sys_hdrs::c_long,
    pub ul: ulong_t,
    pub ll: longlong_t,
    pub ull: u_longlong_t,
    pub f: f32,
    pub d: f64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kstat_named__bindgen_ty_1__bindgen_ty_1 {
    pub addr: kstat_named__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub len: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kstat_named__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub ptr: *mut illumos_sys_hdrs::c_char,
    pub ptr32: caddr32_t,
    pub __pad: [illumos_sys_hdrs::c_char; 8usize],
}
pub type kstat_named_t = kstat_named;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kstat_intr {
    pub intrs: [uint_t; 5usize],
}
pub type kstat_intr_t = kstat_intr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kstat_io {
    pub nread: u_longlong_t,
    pub nwritten: u_longlong_t,
    pub reads: uint_t,
    pub writes: uint_t,
    pub wtime: hrtime_t,
    pub wlentime: hrtime_t,
    pub wlastupdate: hrtime_t,
    pub rtime: hrtime_t,
    pub rlentime: hrtime_t,
    pub rlastupdate: hrtime_t,
    pub wcnt: uint_t,
    pub rcnt: uint_t,
}
pub type kstat_io_t = kstat_io;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kstat_timer {
    pub name: [illumos_sys_hdrs::c_char; 31usize],
    pub resv: uchar_t,
    pub num_events: u_longlong_t,
    pub elapsed_time: hrtime_t,
    pub min_time: hrtime_t,
    pub max_time: hrtime_t,
    pub start_time: hrtime_t,
    pub stop_time: hrtime_t,
}
pub type kstat_timer_t = kstat_timer;
unsafe extern "C" {
    pub fn lock_set(lp: *mut lock_t);
}
unsafe extern "C" {
    pub fn lock_try(lp: *mut lock_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn lock_spin_try(lp: *mut lock_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ulock_try(lp: *mut lock_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn lock_clear(lp: *mut lock_t);
}
unsafe extern "C" {
    pub fn ulock_clear(lp: *mut lock_t);
}
unsafe extern "C" {
    pub fn lock_set_spl(
        lp: *mut lock_t,
        new_pil: illumos_sys_hdrs::c_int,
        old_pil: *mut ushort_t,
    );
}
unsafe extern "C" {
    pub fn lock_clear_splx(lp: *mut lock_t, s: illumos_sys_hdrs::c_int);
}
pub type disp_lock_t = lock_t;
unsafe extern "C" {
    pub static mut hres_lock: u32;
}
unsafe extern "C" {
    pub static mut hrtime_base: hrtime_t;
}
unsafe extern "C" {
    pub static mut clock_res: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn drv_usecwait(arg1: clock_t);
}
unsafe extern "C" {
    pub static mut cpu_decay_factor: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut maxpid: pid_t;
}
unsafe extern "C" {
    pub static mut jump_pid: pid_t;
}
unsafe extern "C" {
    pub static mut _kernelbase: usize;
}
unsafe extern "C" {
    pub static mut _userlimit: usize;
}
unsafe extern "C" {
    pub static mut _userlimit32: usize;
}
unsafe extern "C" {
    pub static mut hz: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut snooping: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut snoop_interval: uint_t;
}
unsafe extern "C" {
    pub static _pagesize: illumos_sys_hdrs::c_ulong;
}
unsafe extern "C" {
    pub static _pageshift: illumos_sys_hdrs::c_uint;
}
unsafe extern "C" {
    pub static _pageoffset: illumos_sys_hdrs::c_ulong;
}
unsafe extern "C" {
    pub static _pagemask: illumos_sys_hdrs::c_ulonglong;
}
unsafe extern "C" {
    pub static _mmu_pagesize: illumos_sys_hdrs::c_ulong;
}
unsafe extern "C" {
    pub static _mmu_pageshift: illumos_sys_hdrs::c_uint;
}
unsafe extern "C" {
    pub static _mmu_pageoffset: illumos_sys_hdrs::c_ulong;
}
unsafe extern "C" {
    pub static _mmu_pagemask: illumos_sys_hdrs::c_ulong;
}
unsafe extern "C" {
    pub static _argsbase: usize;
}
unsafe extern "C" {
    pub static _defaultstksz: illumos_sys_hdrs::c_ulong;
}
unsafe extern "C" {
    pub static _nbpg: illumos_sys_hdrs::c_uint;
}
unsafe extern "C" {
    pub static _ncpu: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static _ncpu_log2: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static _ncpu_p2: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static _clsize: illumos_sys_hdrs::c_int;
}
pub const krw_type_t_RW_DRIVER: krw_type_t = 2;
pub const krw_type_t_RW_DEFAULT: krw_type_t = 4;
pub type krw_type_t = illumos_sys_hdrs::c_uint;
pub const krw_t_RW_WRITER: krw_t = 0;
pub const krw_t_RW_READER: krw_t = 1;
pub const krw_t_RW_READER_STARVEWRITER: krw_t = 2;
pub type krw_t = illumos_sys_hdrs::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _krwlock {
    pub _opaque: [*mut illumos_sys_hdrs::c_void; 1usize],
}
pub type krwlock_t = _krwlock;
unsafe extern "C" {
    pub fn rw_init(
        arg1: *mut krwlock_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: krw_type_t,
        arg4: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn rw_destroy(arg1: *mut krwlock_t);
}
unsafe extern "C" {
    pub fn rw_enter(arg1: *mut krwlock_t, arg2: krw_t);
}
unsafe extern "C" {
    pub fn rw_tryenter(
        arg1: *mut krwlock_t,
        arg2: krw_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rw_exit(arg1: *mut krwlock_t);
}
unsafe extern "C" {
    pub fn rw_downgrade(arg1: *mut krwlock_t);
}
unsafe extern "C" {
    pub fn rw_tryupgrade(arg1: *mut krwlock_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rw_read_held(arg1: *mut krwlock_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rw_write_held(arg1: *mut krwlock_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rw_lock_held(arg1: *mut krwlock_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rw_read_locked(arg1: *mut krwlock_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rw_iswriter(arg1: *mut krwlock_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rw_owner(arg1: *mut krwlock_t) -> *mut _kthread;
}
unsafe extern "C" {
    pub static mut rw_lock_backoff:
        ::core::option::Option<unsafe extern "C" fn(arg1: uint_t) -> uint_t>;
}
unsafe extern "C" {
    pub static mut rw_lock_delay:
        ::core::option::Option<unsafe extern "C" fn(arg1: uint_t)>;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _kcondvar {
    pub _opaque: ushort_t,
}
pub type kcondvar_t = _kcondvar;
pub const kcv_type_t_CV_DEFAULT: kcv_type_t = 0;
pub const kcv_type_t_CV_DRIVER: kcv_type_t = 1;
pub type kcv_type_t = illumos_sys_hdrs::c_uint;
pub const time_res_t_TR_NANOSEC: time_res_t = 0;
pub const time_res_t_TR_MICROSEC: time_res_t = 1;
pub const time_res_t_TR_MILLISEC: time_res_t = 2;
pub const time_res_t_TR_SEC: time_res_t = 3;
pub const time_res_t_TR_CLOCK_TICK: time_res_t = 4;
pub const time_res_t_TR_COUNT: time_res_t = 5;
pub type time_res_t = illumos_sys_hdrs::c_uint;
unsafe extern "C" {
    pub static mut time_res: [time_res_t; 0usize];
}
unsafe extern "C" {
    pub fn cv_init(
        arg1: *mut kcondvar_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: kcv_type_t,
        arg4: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn cv_destroy(arg1: *mut kcondvar_t);
}
unsafe extern "C" {
    pub fn cv_wait(arg1: *mut kcondvar_t, arg2: *mut kmutex_t);
}
unsafe extern "C" {
    pub fn cv_wait_stop(
        arg1: *mut kcondvar_t,
        arg2: *mut kmutex_t,
        arg3: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn cv_timedwait(
        arg1: *mut kcondvar_t,
        arg2: *mut kmutex_t,
        arg3: clock_t,
    ) -> clock_t;
}
unsafe extern "C" {
    pub fn cv_timedwait_hires(
        arg1: *mut kcondvar_t,
        arg2: *mut kmutex_t,
        arg3: hrtime_t,
        arg4: hrtime_t,
        arg5: illumos_sys_hdrs::c_int,
    ) -> clock_t;
}
unsafe extern "C" {
    pub fn cv_reltimedwait(
        arg1: *mut kcondvar_t,
        arg2: *mut kmutex_t,
        arg3: clock_t,
        arg4: time_res_t,
    ) -> clock_t;
}
unsafe extern "C" {
    pub fn cv_wait_sig(
        arg1: *mut kcondvar_t,
        arg2: *mut kmutex_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn cv_timedwait_sig(
        arg1: *mut kcondvar_t,
        arg2: *mut kmutex_t,
        arg3: clock_t,
    ) -> clock_t;
}
unsafe extern "C" {
    pub fn cv_timedwait_sig_hrtime(
        arg1: *mut kcondvar_t,
        arg2: *mut kmutex_t,
        arg3: hrtime_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn cv_reltimedwait_sig(
        arg1: *mut kcondvar_t,
        arg2: *mut kmutex_t,
        arg3: clock_t,
        arg4: time_res_t,
    ) -> clock_t;
}
unsafe extern "C" {
    pub fn cv_wait_sig_swap(
        arg1: *mut kcondvar_t,
        arg2: *mut kmutex_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn cv_wait_sig_swap_core(
        arg1: *mut kcondvar_t,
        arg2: *mut kmutex_t,
        arg3: *mut illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn cv_signal(arg1: *mut kcondvar_t);
}
unsafe extern "C" {
    pub fn cv_broadcast(arg1: *mut kcondvar_t);
}
unsafe extern "C" {
    pub fn cv_waituntil_sig(
        arg1: *mut kcondvar_t,
        arg2: *mut kmutex_t,
        arg3: *mut timestruc_t,
        arg4: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn _sysconf(arg1: illumos_sys_hdrs::c_int) -> illumos_sys_hdrs::c_long;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: illumos_sys_hdrs::c_int,
    pub sival_ptr: *mut illumos_sys_hdrs::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: illumos_sys_hdrs::c_int,
    pub sigev_signo: illumos_sys_hdrs::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function:
        ::core::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
    pub __sigev_pad2: illumos_sys_hdrs::c_int,
}
pub type faultcode_t = illumos_sys_hdrs::c_int;
unsafe extern "C" {
    pub fn fc_decode(arg1: faultcode_t) -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo {
    pub si_signo: illumos_sys_hdrs::c_int,
    pub si_code: illumos_sys_hdrs::c_int,
    pub si_errno: illumos_sys_hdrs::c_int,
    pub si_pad: illumos_sys_hdrs::c_int,
    pub __data: siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo__bindgen_ty_1 {
    pub __pad: [illumos_sys_hdrs::c_int; 60usize],
    pub __proc: siginfo__bindgen_ty_1__bindgen_ty_1,
    pub __fault: siginfo__bindgen_ty_1__bindgen_ty_2,
    pub __file: siginfo__bindgen_ty_1__bindgen_ty_3,
    pub __prof: siginfo__bindgen_ty_1__bindgen_ty_4,
    pub __rctl: siginfo__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub __pid: pid_t,
    pub __pdata: siginfo__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __ctid: ctid_t,
    pub __zoneid: zoneid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __kill: siginfo__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __cld: siginfo__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __uid: uid_t,
    pub __value: sigval,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub __utime: clock_t,
    pub __status: illumos_sys_hdrs::c_int,
    pub __stime: clock_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_2 {
    pub __addr: *mut illumos_sys_hdrs::c_void,
    pub __trapno: illumos_sys_hdrs::c_int,
    pub __pc: caddr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_3 {
    pub __fd: illumos_sys_hdrs::c_int,
    pub __band: illumos_sys_hdrs::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_4 {
    pub __faddr: caddr_t,
    pub __tstamp: timestruc_t,
    pub __syscall: illumos_sys_hdrs::c_short,
    pub __nsysarg: illumos_sys_hdrs::c_char,
    pub __fault: illumos_sys_hdrs::c_char,
    pub __sysarg: [illumos_sys_hdrs::c_long; 8usize],
    pub __mstate: [illumos_sys_hdrs::c_int; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_5 {
    pub __entity: i32,
}
pub type siginfo_t = siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_siginfo {
    pub si_signo: illumos_sys_hdrs::c_int,
    pub si_code: illumos_sys_hdrs::c_int,
    pub si_errno: illumos_sys_hdrs::c_int,
    pub si_pad: illumos_sys_hdrs::c_int,
    pub __data: k_siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k_siginfo__bindgen_ty_1 {
    pub __proc: k_siginfo__bindgen_ty_1__bindgen_ty_1,
    pub __fault: k_siginfo__bindgen_ty_1__bindgen_ty_2,
    pub __file: k_siginfo__bindgen_ty_1__bindgen_ty_3,
    pub __prof: k_siginfo__bindgen_ty_1__bindgen_ty_4,
    pub __rctl: k_siginfo__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub __pid: pid_t,
    pub __pdata: k_siginfo__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __ctid: ctid_t,
    pub __zoneid: zoneid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k_siginfo__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __kill:
        k_siginfo__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __cld:
        k_siginfo__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_siginfo__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __uid: uid_t,
    pub __value: sigval,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_siginfo__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub __utime: clock_t,
    pub __status: illumos_sys_hdrs::c_int,
    pub __stime: clock_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_siginfo__bindgen_ty_1__bindgen_ty_2 {
    pub __addr: *mut illumos_sys_hdrs::c_void,
    pub __trapno: illumos_sys_hdrs::c_int,
    pub __pc: caddr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_siginfo__bindgen_ty_1__bindgen_ty_3 {
    pub __fd: illumos_sys_hdrs::c_int,
    pub __band: illumos_sys_hdrs::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_siginfo__bindgen_ty_1__bindgen_ty_4 {
    pub __faddr: caddr_t,
    pub __tstamp: timestruc_t,
    pub __syscall: illumos_sys_hdrs::c_short,
    pub __nsysarg: illumos_sys_hdrs::c_char,
    pub __fault: illumos_sys_hdrs::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_siginfo__bindgen_ty_1__bindgen_ty_5 {
    pub __entity: i32,
}
pub type k_siginfo_t = k_siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigqueue {
    pub sq_next: *mut sigqueue,
    pub sq_info: k_siginfo_t,
    pub sq_func:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sigqueue)>,
    pub sq_backptr: *mut illumos_sys_hdrs::c_void,
    pub sq_external: illumos_sys_hdrs::c_int,
}
pub type sigqueue_t = sigqueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_sigset_t {
    pub __sigbits: [illumos_sys_hdrs::c_uint; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub sa_flags: illumos_sys_hdrs::c_int,
    pub _funcptr: sigaction__bindgen_ty_1,
    pub sa_mask: sigset_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub _handler: ::core::option::Option<
        unsafe extern "C" fn(arg1: illumos_sys_hdrs::c_int),
    >,
    pub _sigaction: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: illumos_sys_hdrs::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut illumos_sys_hdrs::c_void,
        ),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut illumos_sys_hdrs::c_void,
    pub ss_size: usize,
    pub ss_flags: illumos_sys_hdrs::c_int,
}
pub type stack_t = sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signotify_id {
    pub sn_pid: pid_t,
    pub sn_index: illumos_sys_hdrs::c_int,
    pub sn_pad: illumos_sys_hdrs::c_int,
}
pub type signotify_id_t = signotify_id;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut illumos_sys_hdrs::c_void,
    pub ss_onstack: illumos_sys_hdrs::c_int,
}
unsafe extern "C" {
    pub static nullsmask: k_sigset_t;
}
unsafe extern "C" {
    pub static fillset: k_sigset_t;
}
unsafe extern "C" {
    pub static cantmask: k_sigset_t;
}
unsafe extern "C" {
    pub static cantreset: k_sigset_t;
}
unsafe extern "C" {
    pub static ignoredefault: k_sigset_t;
}
unsafe extern "C" {
    pub static stopdefault: k_sigset_t;
}
unsafe extern "C" {
    pub static coredefault: k_sigset_t;
}
unsafe extern "C" {
    pub static holdvfork: k_sigset_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigsend_t {
    pub sig: illumos_sys_hdrs::c_int,
    pub perm: illumos_sys_hdrs::c_int,
    pub checkperm: illumos_sys_hdrs::c_int,
    pub sicode: illumos_sys_hdrs::c_int,
    pub value: sigval,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct signotifyq_t {
    pub sn_sigq: sigqueue_t,
    pub sn_snid: u_longlong_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigqhdr {
    pub sqb_free: *mut sigqueue_t,
    pub sqb_count: illumos_sys_hdrs::c_int,
    pub sqb_maxcount: uint_t,
    pub sqb_size: usize,
    pub sqb_pexited: uchar_t,
    pub sqb_sent: uint_t,
    pub sqb_cv: kcondvar_t,
    pub sqb_lock: kmutex_t,
}
pub type sigqhdr_t = sigqhdr;
unsafe extern "C" {
    pub fn setsigact(
        arg1: illumos_sys_hdrs::c_int,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: illumos_sys_hdrs::c_int),
        >,
        arg3: *const k_sigset_t,
        arg4: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn sigorset(arg1: *mut k_sigset_t, arg2: *const k_sigset_t);
}
unsafe extern "C" {
    pub fn sigandset(arg1: *mut k_sigset_t, arg2: *const k_sigset_t);
}
unsafe extern "C" {
    pub fn sigdiffset(arg1: *mut k_sigset_t, arg2: *const k_sigset_t);
}
unsafe extern "C" {
    pub fn sigintr(arg1: *mut k_sigset_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn sigunintr(arg1: *mut k_sigset_t);
}
unsafe extern "C" {
    pub fn sigreplace(arg1: *mut k_sigset_t, arg2: *mut k_sigset_t);
}
unsafe extern "C" {
    pub fn kill(
        arg1: pid_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
pub type greg_t = illumos_sys_hdrs::c_long;
pub type gregset_t = [greg_t; 28usize];
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _fpu {
    pub fp_reg_set: _fpu__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _fpu__bindgen_ty_1 {
    pub fpchip_state: _fpu__bindgen_ty_1__fpchip_state,
    pub f_fpregs: [u32; 130usize],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _fpu__bindgen_ty_1__fpchip_state {
    pub cw: u16,
    pub sw: u16,
    pub fctw: u8,
    pub __fx_rsvd: u8,
    pub fop: u16,
    pub rip: u64,
    pub rdp: u64,
    pub mxcsr: u32,
    pub mxcsr_mask: u32,
    pub st: [_fpu__bindgen_ty_1__fpchip_state__bindgen_ty_1; 8usize],
    pub xmm: [upad128_t; 16usize],
    pub __fx_ign2: [upad128_t; 6usize],
    pub status: u32,
    pub xstatus: u32,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _fpu__bindgen_ty_1__fpchip_state__bindgen_ty_1 {
    pub fpr_16: [u16; 5usize],
    pub __fpr_pad: upad128_t,
}
pub type fpregset_t = _fpu;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dbregset {
    pub debugreg: [illumos_sys_hdrs::c_ulong; 16usize],
}
pub type dbregset_t = dbregset;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct tss64 {
    pub tss_rsvd0: u32,
    pub tss_rsp0: u64,
    pub tss_rsp1: u64,
    pub tss_rsp2: u64,
    pub tss_rsvd1: u64,
    pub tss_ist1: u64,
    pub tss_ist2: u64,
    pub tss_ist3: u64,
    pub tss_ist4: u64,
    pub tss_ist5: u64,
    pub tss_ist6: u64,
    pub tss_ist7: u64,
    pub tss_rsvd2: u64,
    pub tss_rsvd3: u16,
    pub tss_bitmapbase: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tss32 {
    pub tss_link: u16,
    pub tss_rsvd0: u16,
    pub tss_esp0: u32,
    pub tss_ss0: u16,
    pub tss_rsvd1: u16,
    pub tss_esp1: u32,
    pub tss_ss1: u16,
    pub tss_rsvd2: u16,
    pub tss_esp2: u32,
    pub tss_ss2: u16,
    pub tss_rsvd3: u16,
    pub tss_cr3: u32,
    pub tss_eip: u32,
    pub tss_eflags: u32,
    pub tss_eax: u32,
    pub tss_ecx: u32,
    pub tss_edx: u32,
    pub tss_ebx: u32,
    pub tss_esp: u32,
    pub tss_ebp: u32,
    pub tss_esi: u32,
    pub tss_edi: u32,
    pub tss_es: u16,
    pub tss_rsvd4: u16,
    pub tss_cs: u16,
    pub tss_rsvd5: u16,
    pub tss_ss: u16,
    pub tss_rsvd6: u16,
    pub tss_ds: u16,
    pub tss_rsvd7: u16,
    pub tss_fs: u16,
    pub tss_rsvd8: u16,
    pub tss_gs: u16,
    pub tss_rsvd9: u16,
    pub tss_ldt: u16,
    pub tss_rsvd10: u16,
    pub tss_rsvd11: u16,
    pub tss_bitmapbase: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tss16 {
    pub tss_link: u16,
    pub tss_sp0: u16,
    pub tss_ss0: u16,
    pub tss_sp1: u16,
    pub tss_ss1: u16,
    pub tss_sp2: u16,
    pub tss_ss2: u16,
    pub tss_ip: u16,
    pub tss_flag: u16,
    pub tss_ax: u16,
    pub tss_cx: u16,
    pub tss_dx: u16,
    pub tss_bx: u16,
    pub tss_sp: u16,
    pub tss_bp: u16,
    pub tss_si: u16,
    pub tss_di: u16,
    pub tss_es: u16,
    pub tss_cs: u16,
    pub tss_ss: u16,
    pub tss_ds: u16,
    pub tss_ldt: u16,
}
pub type tss_t = tss64;
pub type selector_t = u16;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct desctbr_t {
    pub dtr_limit: u16,
    pub dtr_base: u64,
}
unsafe extern "C" {
    pub fn rd_idtr(arg1: *mut desctbr_t);
}
unsafe extern "C" {
    pub fn wr_idtr(arg1: *mut desctbr_t);
}
unsafe extern "C" {
    pub fn rd_gdtr(arg1: *mut desctbr_t);
}
unsafe extern "C" {
    pub fn wr_gdtr(arg1: *mut desctbr_t);
}
unsafe extern "C" {
    pub fn wr_ldtr(arg1: selector_t);
}
unsafe extern "C" {
    pub fn rd_ldtr() -> selector_t;
}
unsafe extern "C" {
    pub fn wr_tsr(arg1: selector_t);
}
unsafe extern "C" {
    pub fn kmdb_enter();
}
unsafe extern "C" {
    pub fn __set_ds(arg1: selector_t);
}
unsafe extern "C" {
    pub fn __set_es(arg1: selector_t);
}
unsafe extern "C" {
    pub fn __set_fs(arg1: selector_t);
}
unsafe extern "C" {
    pub fn __set_gs(arg1: selector_t);
}
unsafe extern "C" {
    pub fn load_segment_registers(
        arg1: selector_t,
        arg2: selector_t,
        arg3: selector_t,
        arg4: selector_t,
    );
}
unsafe extern "C" {
    pub fn get_cs_register() -> selector_t;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct user_desc {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl user_desc {
    #[inline]
    pub fn usd_lolimit(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64)
        }
    }
    #[inline]
    pub fn set_usd_lolimit(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn usd_lolimit_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    16u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_usd_lolimit_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn usd_lobase(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u64)
        }
    }
    #[inline]
    pub fn set_usd_lobase(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn usd_lobase_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    16usize,
                    16u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_usd_lobase_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn usd_midbase(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u64)
        }
    }
    #[inline]
    pub fn set_usd_midbase(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn usd_midbase_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    32usize,
                    8u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_usd_midbase_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn usd_type(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(40usize, 5u8) as u64)
        }
    }
    #[inline]
    pub fn set_usd_type(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn usd_type_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    40usize,
                    5u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_usd_type_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn usd_dpl(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(45usize, 2u8) as u64)
        }
    }
    #[inline]
    pub fn set_usd_dpl(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn usd_dpl_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    45usize,
                    2u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_usd_dpl_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                45usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn usd_p(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u64)
        }
    }
    #[inline]
    pub fn set_usd_p(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn usd_p_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    47usize,
                    1u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_usd_p_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                47usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn usd_hilimit(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(48usize, 4u8) as u64)
        }
    }
    #[inline]
    pub fn set_usd_hilimit(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn usd_hilimit_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    48usize,
                    4u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_usd_hilimit_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn usd_avl(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u64)
        }
    }
    #[inline]
    pub fn set_usd_avl(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn usd_avl_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    52usize,
                    1u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_usd_avl_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                52usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn usd_long(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u64)
        }
    }
    #[inline]
    pub fn set_usd_long(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn usd_long_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    53usize,
                    1u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_usd_long_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                53usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn usd_def32(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u64)
        }
    }
    #[inline]
    pub fn set_usd_def32(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn usd_def32_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    54usize,
                    1u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_usd_def32_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                54usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn usd_gran(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u64)
        }
    }
    #[inline]
    pub fn set_usd_gran(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn usd_gran_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    55usize,
                    1u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_usd_gran_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                55usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn usd_hibase(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u64)
        }
    }
    #[inline]
    pub fn set_usd_hibase(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn usd_hibase_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    56usize,
                    8u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_usd_hibase_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usd_lolimit: u64,
        usd_lobase: u64,
        usd_midbase: u64,
        usd_type: u64,
        usd_dpl: u64,
        usd_p: u64,
        usd_hilimit: u64,
        usd_avl: u64,
        usd_long: u64,
        usd_def32: u64,
        usd_gran: u64,
        usd_hibase: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let usd_lolimit: u64 =
                unsafe { ::core::mem::transmute(usd_lolimit) };
            usd_lolimit as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let usd_lobase: u64 = unsafe { ::core::mem::transmute(usd_lobase) };
            usd_lobase as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let usd_midbase: u64 =
                unsafe { ::core::mem::transmute(usd_midbase) };
            usd_midbase as u64
        });
        __bindgen_bitfield_unit.set(40usize, 5u8, {
            let usd_type: u64 = unsafe { ::core::mem::transmute(usd_type) };
            usd_type as u64
        });
        __bindgen_bitfield_unit.set(45usize, 2u8, {
            let usd_dpl: u64 = unsafe { ::core::mem::transmute(usd_dpl) };
            usd_dpl as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let usd_p: u64 = unsafe { ::core::mem::transmute(usd_p) };
            usd_p as u64
        });
        __bindgen_bitfield_unit.set(48usize, 4u8, {
            let usd_hilimit: u64 =
                unsafe { ::core::mem::transmute(usd_hilimit) };
            usd_hilimit as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let usd_avl: u64 = unsafe { ::core::mem::transmute(usd_avl) };
            usd_avl as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let usd_long: u64 = unsafe { ::core::mem::transmute(usd_long) };
            usd_long as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let usd_def32: u64 = unsafe { ::core::mem::transmute(usd_def32) };
            usd_def32 as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let usd_gran: u64 = unsafe { ::core::mem::transmute(usd_gran) };
            usd_gran as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let usd_hibase: u64 = unsafe { ::core::mem::transmute(usd_hibase) };
            usd_hibase as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type user_desc_t = user_desc;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct system_desc {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl system_desc {
    #[inline]
    pub fn ssd_lolimit(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64)
        }
    }
    #[inline]
    pub fn set_ssd_lolimit(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssd_lolimit_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    16u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ssd_lolimit_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssd_lobase(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u64)
        }
    }
    #[inline]
    pub fn set_ssd_lobase(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssd_lobase_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    16usize,
                    16u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ssd_lobase_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssd_midbase(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u64)
        }
    }
    #[inline]
    pub fn set_ssd_midbase(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssd_midbase_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    32usize,
                    8u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ssd_midbase_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssd_type(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(40usize, 4u8) as u64)
        }
    }
    #[inline]
    pub fn set_ssd_type(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssd_type_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    40usize,
                    4u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ssd_type_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssd_zero1(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u64)
        }
    }
    #[inline]
    pub fn set_ssd_zero1(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssd_zero1_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    44usize,
                    1u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ssd_zero1_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                44usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssd_dpl(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(45usize, 2u8) as u64)
        }
    }
    #[inline]
    pub fn set_ssd_dpl(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssd_dpl_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    45usize,
                    2u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ssd_dpl_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                45usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssd_p(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u64)
        }
    }
    #[inline]
    pub fn set_ssd_p(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssd_p_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    47usize,
                    1u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ssd_p_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                47usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssd_hilimit(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(48usize, 4u8) as u64)
        }
    }
    #[inline]
    pub fn set_ssd_hilimit(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssd_hilimit_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    48usize,
                    4u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ssd_hilimit_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssd_avl(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u64)
        }
    }
    #[inline]
    pub fn set_ssd_avl(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssd_avl_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    52usize,
                    1u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ssd_avl_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                52usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssd_resv1(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(53usize, 2u8) as u64)
        }
    }
    #[inline]
    pub fn set_ssd_resv1(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssd_resv1_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    53usize,
                    2u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ssd_resv1_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                53usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssd_gran(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u64)
        }
    }
    #[inline]
    pub fn set_ssd_gran(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssd_gran_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    55usize,
                    1u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ssd_gran_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                55usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssd_hibase(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u64)
        }
    }
    #[inline]
    pub fn set_ssd_hibase(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssd_hibase_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    56usize,
                    8u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ssd_hibase_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssd_hi64base(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(64usize, 32u8) as u64)
        }
    }
    #[inline]
    pub fn set_ssd_hi64base(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssd_hi64base_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    64usize,
                    32u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ssd_hi64base_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                64usize,
                32u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssd_resv2(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(96usize, 8u8) as u64)
        }
    }
    #[inline]
    pub fn set_ssd_resv2(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(96usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssd_resv2_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    96usize,
                    8u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ssd_resv2_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                96usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssd_zero2(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(104usize, 5u8) as u64)
        }
    }
    #[inline]
    pub fn set_ssd_zero2(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(104usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssd_zero2_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    104usize,
                    5u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ssd_zero2_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                104usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssd_resv3(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(109usize, 19u8) as u64)
        }
    }
    #[inline]
    pub fn set_ssd_resv3(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(109usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssd_resv3_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    109usize,
                    19u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ssd_resv3_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                109usize,
                19u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ssd_lolimit: u64,
        ssd_lobase: u64,
        ssd_midbase: u64,
        ssd_type: u64,
        ssd_zero1: u64,
        ssd_dpl: u64,
        ssd_p: u64,
        ssd_hilimit: u64,
        ssd_avl: u64,
        ssd_resv1: u64,
        ssd_gran: u64,
        ssd_hibase: u64,
        ssd_hi64base: u64,
        ssd_resv2: u64,
        ssd_zero2: u64,
        ssd_resv3: u64,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let ssd_lolimit: u64 =
                unsafe { ::core::mem::transmute(ssd_lolimit) };
            ssd_lolimit as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let ssd_lobase: u64 = unsafe { ::core::mem::transmute(ssd_lobase) };
            ssd_lobase as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let ssd_midbase: u64 =
                unsafe { ::core::mem::transmute(ssd_midbase) };
            ssd_midbase as u64
        });
        __bindgen_bitfield_unit.set(40usize, 4u8, {
            let ssd_type: u64 = unsafe { ::core::mem::transmute(ssd_type) };
            ssd_type as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let ssd_zero1: u64 = unsafe { ::core::mem::transmute(ssd_zero1) };
            ssd_zero1 as u64
        });
        __bindgen_bitfield_unit.set(45usize, 2u8, {
            let ssd_dpl: u64 = unsafe { ::core::mem::transmute(ssd_dpl) };
            ssd_dpl as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let ssd_p: u64 = unsafe { ::core::mem::transmute(ssd_p) };
            ssd_p as u64
        });
        __bindgen_bitfield_unit.set(48usize, 4u8, {
            let ssd_hilimit: u64 =
                unsafe { ::core::mem::transmute(ssd_hilimit) };
            ssd_hilimit as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let ssd_avl: u64 = unsafe { ::core::mem::transmute(ssd_avl) };
            ssd_avl as u64
        });
        __bindgen_bitfield_unit.set(53usize, 2u8, {
            let ssd_resv1: u64 = unsafe { ::core::mem::transmute(ssd_resv1) };
            ssd_resv1 as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let ssd_gran: u64 = unsafe { ::core::mem::transmute(ssd_gran) };
            ssd_gran as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let ssd_hibase: u64 = unsafe { ::core::mem::transmute(ssd_hibase) };
            ssd_hibase as u64
        });
        __bindgen_bitfield_unit.set(64usize, 32u8, {
            let ssd_hi64base: u64 =
                unsafe { ::core::mem::transmute(ssd_hi64base) };
            ssd_hi64base as u64
        });
        __bindgen_bitfield_unit.set(96usize, 8u8, {
            let ssd_resv2: u64 = unsafe { ::core::mem::transmute(ssd_resv2) };
            ssd_resv2 as u64
        });
        __bindgen_bitfield_unit.set(104usize, 5u8, {
            let ssd_zero2: u64 = unsafe { ::core::mem::transmute(ssd_zero2) };
            ssd_zero2 as u64
        });
        __bindgen_bitfield_unit.set(109usize, 19u8, {
            let ssd_resv3: u64 = unsafe { ::core::mem::transmute(ssd_resv3) };
            ssd_resv3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type system_desc_t = system_desc;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct gate_desc {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl gate_desc {
    #[inline]
    pub fn sgd_looffset(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64)
        }
    }
    #[inline]
    pub fn set_sgd_looffset(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sgd_looffset_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    16u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_sgd_looffset_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sgd_selector(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u64)
        }
    }
    #[inline]
    pub fn set_sgd_selector(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sgd_selector_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    16usize,
                    16u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_sgd_selector_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sgd_ist(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(32usize, 3u8) as u64)
        }
    }
    #[inline]
    pub fn set_sgd_ist(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sgd_ist_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    32usize,
                    3u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_sgd_ist_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sgd_resv1(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(35usize, 5u8) as u64)
        }
    }
    #[inline]
    pub fn set_sgd_resv1(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sgd_resv1_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    35usize,
                    5u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_sgd_resv1_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sgd_type(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(40usize, 5u8) as u64)
        }
    }
    #[inline]
    pub fn set_sgd_type(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sgd_type_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    40usize,
                    5u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_sgd_type_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sgd_dpl(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(45usize, 2u8) as u64)
        }
    }
    #[inline]
    pub fn set_sgd_dpl(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sgd_dpl_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    45usize,
                    2u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_sgd_dpl_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                45usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sgd_p(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u64)
        }
    }
    #[inline]
    pub fn set_sgd_p(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sgd_p_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    47usize,
                    1u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_sgd_p_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                47usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sgd_hioffset(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u64)
        }
    }
    #[inline]
    pub fn set_sgd_hioffset(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sgd_hioffset_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    48usize,
                    16u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_sgd_hioffset_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sgd_hi64offset(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(64usize, 32u8) as u64)
        }
    }
    #[inline]
    pub fn set_sgd_hi64offset(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sgd_hi64offset_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    64usize,
                    32u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_sgd_hi64offset_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                64usize,
                32u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sgd_resv2(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(96usize, 8u8) as u64)
        }
    }
    #[inline]
    pub fn set_sgd_resv2(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(96usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sgd_resv2_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    96usize,
                    8u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_sgd_resv2_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                96usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sgd_zero(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(104usize, 5u8) as u64)
        }
    }
    #[inline]
    pub fn set_sgd_zero(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(104usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sgd_zero_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    104usize,
                    5u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_sgd_zero_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                104usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sgd_resv3(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(109usize, 19u8) as u64)
        }
    }
    #[inline]
    pub fn set_sgd_resv3(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(109usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sgd_resv3_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    109usize,
                    19u8,
                ) as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_sgd_resv3_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                109usize,
                19u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sgd_looffset: u64,
        sgd_selector: u64,
        sgd_ist: u64,
        sgd_resv1: u64,
        sgd_type: u64,
        sgd_dpl: u64,
        sgd_p: u64,
        sgd_hioffset: u64,
        sgd_hi64offset: u64,
        sgd_resv2: u64,
        sgd_zero: u64,
        sgd_resv3: u64,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let sgd_looffset: u64 =
                unsafe { ::core::mem::transmute(sgd_looffset) };
            sgd_looffset as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let sgd_selector: u64 =
                unsafe { ::core::mem::transmute(sgd_selector) };
            sgd_selector as u64
        });
        __bindgen_bitfield_unit.set(32usize, 3u8, {
            let sgd_ist: u64 = unsafe { ::core::mem::transmute(sgd_ist) };
            sgd_ist as u64
        });
        __bindgen_bitfield_unit.set(35usize, 5u8, {
            let sgd_resv1: u64 = unsafe { ::core::mem::transmute(sgd_resv1) };
            sgd_resv1 as u64
        });
        __bindgen_bitfield_unit.set(40usize, 5u8, {
            let sgd_type: u64 = unsafe { ::core::mem::transmute(sgd_type) };
            sgd_type as u64
        });
        __bindgen_bitfield_unit.set(45usize, 2u8, {
            let sgd_dpl: u64 = unsafe { ::core::mem::transmute(sgd_dpl) };
            sgd_dpl as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let sgd_p: u64 = unsafe { ::core::mem::transmute(sgd_p) };
            sgd_p as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let sgd_hioffset: u64 =
                unsafe { ::core::mem::transmute(sgd_hioffset) };
            sgd_hioffset as u64
        });
        __bindgen_bitfield_unit.set(64usize, 32u8, {
            let sgd_hi64offset: u64 =
                unsafe { ::core::mem::transmute(sgd_hi64offset) };
            sgd_hi64offset as u64
        });
        __bindgen_bitfield_unit.set(96usize, 8u8, {
            let sgd_resv2: u64 = unsafe { ::core::mem::transmute(sgd_resv2) };
            sgd_resv2 as u64
        });
        __bindgen_bitfield_unit.set(104usize, 5u8, {
            let sgd_zero: u64 = unsafe { ::core::mem::transmute(sgd_zero) };
            sgd_zero as u64
        });
        __bindgen_bitfield_unit.set(109usize, 19u8, {
            let sgd_resv3: u64 = unsafe { ::core::mem::transmute(sgd_resv3) };
            sgd_resv3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gate_desc_t = gate_desc;
unsafe extern "C" {
    pub fn set_usegd(
        arg1: *mut user_desc_t,
        arg2: uint_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: u32,
        arg5: uint_t,
        arg6: uint_t,
        arg7: uint_t,
        arg8: uint_t,
    );
}
unsafe extern "C" {
    pub fn idt_vector_to_ist(arg1: uint_t) -> uint_t;
}
unsafe extern "C" {
    pub fn set_gatesegd(
        arg1: *mut gate_desc_t,
        arg2: ::core::option::Option<unsafe extern "C" fn()>,
        arg3: selector_t,
        arg4: uint_t,
        arg5: uint_t,
        arg6: uint_t,
    );
}
unsafe extern "C" {
    pub fn set_syssegd(
        arg1: *mut system_desc_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
        arg4: uint_t,
        arg5: uint_t,
    );
}
unsafe extern "C" {
    pub fn get_ssd_base(
        arg1: *mut system_desc_t,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn gdt_update_usegd(arg1: uint_t, arg2: *mut user_desc_t);
}
unsafe extern "C" {
    pub fn ldt_update_segd(
        arg1: *mut user_desc_t,
        arg2: *mut user_desc_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn init_boot_gdt(arg1: *mut user_desc_t);
}
unsafe extern "C" {
    pub static mut idt0: *mut gate_desc_t;
}
unsafe extern "C" {
    pub static mut idt0_default_reg: desctbr_t;
}
unsafe extern "C" {
    pub static mut gdt0: *mut user_desc_t;
}
unsafe extern "C" {
    pub static mut zero_udesc: user_desc_t;
}
unsafe extern "C" {
    pub static mut null_udesc: user_desc_t;
}
unsafe extern "C" {
    pub static mut null_sdesc: system_desc_t;
}
unsafe extern "C" {
    pub static mut zero_u32desc: user_desc_t;
}
unsafe extern "C" {
    pub static mut ucs_on: user_desc_t;
}
unsafe extern "C" {
    pub static mut ucs_off: user_desc_t;
}
unsafe extern "C" {
    pub static mut ucs32_on: user_desc_t;
}
unsafe extern "C" {
    pub static mut ucs32_off: user_desc_t;
}
unsafe extern "C" {
    pub static mut ktss0: *mut tss_t;
}
unsafe extern "C" {
    pub fn div0trap();
}
unsafe extern "C" {
    pub fn dbgtrap();
}
unsafe extern "C" {
    pub fn nmiint();
}
unsafe extern "C" {
    pub fn brktrap();
}
unsafe extern "C" {
    pub fn ovflotrap();
}
unsafe extern "C" {
    pub fn boundstrap();
}
unsafe extern "C" {
    pub fn invoptrap();
}
unsafe extern "C" {
    pub fn ndptrap();
}
unsafe extern "C" {
    pub fn syserrtrap();
}
unsafe extern "C" {
    pub fn invaltrap();
}
unsafe extern "C" {
    pub fn invtsstrap();
}
unsafe extern "C" {
    pub fn segnptrap();
}
unsafe extern "C" {
    pub fn stktrap();
}
unsafe extern "C" {
    pub fn gptrap();
}
unsafe extern "C" {
    pub fn pftrap();
}
unsafe extern "C" {
    pub fn ndperr();
}
unsafe extern "C" {
    pub fn overrun();
}
unsafe extern "C" {
    pub fn resvtrap();
}
unsafe extern "C" {
    pub fn _start();
}
unsafe extern "C" {
    pub fn cmnint();
}
unsafe extern "C" {
    pub fn achktrap();
}
unsafe extern "C" {
    pub fn mcetrap();
}
unsafe extern "C" {
    pub fn xmtrap();
}
unsafe extern "C" {
    pub fn fasttrap();
}
unsafe extern "C" {
    pub fn dtrace_ret();
}
unsafe extern "C" {
    pub fn tr_invaltrap();
}
unsafe extern "C" {
    pub fn tr_div0trap();
}
unsafe extern "C" {
    pub fn tr_dbgtrap();
}
unsafe extern "C" {
    pub fn tr_nmiint();
}
unsafe extern "C" {
    pub fn tr_brktrap();
}
unsafe extern "C" {
    pub fn tr_ovflotrap();
}
unsafe extern "C" {
    pub fn tr_boundstrap();
}
unsafe extern "C" {
    pub fn tr_invoptrap();
}
unsafe extern "C" {
    pub fn tr_ndptrap();
}
unsafe extern "C" {
    pub fn tr_syserrtrap();
}
unsafe extern "C" {
    pub fn tr_invtsstrap();
}
unsafe extern "C" {
    pub fn tr_segnptrap();
}
unsafe extern "C" {
    pub fn tr_stktrap();
}
unsafe extern "C" {
    pub fn tr_gptrap();
}
unsafe extern "C" {
    pub fn tr_pftrap();
}
unsafe extern "C" {
    pub fn tr_ndperr();
}
unsafe extern "C" {
    pub fn tr_overrun();
}
unsafe extern "C" {
    pub fn tr_resvtrap();
}
unsafe extern "C" {
    pub fn tr_achktrap();
}
unsafe extern "C" {
    pub fn tr_mcetrap();
}
unsafe extern "C" {
    pub fn tr_xmtrap();
}
unsafe extern "C" {
    pub fn tr_fasttrap();
}
unsafe extern "C" {
    pub fn tr_dtrace_ret();
}
unsafe extern "C" {
    pub static mut kpti_enable: u64;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fnsave_state {
    pub f_fcw: u16,
    pub __f_ign0: u16,
    pub f_fsw: u16,
    pub __f_ign1: u16,
    pub f_ftw: u16,
    pub __f_ign2: u16,
    pub f_eip: u32,
    pub f_cs: u16,
    pub f_fop: u16,
    pub f_dp: u32,
    pub f_ds: u16,
    pub __f_ign3: u16,
    pub f_st: [fnsave_state__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fnsave_state__bindgen_ty_1 {
    pub fpr_16: [u16; 5usize],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct fxsave_state {
    pub fx_fcw: u16,
    pub fx_fsw: u16,
    pub fx_fctw: u16,
    pub fx_fop: u16,
    pub fx_rip: u64,
    pub fx_rdp: u64,
    pub fx_mxcsr: u32,
    pub fx_mxcsr_mask: u32,
    pub fx_st: [fxsave_state__bindgen_ty_1; 8usize],
    pub fx_xmm: [upad128_t; 16usize],
    pub __fx_ign2: [upad128_t; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxsave_state__bindgen_ty_1 {
    pub fpr_16: [u16; 5usize],
    pub fpr_mmx: u_longlong_t,
    pub __fpr_pad: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xsave_header {
    pub xsh_xstate_bv: u64,
    pub xsh_xcomp_bv: u64,
    pub xsh_reserved: [u64; 6usize],
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct xsave_state {
    pub xs_fxsave: fxsave_state,
    pub xs_header: xsave_header,
    pub xs_ymm: [upad128_t; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kfpu_t {
    pub kfpu_u: kfpu_t__kfpu_u,
    pub kfpu_status: u32,
    pub kfpu_xstatus: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kfpu_t__kfpu_u {
    pub kfpu_generic: *mut illumos_sys_hdrs::c_void,
    pub kfpu_fx: *mut fxsave_state,
    pub kfpu_xs: *mut xsave_state,
}
unsafe extern "C" {
    pub static mut fp_kind: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut fp_save_mech: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut fpu_exists: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut fp_elf: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut xsave_bv_all: u64;
}
unsafe extern "C" {
    pub static mut fpu_ignored: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut fpu_pentium_fdivbug: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut sse_mxcsr_mask: u32;
}
unsafe extern "C" {
    pub fn fpu_probe();
}
unsafe extern "C" {
    pub fn fpu_initial_probe() -> uint_t;
}
unsafe extern "C" {
    pub fn fpu_auxv_info(arg1: *mut illumos_sys_hdrs::c_int, arg2: *mut usize);
}
unsafe extern "C" {
    pub fn fpu_xsave_enabled() -> boolean_t;
}
unsafe extern "C" {
    pub fn fpnsave_ctxt(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn fpxsave_ctxt(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn xsave_ctxt(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn xsaveopt_ctxt(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn fpxsave_excp_clr_ctxt(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn xsave_excp_clr_ctxt(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn xsaveopt_excp_clr_ctxt(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub static mut fpsave_ctxt: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
    >;
}
unsafe extern "C" {
    pub static mut xsavep: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut xsave_state, arg2: u64),
    >;
}
unsafe extern "C" {
    pub fn fpxrestore_ctxt(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn xrestore_ctxt(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub static mut fprestore_ctxt: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
    >;
}
unsafe extern "C" {
    pub fn fxsave_insn(arg1: *mut fxsave_state);
}
unsafe extern "C" {
    pub fn fpxsave(arg1: *mut fxsave_state);
}
unsafe extern "C" {
    pub fn fpxrestore(arg1: *mut fxsave_state);
}
unsafe extern "C" {
    pub fn xsave(arg1: *mut xsave_state, arg2: u64);
}
unsafe extern "C" {
    pub fn xsaveopt(arg1: *mut xsave_state, arg2: u64);
}
unsafe extern "C" {
    pub fn xrestore(arg1: *mut xsave_state, arg2: u64);
}
unsafe extern "C" {
    pub fn fpenable();
}
unsafe extern "C" {
    pub fn fpdisable();
}
unsafe extern "C" {
    pub fn fpinit();
}
unsafe extern "C" {
    pub fn fperr_reset() -> u32;
}
unsafe extern "C" {
    pub fn fpxerr_reset() -> u32;
}
unsafe extern "C" {
    pub fn fpgetcwsw() -> u32;
}
unsafe extern "C" {
    pub fn fpgetmxcsr() -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regs {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn fpexterrflt(arg1: *mut regs) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fpsimderrflt(arg1: *mut regs) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fpsetcw(arg1: u16, arg2: u32);
}
unsafe extern "C" {
    pub fn fp_seed();
}
unsafe extern "C" {
    pub fn fp_exec();
}
unsafe extern "C" {
    pub fn fp_lwp_init(arg1: *mut _klwp);
}
unsafe extern "C" {
    pub fn fp_lwp_cleanup(arg1: *mut _klwp);
}
unsafe extern "C" {
    pub fn fp_lwp_dup(arg1: *mut _klwp);
}
unsafe extern "C" {
    pub static sse_initial: fxsave_state;
}
unsafe extern "C" {
    pub static avx_initial: xsave_state;
}
unsafe extern "C" {
    pub fn fpu_proc_xregs_info(
        arg1: *mut proc_,
        arg2: *mut u32,
        arg3: *mut u32,
        arg4: *mut u32,
    );
}
unsafe extern "C" {
    pub fn fpu_proc_xregs_max_size() -> usize;
}
unsafe extern "C" {
    pub fn fpu_proc_xregs_get(
        arg1: *mut _klwp,
        arg2: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn fpu_proc_xregs_set(
        arg1: *mut _klwp,
        arg2: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fpu_signal_copyin(
        arg1: *mut _klwp,
        arg2: *mut ucontext,
    ) -> illumos_sys_hdrs::c_int;
}
pub type fpu_copyout_f = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    ) -> illumos_sys_hdrs::c_int,
>;
unsafe extern "C" {
    pub fn fpu_signal_copyout(
        arg1: *mut _klwp,
        arg2: usize,
        arg3: fpu_copyout_f,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fpu_set_xsave(
        arg1: *mut _klwp,
        arg2: *const illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn fpu_signal_size(arg1: *mut _klwp) -> usize;
}
unsafe extern "C" {
    pub fn fpu_get_fpregset(arg1: *mut _klwp, arg2: *mut fpregset_t);
}
unsafe extern "C" {
    pub fn fpu_set_fpregset(arg1: *mut _klwp, arg2: *const fpregset_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fpu_ctx {
    pub fpu_regs: kfpu_t,
    pub fpu_xsave_mask: u64,
    pub fpu_flags: uint_t,
    pub fpu_signal: *mut illumos_sys_hdrs::c_void,
}
pub type fpu_ctx_t = fpu_ctx;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pcb {
    pub pcb_fpu: fpu_ctx_t,
    pub pcb_flags: uint_t,
    pub pcb_drstat: greg_t,
    pub pcb_instr: illumos_sys_hdrs::c_uchar,
    pub pcb_rupdate: illumos_sys_hdrs::c_uchar,
    pub pcb_fsbase: usize,
    pub pcb_gsbase: usize,
    pub pcb_ds: selector_t,
    pub pcb_es: selector_t,
    pub pcb_fs: selector_t,
    pub pcb_gs: selector_t,
    pub pcb_fsdesc: user_desc_t,
    pub pcb_gsdesc: user_desc_t,
}
pub type pcb_t = pcb;
pub type ucontext_t = ucontext;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct ucontext {
    pub uc_flags: illumos_sys_hdrs::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_sigmask: sigset_t,
    pub uc_stack: stack_t,
    pub __bindgen_padding_0: u64,
    pub uc_mcontext: mcontext_t,
    pub uc_filler: [illumos_sys_hdrs::c_long; 3usize],
    pub uc_xsave: illumos_sys_hdrs::c_long,
    pub uc_filler1: illumos_sys_hdrs::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uc_xsave {
    pub ucx_vers: u32,
    pub ucx_len: u32,
    pub ucx_bv: u64,
}
pub type uc_xsave_t = uc_xsave;
pub const savecontext_flags_t_SAVECTXT_F_NONE: savecontext_flags_t = 0;
pub const savecontext_flags_t_SAVECTXT_F_EXTD: savecontext_flags_t = 1;
pub const savecontext_flags_t_SAVECTXT_F_ONFAULT: savecontext_flags_t = 2;
pub type savecontext_flags_t = illumos_sys_hdrs::c_uint;
unsafe extern "C" {
    pub fn savecontext(
        arg1: *mut ucontext_t,
        arg2: *const k_sigset_t,
        arg3: savecontext_flags_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn restorecontext(arg1: *mut ucontext_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _lwp_mutex {
    pub flags: _lwp_mutex__bindgen_ty_1,
    pub lock: _lwp_mutex__bindgen_ty_2,
    pub data: upad64_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _lwp_mutex__bindgen_ty_1 {
    pub flag1: u16,
    pub flag2: u8,
    pub ceiling: u8,
    pub mbcp_type_un: _lwp_mutex__bindgen_ty_1__bindgen_ty_1,
    pub magic: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _lwp_mutex__bindgen_ty_1__bindgen_ty_1 {
    pub bcptype: u16,
    pub mtype_rcount: _lwp_mutex__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lwp_mutex__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub count_type1: u8,
    pub count_type2: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _lwp_mutex__bindgen_ty_2 {
    pub lock64: _lwp_mutex__bindgen_ty_2__bindgen_ty_1,
    pub lock32: _lwp_mutex__bindgen_ty_2__bindgen_ty_2,
    pub owner64: upad64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lwp_mutex__bindgen_ty_2__bindgen_ty_1 {
    pub pad: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lwp_mutex__bindgen_ty_2__bindgen_ty_2 {
    pub ownerpid: u32,
    pub lockword: u32,
}
pub type lwp_mutex_t = _lwp_mutex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lwp_cond {
    pub flags: _lwp_cond__bindgen_ty_1,
    pub data: upad64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lwp_cond__bindgen_ty_1 {
    pub flag: [u8; 4usize],
    pub type_: u16,
    pub magic: u16,
}
pub type lwp_cond_t = _lwp_cond;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lwp_sema {
    pub count: u32,
    pub type_: u16,
    pub magic: u16,
    pub flags: [u8; 8usize],
    pub data: upad64_t,
}
pub type lwp_sema_t = _lwp_sema;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _lwp_rwlock {
    pub readers: i32,
    pub type_: u16,
    pub magic: u16,
    pub mutex: lwp_mutex_t,
    pub readercv: lwp_cond_t,
    pub writercv: lwp_cond_t,
}
pub type lwp_rwlock_t = _lwp_rwlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lwpinfo {
    pub lwp_utime: timestruc_t,
    pub lwp_stime: timestruc_t,
    pub lwpinfo_pad: [illumos_sys_hdrs::c_long; 64usize],
}
pub type lwpid_t = uint_t;
pub type ctevid_t = u64;
pub const ctstate_CTS_OWNED: ctstate = 0;
pub const ctstate_CTS_INHERITED: ctstate = 1;
pub const ctstate_CTS_ORPHAN: ctstate = 2;
pub const ctstate_CTS_DEAD: ctstate = 3;
pub type ctstate = illumos_sys_hdrs::c_uint;
pub use self::ctstate as ctstate_t;
pub const ct_typeid_CTT_PROCESS: ct_typeid = 0;
pub const ct_typeid_CTT_DEVICE: ct_typeid = 1;
pub const ct_typeid_CTT_MAXTYPE: ct_typeid = 2;
pub type ct_typeid = illumos_sys_hdrs::c_uint;
pub use self::ct_typeid as ct_typeid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ct_event {
    pub ctev_id: ctid_t,
    pub ctev_pad1: u32,
    pub ctev_evid: ctevid_t,
    pub ctev_cttype: ct_typeid_t,
    pub ctev_flags: u32,
    pub ctev_type: u32,
    pub ctev_nbytes: u32,
    pub ctev_goffset: u32,
    pub ctev_pad2: u32,
    pub ctev_buffer: *mut illumos_sys_hdrs::c_char,
}
pub type ct_event_t = ct_event;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ct_status {
    pub ctst_id: ctid_t,
    pub ctst_zoneid: zoneid_t,
    pub ctst_type: ct_typeid_t,
    pub ctst_holder: pid_t,
    pub ctst_state: ctstate_t,
    pub ctst_nevents: illumos_sys_hdrs::c_int,
    pub ctst_ntime: illumos_sys_hdrs::c_int,
    pub ctst_qtime: illumos_sys_hdrs::c_int,
    pub ctst_nevid: u64,
    pub ctst_detail: uint_t,
    pub ctst_nbytes: usize,
    pub ctst_critical: uint_t,
    pub ctst_informative: uint_t,
    pub ctst_cookie: u64,
    pub ctst_buffer: *mut illumos_sys_hdrs::c_char,
}
pub type ct_status_t = ct_status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ct_param {
    pub ctpm_id: u32,
    pub ctpm_size: u32,
    pub ctpm_value: *mut illumos_sys_hdrs::c_void,
}
pub type ct_param_t = ct_param;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lrusage {
    pub minflt: u_longlong_t,
    pub majflt: u_longlong_t,
    pub nswap: u_longlong_t,
    pub inblock: u_longlong_t,
    pub oublock: u_longlong_t,
    pub msgsnd: u_longlong_t,
    pub msgrcv: u_longlong_t,
    pub nsignals: u_longlong_t,
    pub nvcsw: u_longlong_t,
    pub nivcsw: u_longlong_t,
    pub sysc: u_longlong_t,
    pub ioch: u_longlong_t,
}
pub type klwp_id_t = *mut _klwp;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _klwp {
    pub lwp_pcb: pcb,
    pub lwp_oldcontext: usize,
    pub lwp_ap: *mut illumos_sys_hdrs::c_long,
    pub lwp_errno: illumos_sys_hdrs::c_int,
    pub lwp_error: illumos_sys_hdrs::c_char,
    pub lwp_eosys: illumos_sys_hdrs::c_char,
    pub lwp_argsaved: illumos_sys_hdrs::c_char,
    pub lwp_watchtrap: illumos_sys_hdrs::c_char,
    pub lwp_arg: [illumos_sys_hdrs::c_long; 8usize],
    pub lwp_regs: *mut illumos_sys_hdrs::c_void,
    pub lwp_fpu: *mut illumos_sys_hdrs::c_void,
    pub lwp_qsav: label_t,
    pub lwp_cursig: uchar_t,
    pub lwp_curflt: uchar_t,
    pub lwp_sysabort: uchar_t,
    pub lwp_asleep: uchar_t,
    pub lwp_extsig: uchar_t,
    pub lwp_sigaltstack: stack_t,
    pub lwp_curinfo: *mut sigqueue,
    pub lwp_siginfo: k_siginfo_t,
    pub lwp_sigoldmask: k_sigset_t,
    pub lwp_watch: [_klwp_lwp_watch; 4usize],
    pub lwp_oweupc: u32,
    pub lwp_mstate: _klwp_mstate,
    pub lwp_ru: lrusage,
    pub lwp_lastfault: illumos_sys_hdrs::c_int,
    pub lwp_lastfaddr: caddr_t,
    pub lwp_timer: [itimerval; 3usize],
    pub lwp_unused: illumos_sys_hdrs::c_char,
    pub lwp_state: illumos_sys_hdrs::c_char,
    pub lwp_nostop: ushort_t,
    pub lwp_pad: ushort_t,
    pub lwp_badpriv: illumos_sys_hdrs::c_short,
    pub lwp_thread: *mut _kthread,
    pub lwp_procp: *mut proc_,
    pub lwp_childstksz: usize,
    pub lwp_ustack: usize,
    pub lwp_old_stk_ctl: usize,
    pub lwp_ct_active: [*mut ct_template; 2usize],
    pub lwp_ct_latest: [*mut contract; 2usize],
    pub lwp_brand: *mut illumos_sys_hdrs::c_void,
    pub lwp_spymaster: *mut psinfo,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _klwp_lwp_watch {
    pub wpaddr: caddr_t,
    pub wpsize: usize,
    pub wpcode: illumos_sys_hdrs::c_int,
    pub wpmapped: illumos_sys_hdrs::c_int,
    pub wppc: greg_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _klwp_mstate {
    pub ms_prev: illumos_sys_hdrs::c_int,
    pub ms_start: hrtime_t,
    pub ms_term: hrtime_t,
    pub ms_state_start: hrtime_t,
    pub ms_acct: [hrtime_t; 10usize],
}
pub type klwp_t = _klwp;
unsafe extern "C" {
    pub static mut lwp_default_stksize: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut lwp_reapcnt: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut lwp_deathrow: *mut _kthread;
}
unsafe extern "C" {
    pub static mut reaplock: kmutex_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmem_cache {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub static mut lwp_cache: *mut kmem_cache;
}
unsafe extern "C" {
    pub static mut segkp_lwp: *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub static mut lwp0: klwp_t;
}
unsafe extern "C" {
    pub fn lwp_rtt();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpc_attr_t {
    pub ca_name: *mut illumos_sys_hdrs::c_char,
    pub ca_val: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _kcpc_attr {
    pub ka_name: [illumos_sys_hdrs::c_char; 32usize],
    pub ka_val: u64,
}
pub type kcpc_attr_t = _kcpc_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _kcpc_pic {
    pub kp_flags: uint_t,
    pub kp_req: *mut _kcpc_request,
}
pub type kcpc_pic_t = _kcpc_pic;
pub type kcpc_ctx_t = _kcpc_ctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _kcpc_ctx {
    pub kc_set: *mut _kcpc_set,
    pub kc_flags: uint_t,
    pub kc_pics: *mut kcpc_pic_t,
    pub kc_hrtime: hrtime_t,
    pub kc_vtick: u64,
    pub kc_rawtick: u64,
    pub kc_thread: *mut _kthread,
    pub kc_cpuid: illumos_sys_hdrs::c_int,
    pub kc_next: *mut kcpc_ctx_t,
    pub kc_lock: kmutex_t,
    pub kc_condv: kcondvar_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cpc_args {
    pub udata1: *mut illumos_sys_hdrs::c_void,
    pub udata2: *mut illumos_sys_hdrs::c_void,
    pub udata3: *mut illumos_sys_hdrs::c_void,
}
pub type __cpc_args_t = __cpc_args;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cpc_args32 {
    pub udata1: caddr32_t,
    pub udata2: caddr32_t,
    pub udata3: caddr32_t,
}
pub type __cpc_args32_t = __cpc_args32;
pub const dcpc_intr_state_DCPC_INTR_INACTIVE: dcpc_intr_state = 0;
pub const dcpc_intr_state_DCPC_INTR_FREE: dcpc_intr_state = 1;
pub const dcpc_intr_state_DCPC_INTR_PROCESSING: dcpc_intr_state = 2;
pub const dcpc_intr_state_DCPC_INTR_CONFIG: dcpc_intr_state = 3;
pub type dcpc_intr_state = illumos_sys_hdrs::c_uint;
pub const dcpc_mask_attr_DCPC_UMASK: dcpc_mask_attr = 1;
pub const dcpc_mask_attr_DCPC_EMASK: dcpc_mask_attr = 2;
pub type dcpc_mask_attr = illumos_sys_hdrs::c_uint;
unsafe extern "C" {
    pub fn tsc_read() -> hrtime_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub static mut cpc_ncounters: uint_t;
}
unsafe extern "C" {
    pub static mut kcpc_cpuctx_lock: krwlock_t;
}
unsafe extern "C" {
    pub static mut kcpc_cpuctx: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_invalidate_all();
}
unsafe extern "C" {
    pub fn kcpc_passivate();
}
unsafe extern "C" {
    pub fn kcpc_cpu_stop(arg1: *mut cpu, arg2: boolean_t);
}
unsafe extern "C" {
    pub fn kcpc_pcbe_tryload(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: uint_t,
        arg3: uint_t,
        arg4: uint_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_cpu_program(arg1: *mut cpu, arg2: *mut kcpc_ctx_t);
}
unsafe extern "C" {
    pub fn kcpc_register_dcpc(
        func: ::core::option::Option<unsafe extern "C" fn(arg1: u64)>,
    );
}
unsafe extern "C" {
    pub fn kcpc_unregister_dcpc();
}
unsafe extern "C" {
    pub fn kcpc_ctx_alloc(arg1: illumos_sys_hdrs::c_int) -> *mut kcpc_ctx_t;
}
unsafe extern "C" {
    pub fn kcpc_assign_reqs(
        arg1: *mut _kcpc_set,
        arg2: *mut kcpc_ctx_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_ctx_free(arg1: *mut kcpc_ctx_t);
}
unsafe extern "C" {
    pub fn kcpc_configure_reqs(
        arg1: *mut kcpc_ctx_t,
        arg2: *mut _kcpc_set,
        arg3: *mut illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_free_configs(arg1: *mut _kcpc_set);
}
pub type kcpc_set_t = _kcpc_set;
pub type kcpc_request_t = _kcpc_request;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pcbe_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _kcpc_set {
    pub ks_flags: illumos_sys_hdrs::c_int,
    pub ks_nreqs: illumos_sys_hdrs::c_int,
    pub ks_req: *mut kcpc_request_t,
    pub ks_data: *mut u64,
    pub ks_ctx: *mut kcpc_ctx_t,
    pub ks_state: ushort_t,
    pub ks_lock: kmutex_t,
    pub ks_condv: kcondvar_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _kcpc_request {
    pub kr_config: *mut illumos_sys_hdrs::c_void,
    pub kr_index: illumos_sys_hdrs::c_int,
    pub kr_picnum: illumos_sys_hdrs::c_int,
    pub kr_picp: *mut kcpc_pic_t,
    pub kr_data: *mut u64,
    pub kr_event: [illumos_sys_hdrs::c_char; 512usize],
    pub kr_preset: u64,
    pub kr_flags: uint_t,
    pub kr_nattrs: uint_t,
    pub kr_attr: *mut kcpc_attr_t,
    pub kr_ptr: *mut illumos_sys_hdrs::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _kcpc_request_list {
    pub krl_list: *mut kcpc_request_t,
    pub krl_cnt: illumos_sys_hdrs::c_int,
    pub krl_max: illumos_sys_hdrs::c_int,
}
pub type kcpc_request_list_t = _kcpc_request_list;
pub type kcpc_update_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: u64,
    ) -> illumos_sys_hdrs::c_int,
>;
pub type kcpc_read_func_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: kcpc_update_func_t) -> illumos_sys_hdrs::c_int,
>;
unsafe extern "C" {
    pub fn kcpc_init() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_bind_thread(
        set: *mut kcpc_set_t,
        t: *mut _kthread,
        subcode: *mut illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_bind_cpu(
        set: *mut kcpc_set_t,
        cpuid: illumos_sys_hdrs::c_int,
        subcode: *mut illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_sample(
        set: *mut kcpc_set_t,
        buf: *mut u64,
        hrtime: *mut hrtime_t,
        tick: *mut u64,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_cpu_ctx_create(
        cp: *mut cpu,
        req_list: *mut kcpc_request_list_t,
        kmem_flags: illumos_sys_hdrs::c_int,
        ctx_ptr_array: *mut *mut *mut kcpc_ctx_t,
        ctx_ptr_array_sz: *mut usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_event_supported(
        event: *mut illumos_sys_hdrs::c_char,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn kcpc_reqs_init(
        nreqs: illumos_sys_hdrs::c_int,
        kmem_flags: illumos_sys_hdrs::c_int,
    ) -> *mut kcpc_request_list_t;
}
unsafe extern "C" {
    pub fn kcpc_reqs_add(
        req_list: *mut kcpc_request_list_t,
        event: *mut illumos_sys_hdrs::c_char,
        preset: u64,
        flags: uint_t,
        nattrs: uint_t,
        attr: *mut kcpc_attr_t,
        ptr: *mut illumos_sys_hdrs::c_void,
        kmem_flags: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_reqs_reset(
        req_list: *mut kcpc_request_list_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_reqs_fini(
        req_list: *mut kcpc_request_list_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_read(arg1: kcpc_update_func_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_program(
        ctx: *mut kcpc_ctx_t,
        for_thread: boolean_t,
        cu_interpose: boolean_t,
    );
}
unsafe extern "C" {
    pub fn kcpc_unprogram(ctx: *mut kcpc_ctx_t, cu_interpose: boolean_t);
}
unsafe extern "C" {
    pub fn kcpc_unbind(set: *mut kcpc_set_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_preset(
        set: *mut kcpc_set_t,
        index: illumos_sys_hdrs::c_int,
        preset: u64,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_restart(set: *mut kcpc_set_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_enable(
        t: *mut _kthread,
        cmd: illumos_sys_hdrs::c_int,
        enable: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_invalidate(t: *mut _kthread);
}
unsafe extern "C" {
    pub fn kcpc_overflow_ast() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_hw_overflow_intr(arg1: caddr_t, arg2: caddr_t) -> uint_t;
}
unsafe extern "C" {
    pub fn kcpc_hw_cpu_hook(
        cpuid: illumos_sys_hdrs::c_int,
        kcpc_cpumap: *mut ulong_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_hw_lwp_hook() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_idle_ctxop_install(arg1: *mut _kthread, arg2: *mut cpu);
}
unsafe extern "C" {
    pub fn kcpc_free_cpu(arg1: *mut kcpc_ctx_t);
}
unsafe extern "C" {
    pub static mut dtrace_cpc_in_use: u32;
}
unsafe extern "C" {
    pub static mut dtrace_cpc_fire:
        ::core::option::Option<unsafe extern "C" fn(arg1: u64)>;
}
unsafe extern "C" {
    pub fn kcpc_free_set(set: *mut kcpc_set_t);
}
unsafe extern "C" {
    pub fn kcpc_next_config(
        token: *mut illumos_sys_hdrs::c_void,
        current: *mut illumos_sys_hdrs::c_void,
        data: *mut *mut u64,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn kcpc_invalidate_config(token: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn kcpc_list_attrs() -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn kcpc_list_events(pic: uint_t) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn kcpc_pcbe_capabilities() -> uint_t;
}
unsafe extern "C" {
    pub fn kcpc_pcbe_loaded() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_allow_nonpriv(
        token: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcpc_register_pcbe(arg1: *mut __pcbe_ops);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctxop {
    pub save_op: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
    >,
    pub restore_op: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
    >,
    pub fork_op: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut illumos_sys_hdrs::c_void,
            arg2: *mut illumos_sys_hdrs::c_void,
        ),
    >,
    pub lwp_create_op: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut illumos_sys_hdrs::c_void,
            arg2: *mut illumos_sys_hdrs::c_void,
        ),
    >,
    pub exit_op: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
    >,
    pub free_op: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut illumos_sys_hdrs::c_void,
            arg2: illumos_sys_hdrs::c_int,
        ),
    >,
    pub arg: *mut illumos_sys_hdrs::c_void,
    pub next: *mut ctxop,
    pub prev: *mut ctxop,
    pub save_ts: hrtime_t,
    pub restore_ts: hrtime_t,
}
pub type ctxop_t = ctxop;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct afd_t {
    pub a_fdlock: kmutex_t,
    pub a_fd: *mut illumos_sys_hdrs::c_int,
    pub a_nfd: illumos_sys_hdrs::c_int,
    pub a_stale: illumos_sys_hdrs::c_int,
    pub a_buf: [illumos_sys_hdrs::c_int; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lwpchan_t {
    pub lc_wchan0: caddr_t,
    pub lc_wchan: caddr_t,
}
pub type kthread_id_t = *mut _kthread;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turnstile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct panic_trap_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct upimutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kproject {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct on_trap_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct waitq {
    _unused: [u8; 0],
}
pub type kt_did_t = u64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _kthread {
    pub t_link: *mut _kthread,
    pub t_stk: caddr_t,
    pub t_startpc: ::core::option::Option<unsafe extern "C" fn()>,
    pub t_bound_cpu: *mut cpu,
    pub t_affinitycnt: illumos_sys_hdrs::c_short,
    pub t_bind_cpu: illumos_sys_hdrs::c_short,
    pub t_flag: uint_t,
    pub t_proc_flag: ushort_t,
    pub t_schedflag: ushort_t,
    pub t_preempt: illumos_sys_hdrs::c_char,
    pub t_preempt_lk: illumos_sys_hdrs::c_char,
    pub t_state: uint_t,
    pub t_pri: pri_t,
    pub t_epri: pri_t,
    pub t_cpri: pri_t,
    pub t_writer: illumos_sys_hdrs::c_char,
    pub t_bindflag: uchar_t,
    pub t_pcb: label_t,
    pub t_lwpchan: lwpchan_t,
    pub t_sobj_ops: *mut _sobj_ops,
    pub t_cid: id_t,
    pub t_clfuncs: *mut thread_ops,
    pub t_cldata: *mut illumos_sys_hdrs::c_void,
    pub t_ctx: *mut ctxop_t,
    pub t_lofault: usize,
    pub t_onfault: *mut label_t,
    pub t_ontrap: *mut on_trap_data,
    pub t_swap: caddr_t,
    pub t_lock: lock_t,
    pub t_lockstat: u8,
    pub t_pil: u8,
    pub t_pi_lock: disp_lock_t,
    pub t_nomigrate: illumos_sys_hdrs::c_char,
    pub t_cpu: *mut cpu,
    pub t_weakbound_cpu: *mut cpu,
    pub t_lpl: *mut lgrp_ld,
    pub t_lgrp_reserv: [*mut illumos_sys_hdrs::c_void; 2usize],
    pub t_intr: *mut _kthread,
    pub t_intr_start: u64,
    pub t_did: kt_did_t,
    pub t_cpc_ctx: *mut _kcpc_ctx,
    pub t_cpc_set: *mut _kcpc_set,
    pub t_tid: id_t,
    pub t_waitfor: id_t,
    pub t_sigqueue: *mut sigqueue,
    pub t_sig: k_sigset_t,
    pub t_extsig: k_sigset_t,
    pub t_hold: k_sigset_t,
    pub t_sigwait: k_sigset_t,
    pub t_forw: *mut _kthread,
    pub t_back: *mut _kthread,
    pub t_thlink: *mut _kthread,
    pub t_lwp: *mut klwp_t,
    pub t_procp: *mut proc_,
    pub t_audit_data: *mut t_audit_data,
    pub t_next: *mut _kthread,
    pub t_prev: *mut _kthread,
    pub t_whystop: ushort_t,
    pub t_whatstop: ushort_t,
    pub t_dslot: illumos_sys_hdrs::c_int,
    pub t_pollstate: *mut pollstate,
    pub t_pollcache: *mut pollcache,
    pub t_cred: *mut cred,
    pub t_start: time_t,
    pub t_lbolt: clock_t,
    pub t_stoptime: hrtime_t,
    pub t_pctcpu: uint_t,
    pub t_sysnum: illumos_sys_hdrs::c_short,
    pub t_delay_cv: kcondvar_t,
    pub t_delay_lock: kmutex_t,
    pub t_lockp: *mut disp_lock_t,
    pub t_oldspl: ushort_t,
    pub t_pre_sys: illumos_sys_hdrs::c_char,
    pub t_lock_flush: lock_t,
    pub t_disp_queue: *mut _disp,
    pub t_disp_time: clock_t,
    pub _tu: _kthread___tu,
    pub t_waitrq: hrtime_t,
    pub t_mstate: illumos_sys_hdrs::c_int,
    pub t_rprof: *mut _kthread_rprof,
    pub t_prioinv: *mut turnstile,
    pub t_ts: *mut turnstile,
    pub t_tsd: *mut _kthread_tsd_thread,
    pub t_stime: clock_t,
    pub t_door: *mut door_data,
    pub t_plockp: *mut kmutex_t,
    pub t_schedctl: *mut sc_shared,
    pub t_sc_uaddr: usize,
    pub t_cpupart: *mut cpupart,
    pub t_bind_pset: illumos_sys_hdrs::c_int,
    pub t_copyops: *mut copyops,
    pub t_stkbase: caddr_t,
    pub t_red_pp: *mut page,
    pub t_activefd: afd_t,
    pub t_priforw: *mut _kthread,
    pub t_priback: *mut _kthread,
    pub t_sleepq: *mut sleepq,
    pub t_panic_trap: *mut panic_trap_info,
    pub t_lgrp_affinity: *mut illumos_sys_hdrs::c_int,
    pub t_upimutex: *mut upimutex,
    pub t_nupinest: u32,
    pub t_proj: *mut kproject,
    pub t_unpark: u8,
    pub t_release: u8,
    pub t_hatdepth: u8,
    pub t_xpvcntr: u8,
    pub t_joincv: kcondvar_t,
    pub t_taskq: *mut illumos_sys_hdrs::c_void,
    pub t_anttime: hrtime_t,
    pub t_pdmsg: *mut illumos_sys_hdrs::c_char,
    pub t_predcache: uint_t,
    pub t_dtrace_vtime: hrtime_t,
    pub t_dtrace_start: hrtime_t,
    pub t_dtrace_stop: u8,
    pub t_dtrace_sig: u8,
    pub _tdu: _kthread___tdu,
    pub t_dtrace_pc: usize,
    pub t_dtrace_npc: usize,
    pub t_dtrace_scrpc: usize,
    pub t_dtrace_astpc: usize,
    pub t_dtrace_regv: u64,
    pub t_useracc: u64,
    pub t_hrtime: hrtime_t,
    pub t_ctx_lock: kmutex_t,
    pub t_waitq: *mut waitq,
    pub t_wait_mutex: kmutex_t,
    pub t_name: *mut illumos_sys_hdrs::c_char,
    pub t_unsafe: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _kthread___tu {
    pub _ts: _kthread___tu___ts,
    pub _t_post_sys_ast: illumos_sys_hdrs::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _kthread___tu___ts {
    pub _t_astflag: illumos_sys_hdrs::c_char,
    pub _t_sig_check: illumos_sys_hdrs::c_char,
    pub _t_post_sys: illumos_sys_hdrs::c_char,
    pub _t_trapret: illumos_sys_hdrs::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _kthread_rprof {
    pub rp_anystate: illumos_sys_hdrs::c_int,
    pub rp_state: [uint_t; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _kthread_tsd_thread {
    pub ts_next: *mut _kthread_tsd_thread,
    pub ts_prev: *mut _kthread_tsd_thread,
    pub ts_nkeys: uint_t,
    pub ts_value: *mut *mut illumos_sys_hdrs::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _kthread___tdu {
    pub _tds: _kthread___tdu___tds,
    pub _t_dtrace_ft: ulong_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _kthread___tdu___tds {
    pub _t_dtrace_on: u8,
    pub _t_dtrace_step: u8,
    pub _t_dtrace_ret: u8,
    pub _t_dtrace_ast: u8,
    pub _t_dtrace_reg: u8,
}
pub type kthread_t = _kthread;
unsafe extern "C" {
    pub fn threadp() -> *mut kthread_t;
}
unsafe extern "C" {
    pub static mut t0: _kthread;
}
unsafe extern "C" {
    pub static mut pidlock: kmutex_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_free_lock {
    pub tf_lock: kmutex_t,
    pub tf_pad: [uchar_t; 56usize],
}
pub type thread_free_lock_t = thread_free_lock;
unsafe extern "C" {
    pub fn thread_free_prevent(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn thread_free_allow(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn thread_change_pri(
        t: *mut kthread_t,
        disp_pri: pri_t,
        front: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn thread_change_epri(t: *mut kthread_t, disp_pri: pri_t);
}
unsafe extern "C" {
    pub fn thread_transition(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn thread_stop(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn thread_lock(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn thread_lock_high(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn thread_onproc(arg1: *mut kthread_t, arg2: *mut cpu);
}
unsafe extern "C" {
    pub static mut transition_lock: disp_lock_t;
}
unsafe extern "C" {
    pub static mut stop_lock: disp_lock_t;
}
unsafe extern "C" {
    pub fn thread_stk_init(arg1: caddr_t) -> caddr_t;
}
unsafe extern "C" {
    pub fn thread_setname(
        arg1: *mut kthread_t,
        arg2: *const illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn thread_vsetname(
        arg1: *mut kthread_t,
        arg2: *const illumos_sys_hdrs::c_char,
        ...
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut default_binding_mode: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut default_stksize: illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmem_stkinfo {
    pub kthread: caddr_t,
    pub t_startpc: caddr_t,
    pub start: caddr_t,
    pub stksz: usize,
    pub percent: usize,
    pub t_tid: id_t,
    pub cmd: [illumos_sys_hdrs::c_char; 64usize],
}
pub type kmem_stkinfo_t = kmem_stkinfo;
pub const ksema_type_t_SEMA_DEFAULT: ksema_type_t = 0;
pub const ksema_type_t_SEMA_DRIVER: ksema_type_t = 1;
pub type ksema_type_t = illumos_sys_hdrs::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ksema {
    pub _opaque: [*mut illumos_sys_hdrs::c_void; 2usize],
}
pub type ksema_t = _ksema;
unsafe extern "C" {
    pub fn sema_init(
        arg1: *mut ksema_t,
        arg2: u32,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: ksema_type_t,
        arg5: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn sema_destroy(arg1: *mut ksema_t);
}
unsafe extern "C" {
    pub fn sema_p(arg1: *mut ksema_t);
}
unsafe extern "C" {
    pub fn sema_p_sig(arg1: *mut ksema_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn sema_v(arg1: *mut ksema_t);
}
unsafe extern "C" {
    pub fn sema_tryp(arg1: *mut ksema_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn sema_held(arg1: *mut ksema_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut ncpus: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn disp_lock_enter(arg1: *mut disp_lock_t);
}
unsafe extern "C" {
    pub fn disp_lock_exit(arg1: *mut disp_lock_t);
}
unsafe extern "C" {
    pub fn disp_lock_exit_nopreempt(arg1: *mut disp_lock_t);
}
unsafe extern "C" {
    pub fn disp_lock_enter_high(arg1: *mut disp_lock_t);
}
unsafe extern "C" {
    pub fn disp_lock_exit_high(arg1: *mut disp_lock_t);
}
unsafe extern "C" {
    pub fn disp_lock_init(
        lp: *mut disp_lock_t,
        name: *mut illumos_sys_hdrs::c_char,
    );
}
unsafe extern "C" {
    pub fn disp_lock_destroy(lp: *mut disp_lock_t);
}
unsafe extern "C" {
    pub static mut kstat_chain_id: kid_t;
}
unsafe extern "C" {
    pub fn kstat_init();
}
unsafe extern "C" {
    pub fn kstat_create(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *const illumos_sys_hdrs::c_char,
        arg4: *const illumos_sys_hdrs::c_char,
        arg5: uchar_t,
        arg6: uint_t,
        arg7: uchar_t,
    ) -> *mut kstat_t;
}
unsafe extern "C" {
    pub fn kstat_create_zone(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *const illumos_sys_hdrs::c_char,
        arg4: *const illumos_sys_hdrs::c_char,
        arg5: uchar_t,
        arg6: uint_t,
        arg7: uchar_t,
        arg8: zoneid_t,
    ) -> *mut kstat_t;
}
unsafe extern "C" {
    pub fn kstat_install(arg1: *mut kstat_t);
}
unsafe extern "C" {
    pub fn kstat_delete(arg1: *mut kstat_t);
}
unsafe extern "C" {
    pub fn kstat_named_setstr(
        knp: *mut kstat_named_t,
        src: *const illumos_sys_hdrs::c_char,
    );
}
unsafe extern "C" {
    pub fn kstat_set_string(
        arg1: *mut illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
    );
}
unsafe extern "C" {
    pub fn kstat_delete_byname(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *const illumos_sys_hdrs::c_char,
    );
}
unsafe extern "C" {
    pub fn kstat_delete_byname_zone(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *const illumos_sys_hdrs::c_char,
        arg4: zoneid_t,
    );
}
unsafe extern "C" {
    pub fn kstat_named_init(
        arg1: *mut kstat_named_t,
        arg2: *const illumos_sys_hdrs::c_char,
        arg3: uchar_t,
    );
}
unsafe extern "C" {
    pub fn kstat_timer_init(
        arg1: *mut kstat_timer_t,
        arg2: *const illumos_sys_hdrs::c_char,
    );
}
unsafe extern "C" {
    pub fn kstat_waitq_enter(arg1: *mut kstat_io_t);
}
unsafe extern "C" {
    pub fn kstat_waitq_exit(arg1: *mut kstat_io_t);
}
unsafe extern "C" {
    pub fn kstat_runq_enter(arg1: *mut kstat_io_t);
}
unsafe extern "C" {
    pub fn kstat_runq_exit(arg1: *mut kstat_io_t);
}
unsafe extern "C" {
    pub fn kstat_waitq_to_runq(arg1: *mut kstat_io_t);
}
unsafe extern "C" {
    pub fn kstat_runq_back_to_waitq(arg1: *mut kstat_io_t);
}
unsafe extern "C" {
    pub fn kstat_timer_start(arg1: *mut kstat_timer_t);
}
unsafe extern "C" {
    pub fn kstat_timer_stop(arg1: *mut kstat_timer_t);
}
unsafe extern "C" {
    pub fn kstat_zone_add(arg1: *mut kstat_t, arg2: zoneid_t);
}
unsafe extern "C" {
    pub fn kstat_zone_remove(arg1: *mut kstat_t, arg2: zoneid_t);
}
unsafe extern "C" {
    pub fn kstat_zone_find(
        arg1: *mut kstat_t,
        arg2: zoneid_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kstat_hold_bykid(kid: kid_t, arg1: zoneid_t) -> *mut kstat_t;
}
unsafe extern "C" {
    pub fn kstat_hold_byname(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *const illumos_sys_hdrs::c_char,
        arg4: zoneid_t,
    ) -> *mut kstat_t;
}
unsafe extern "C" {
    pub fn kstat_rele(arg1: *mut kstat_t);
}
pub type cred_t = cred;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct prcred {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ksid {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ksidlist {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct credklpd {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct credgrp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auditinfo_addr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub static mut ngroups_max: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut kcred: *mut cred;
}
unsafe extern "C" {
    pub fn cred_init();
}
unsafe extern "C" {
    pub fn crhold(arg1: *mut cred_t);
}
unsafe extern "C" {
    pub fn crfree(arg1: *mut cred_t);
}
unsafe extern "C" {
    pub fn cralloc() -> *mut cred_t;
}
unsafe extern "C" {
    pub fn cralloc_ksid() -> *mut cred_t;
}
unsafe extern "C" {
    pub fn crget() -> *mut cred_t;
}
unsafe extern "C" {
    pub fn crcopy(arg1: *mut cred_t) -> *mut cred_t;
}
unsafe extern "C" {
    pub fn crcopy_to(arg1: *mut cred_t, arg2: *mut cred_t);
}
unsafe extern "C" {
    pub fn crdup(arg1: *mut cred_t) -> *mut cred_t;
}
unsafe extern "C" {
    pub fn crdup_to(arg1: *mut cred_t, arg2: *mut cred_t);
}
unsafe extern "C" {
    pub fn crgetcred() -> *mut cred_t;
}
unsafe extern "C" {
    pub fn crset(arg1: *mut proc_, arg2: *mut cred_t);
}
unsafe extern "C" {
    pub fn crset_zone_privall(arg1: *mut cred_t);
}
unsafe extern "C" {
    pub fn groupmember(
        arg1: gid_t,
        arg2: *const cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn supgroupmember(
        arg1: gid_t,
        arg2: *const cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn hasprocperm(
        arg1: *const cred_t,
        arg2: *const cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prochasprocperm(
        arg1: *mut proc_,
        arg2: *mut proc_,
        arg3: *const cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn crcmp(
        arg1: *const cred_t,
        arg2: *const cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn zone_kcred() -> *mut cred_t;
}
unsafe extern "C" {
    pub fn crgetuid(arg1: *const cred_t) -> uid_t;
}
unsafe extern "C" {
    pub fn crgetruid(arg1: *const cred_t) -> uid_t;
}
unsafe extern "C" {
    pub fn crgetsuid(arg1: *const cred_t) -> uid_t;
}
unsafe extern "C" {
    pub fn crgetgid(arg1: *const cred_t) -> gid_t;
}
unsafe extern "C" {
    pub fn crgetrgid(arg1: *const cred_t) -> gid_t;
}
unsafe extern "C" {
    pub fn crgetsgid(arg1: *const cred_t) -> gid_t;
}
unsafe extern "C" {
    pub fn crgetzoneid(arg1: *const cred_t) -> zoneid_t;
}
unsafe extern "C" {
    pub fn crgetprojid(arg1: *const cred_t) -> projid_t;
}
unsafe extern "C" {
    pub fn crgetmapped(arg1: *const cred_t) -> *mut cred_t;
}
unsafe extern "C" {
    pub fn crgetauinfo(arg1: *const cred_t) -> *const auditinfo_addr;
}
unsafe extern "C" {
    pub fn crgetauinfo_modifiable(arg1: *mut cred_t) -> *mut auditinfo_addr;
}
unsafe extern "C" {
    pub fn crgetref(arg1: *const cred_t) -> uint_t;
}
unsafe extern "C" {
    pub fn crgetgroups(arg1: *const cred_t) -> *const gid_t;
}
unsafe extern "C" {
    pub fn crgetggroups(arg1: *const credgrp) -> *const gid_t;
}
unsafe extern "C" {
    pub fn crgetngroups(arg1: *const cred_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn crsetresuid(
        arg1: *mut cred_t,
        arg2: uid_t,
        arg3: uid_t,
        arg4: uid_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn crsetresgid(
        arg1: *mut cred_t,
        arg2: gid_t,
        arg3: gid_t,
        arg4: gid_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn crsetugid(
        arg1: *mut cred_t,
        arg2: uid_t,
        arg3: gid_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn crsetgroups(
        arg1: *mut cred_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut gid_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn crgrpcopyin(
        arg1: illumos_sys_hdrs::c_int,
        arg2: *mut gid_t,
    ) -> *mut credgrp;
}
unsafe extern "C" {
    pub fn crgrprele(arg1: *mut credgrp);
}
unsafe extern "C" {
    pub fn crsetcredgrp(arg1: *mut cred_t, arg2: *mut credgrp);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zone {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn crsetzone(arg1: *mut cred_t, arg2: *mut zone);
}
unsafe extern "C" {
    pub fn crgetzone(arg1: *const cred_t) -> *mut zone;
}
unsafe extern "C" {
    pub fn crsetprojid(arg1: *mut cred_t, arg2: projid_t);
}
unsafe extern "C" {
    pub fn crnetadjust(arg1: *mut cred_t) -> *mut cred_t;
}
unsafe extern "C" {
    pub fn cred2prcred(arg1: *const cred_t, arg2: *mut prcred);
}
unsafe extern "C" {
    pub fn crgetlabel(arg1: *const cred_t) -> *mut ts_label_s;
}
unsafe extern "C" {
    pub fn crisremote(arg1: *const cred_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn valid_ephemeral_uid(arg1: *mut zone, arg2: uid_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn valid_ephemeral_gid(arg1: *mut zone, arg2: gid_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn eph_uid_alloc(
        arg1: *mut zone,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut uid_t,
        arg4: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn eph_gid_alloc(
        arg1: *mut zone,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut gid_t,
        arg4: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn crsetsid(
        arg1: *mut cred_t,
        arg2: *mut ksid,
        arg3: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn crsetsidlist(arg1: *mut cred_t, arg2: *mut ksidlist);
}
unsafe extern "C" {
    pub fn crgetsid(
        arg1: *const cred_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> *mut ksid;
}
unsafe extern "C" {
    pub fn crgetsidlist(arg1: *const cred_t) -> *mut ksidlist;
}
unsafe extern "C" {
    pub fn crsetpriv(arg1: *mut cred_t, ...) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn crgetcrklpd(arg1: *const cred_t) -> *mut credklpd;
}
unsafe extern "C" {
    pub fn crsetcrklpd(arg1: *mut cred_t, arg2: *mut credklpd);
}
pub type netstackid_t = id_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nm_state_t {
    pub nms_flags: u16,
    pub nms_cv: kcondvar_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netstack {
    pub netstack_u: netstack__bindgen_ty_1,
    pub netstack_m_state: [nm_state_t; 19usize],
    pub netstack_lock: kmutex_t,
    pub netstack_next: *mut netstack,
    pub netstack_stackid: netstackid_t,
    pub netstack_numzones: illumos_sys_hdrs::c_int,
    pub netstack_refcnt: illumos_sys_hdrs::c_int,
    pub netstack_flags: illumos_sys_hdrs::c_int,
    pub netstack_cv: kcondvar_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union netstack__bindgen_ty_1 {
    pub nu_modules: [*mut illumos_sys_hdrs::c_void; 19usize],
    pub nu_s: netstack__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netstack__bindgen_ty_1__bindgen_ty_1 {
    pub nu_dls: *mut dls_stack,
    pub nu_iptun: *mut iptun_stack,
    pub nu_str: *mut str_stack,
    pub nu_hook: *mut hook_stack,
    pub nu_neti: *mut neti_stack,
    pub nu_arp: *mut arp_stack,
    pub nu_ip: *mut ip_stack,
    pub nu_icmp: *mut icmp_stack,
    pub nu_udp: *mut udp_stack,
    pub nu_tcp: *mut tcp_stack,
    pub nu_sctp: *mut sctp_stack,
    pub nu_rts: *mut rts_stack,
    pub nu_ipsec: *mut ipsec_stack,
    pub nu_keysock: *mut keysock_stack,
    pub nu_spdsock: *mut spd_stack,
    pub nu_ipsecah: *mut ipsecah_stack,
    pub nu_ipsecesp: *mut ipsecesp_stack,
    pub nu_ipnet: *mut ipnet_stack,
    pub nu_ilb: *mut ilb_stack,
}
pub type netstack_t = netstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netstack_registry {
    pub nr_flags: illumos_sys_hdrs::c_int,
    pub nr_create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: netstackid_t,
            arg2: *mut netstack_t,
        ) -> *mut illumos_sys_hdrs::c_void,
    >,
    pub nr_shutdown: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: netstackid_t,
            arg2: *mut illumos_sys_hdrs::c_void,
        ),
    >,
    pub nr_destroy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: netstackid_t,
            arg2: *mut illumos_sys_hdrs::c_void,
        ),
    >,
}
unsafe extern "C" {
    pub fn netstack_init();
}
unsafe extern "C" {
    pub fn netstack_hold(arg1: *mut netstack_t);
}
unsafe extern "C" {
    pub fn netstack_hold_if_active(arg1: *mut netstack_t) -> *mut netstack_t;
}
unsafe extern "C" {
    pub fn netstack_rele(arg1: *mut netstack_t);
}
unsafe extern "C" {
    pub fn netstack_find_by_cred(arg1: *const cred_t) -> *mut netstack_t;
}
unsafe extern "C" {
    pub fn netstack_find_by_stackid(arg1: netstackid_t) -> *mut netstack_t;
}
unsafe extern "C" {
    pub fn netstack_find_by_zoneid(arg1: zoneid_t) -> *mut netstack_t;
}
unsafe extern "C" {
    pub fn netstack_inuse_by_stackid(stackid: netstackid_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn netstackid_to_zoneid(arg1: netstackid_t) -> zoneid_t;
}
unsafe extern "C" {
    pub fn netstack_get_zoneid(arg1: *mut netstack_t) -> zoneid_t;
}
unsafe extern "C" {
    pub fn zoneid_to_netstackid(arg1: zoneid_t) -> netstackid_t;
}
unsafe extern "C" {
    pub fn netstack_get_current() -> *mut netstack_t;
}
unsafe extern "C" {
    pub fn netstack_register(
        arg1: illumos_sys_hdrs::c_int,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: netstackid_t,
                arg2: *mut netstack_t,
            ) -> *mut illumos_sys_hdrs::c_void,
        >,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: netstackid_t,
                arg2: *mut illumos_sys_hdrs::c_void,
            ),
        >,
        arg4: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: netstackid_t,
                arg2: *mut illumos_sys_hdrs::c_void,
            ),
        >,
    );
}
unsafe extern "C" {
    pub fn netstack_unregister(arg1: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn kstat_create_netstack(
        arg1: *mut illumos_sys_hdrs::c_char,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: *mut illumos_sys_hdrs::c_char,
        arg5: uchar_t,
        arg6: uint_t,
        arg7: uchar_t,
        arg8: netstackid_t,
    ) -> *mut kstat_t;
}
unsafe extern "C" {
    pub fn kstat_delete_netstack(arg1: *mut kstat_t, arg2: netstackid_t);
}
pub type netstack_handle_t = illumos_sys_hdrs::c_int;
unsafe extern "C" {
    pub fn netstack_next_init(arg1: *mut netstack_handle_t);
}
unsafe extern "C" {
    pub fn netstack_next_fini(arg1: *mut netstack_handle_t);
}
unsafe extern "C" {
    pub fn netstack_next(arg1: *mut netstack_handle_t) -> *mut netstack_t;
}
pub type sa_family_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [illumos_sys_hdrs::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_un {
    pub sun_family: sa_family_t,
    pub sun_path: [illumos_sys_hdrs::c_char; 108usize],
}
unsafe extern "C" {
    pub fn strlen(
        arg1: *const illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_ulong;
}
unsafe extern "C" {
    pub fn unp_discard() -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_dl {
    pub sdl_family: ushort_t,
    pub sdl_index: ushort_t,
    pub sdl_type: uchar_t,
    pub sdl_nlen: uchar_t,
    pub sdl_alen: uchar_t,
    pub sdl_slen: uchar_t,
    pub sdl_data: [illumos_sys_hdrs::c_char; 244usize],
}
unsafe extern "C" {
    pub fn _link_ntoa(
        arg1: *const illumos_sys_hdrs::c_uchar,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: illumos_sys_hdrs::c_int,
        arg4: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn _link_aton(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_uchar;
}
pub type sockaddr_maxalign_t = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub _ss_pad1: [illumos_sys_hdrs::c_char; 6usize],
    pub _ss_align: sockaddr_maxalign_t,
    pub _ss_pad2: [illumos_sys_hdrs::c_char; 240usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_ll {
    pub sll_family: u16,
    pub sll_protocol: u16,
    pub sll_ifindex: i32,
    pub sll_hatype: u16,
    pub sll_pkttype: u8,
    pub sll_halen: u8,
    pub sll_addr: [u8; 8usize],
}
pub type socklen_t = u32;
pub type Psocklen_t = *mut illumos_sys_hdrs::c_void;
pub type in_port_t = u16;
pub type in_addr_t = u32;
unsafe extern "C" {
    pub fn htonl(arg1: u32) -> u32;
}
unsafe extern "C" {
    pub fn htons(arg1: u16) -> u16;
}
unsafe extern "C" {
    pub fn ntohl(arg1: u32) -> u32;
}
unsafe extern "C" {
    pub fn ntohs(arg1: u16) -> u16;
}
unsafe extern "C" {
    pub fn htonll(arg1: u64) -> u64;
}
unsafe extern "C" {
    pub fn ntohll(arg1: u64) -> u64;
}
pub type ipaddr_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub _S6_un: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub _S6_u32: [u32; 4usize],
    pub _S6_u16: [u16; 8usize],
    pub _S6_u8: [u8; 16usize],
    pub __S6_align: u32,
}
pub type in6_addr_t = in6_addr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_addr {
    pub S_un: in_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in_addr__bindgen_ty_1 {
    pub S_un_b: in_addr__bindgen_ty_1__bindgen_ty_1,
    pub S_un_w: in_addr__bindgen_ty_1__bindgen_ty_2,
    pub S_addr: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr__bindgen_ty_1__bindgen_ty_1 {
    pub s_b1: u8,
    pub s_b2: u8,
    pub s_b3: u8,
    pub s_b4: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr__bindgen_ty_1__bindgen_ty_2 {
    pub s_w1: u16,
    pub s_w2: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [illumos_sys_hdrs::c_char; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
    pub __sin6_src_id: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipsec_req {
    pub ipsr_ah_req: uint_t,
    pub ipsr_esp_req: uint_t,
    pub ipsr_self_encap_req: uint_t,
    pub ipsr_auth_alg: u8,
    pub ipsr_esp_alg: u8,
    pub ipsr_esp_auth_alg: u8,
}
pub type ipsec_req_t = ipsec_req;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_sourceaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: illumos_sys_hdrs::c_uint,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
unsafe extern "C" {
    pub fn setsourcefilter(
        arg1: illumos_sys_hdrs::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: u32,
        arg6: uint_t,
        arg7: *mut sockaddr_storage,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn getsourcefilter(
        arg1: illumos_sys_hdrs::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: *mut u32,
        arg6: *mut uint_t,
        arg7: *mut sockaddr_storage,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn setipv4sourcefilter(
        arg1: illumos_sys_hdrs::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: u32,
        arg5: u32,
        arg6: *mut in_addr,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn getipv4sourcefilter(
        arg1: illumos_sys_hdrs::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: *mut u32,
        arg5: *mut u32,
        arg6: *mut in_addr,
    ) -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: illumos_sys_hdrs::c_uint,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
pub type in_pktinfo_t = in_pktinfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: illumos_sys_hdrs::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
unsafe extern "C" {
    pub fn inet6_rth_space(
        type_: illumos_sys_hdrs::c_int,
        segments: illumos_sys_hdrs::c_int,
    ) -> socklen_t;
}
unsafe extern "C" {
    pub fn inet6_rth_init(
        bp: *mut illumos_sys_hdrs::c_void,
        bp_len: socklen_t,
        type_: illumos_sys_hdrs::c_int,
        segments: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn inet6_rth_add(
        bp: *mut illumos_sys_hdrs::c_void,
        addr: *const in6_addr,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn inet6_rth_reverse(
        in_: *const illumos_sys_hdrs::c_void,
        out: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn inet6_rth_segments(
        bp: *const illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn inet6_rth_getaddr(
        bp: *const illumos_sys_hdrs::c_void,
        index: illumos_sys_hdrs::c_int,
    ) -> *mut in6_addr;
}
unsafe extern "C" {
    pub fn inet6_opt_init(
        extbuf: *mut illumos_sys_hdrs::c_void,
        extlen: socklen_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn inet6_opt_append(
        extbuf: *mut illumos_sys_hdrs::c_void,
        extlen: socklen_t,
        offset: illumos_sys_hdrs::c_int,
        type_: u8,
        len: socklen_t,
        align: uint_t,
        databufp: *mut *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn inet6_opt_finish(
        extbuf: *mut illumos_sys_hdrs::c_void,
        extlen: socklen_t,
        offset: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn inet6_opt_set_val(
        databuf: *mut illumos_sys_hdrs::c_void,
        offset: illumos_sys_hdrs::c_int,
        val: *mut illumos_sys_hdrs::c_void,
        vallen: socklen_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn inet6_opt_next(
        extbuf: *mut illumos_sys_hdrs::c_void,
        extlen: socklen_t,
        offset: illumos_sys_hdrs::c_int,
        typep: *mut u8,
        lenp: *mut socklen_t,
        databufp: *mut *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn inet6_opt_find(
        extbufp: *mut illumos_sys_hdrs::c_void,
        extlen: socklen_t,
        offset: illumos_sys_hdrs::c_int,
        type_: u8,
        lenp: *mut socklen_t,
        databufp: *mut *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn inet6_opt_get_val(
        databuf: *mut illumos_sys_hdrs::c_void,
        offset: illumos_sys_hdrs::c_int,
        val: *mut illumos_sys_hdrs::c_void,
        vallen: socklen_t,
    ) -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_prefix_t {
    pub in_prefix_addr: in_addr,
    pub in_prefix_len: illumos_sys_hdrs::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ip_tos: uchar_t,
    pub ip_len: ushort_t,
    pub ip_id: ushort_t,
    pub ip_off: ushort_t,
    pub ip_ttl: uchar_t,
    pub ip_p: uchar_t,
    pub ip_sum: ushort_t,
    pub ip_src: in_addr,
    pub ip_dst: in_addr,
}
impl ip {
    #[inline]
    pub fn ip_hl(&self) -> uchar_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8)
        }
    }
    #[inline]
    pub fn set_ip_hl(&mut self, val: uchar_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ip_hl_raw(this: *const Self) -> uchar_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    4u8,
                ) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ip_hl_raw(this: *mut Self, val: uchar_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ip_v(&self) -> uchar_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8)
        }
    }
    #[inline]
    pub fn set_ip_v(&mut self, val: uchar_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ip_v_raw(this: *const Self) -> uchar_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    4usize,
                    4u8,
                ) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ip_v_raw(this: *mut Self, val: uchar_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ip_hl: uchar_t,
        ip_v: uchar_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ip_hl: u8 = unsafe { ::core::mem::transmute(ip_hl) };
            ip_hl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ip_v: u8 = unsafe { ::core::mem::transmute(ip_v) };
            ip_v as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_timestamp {
    pub ipt_code: uchar_t,
    pub ipt_len: uchar_t,
    pub ipt_ptr: uchar_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ipt_timestamp: ip_timestamp_ipt_timestamp,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip_timestamp_ipt_timestamp {
    pub ipt_time: [u32; 1usize],
    pub ipt_ta: [ip_timestamp_ipt_timestamp_ipt_ta; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_timestamp_ipt_timestamp_ipt_ta {
    pub ipt_addr: in_addr,
    pub ipt_time: u32,
}
impl ip_timestamp {
    #[inline]
    pub fn ipt_flg(&self) -> uchar_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8)
        }
    }
    #[inline]
    pub fn set_ipt_flg(&mut self, val: uchar_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipt_flg_raw(this: *const Self) -> uchar_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    4u8,
                ) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ipt_flg_raw(this: *mut Self, val: uchar_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ipt_oflw(&self) -> uchar_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8)
        }
    }
    #[inline]
    pub fn set_ipt_oflw(&mut self, val: uchar_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipt_oflw_raw(this: *const Self) -> uchar_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    4usize,
                    4u8,
                ) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ipt_oflw_raw(this: *mut Self, val: uchar_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ipt_flg: uchar_t,
        ipt_oflw: uchar_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ipt_flg: u8 = unsafe { ::core::mem::transmute(ipt_flg) };
            ipt_flg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ipt_oflw: u8 = unsafe { ::core::mem::transmute(ipt_oflw) };
            ipt_oflw as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rwstlock {
    pub rwst_count: isize,
    pub rwst_rcv: kcondvar_t,
    pub rwst_wcv: kcondvar_t,
    pub rwst_lock: kmutex_t,
}
pub type rwstlock_t = rwstlock;
unsafe extern "C" {
    pub fn rwst_enter(arg1: *mut rwstlock_t, arg2: krw_t);
}
unsafe extern "C" {
    pub fn rwst_enter_sig(
        arg1: *mut rwstlock_t,
        arg2: krw_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rwst_exit(arg1: *mut rwstlock_t);
}
unsafe extern "C" {
    pub fn rwst_init(
        arg1: *mut rwstlock_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: krw_type_t,
        arg4: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn rwst_destroy(arg1: *mut rwstlock_t);
}
unsafe extern "C" {
    pub fn rwst_lock_held(
        arg1: *mut rwstlock_t,
        arg2: krw_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rwst_tryenter(
        arg1: *mut rwstlock_t,
        arg2: krw_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rwst_owner(arg1: *mut rwstlock_t) -> *mut _kthread;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: caddr_t,
    pub iov_len: usize,
}
pub type iovec_t = iovec;
pub const uio_seg_UIO_USERSPACE: uio_seg = 0;
pub const uio_seg_UIO_SYSSPACE: uio_seg = 1;
pub const uio_seg_UIO_USERISPACE: uio_seg = 2;
pub type uio_seg = illumos_sys_hdrs::c_uint;
pub use self::uio_seg as uio_seg_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uio {
    pub uio_iov: *mut iovec_t,
    pub uio_iovcnt: illumos_sys_hdrs::c_int,
    pub _uio_offset: lloff_t,
    pub uio_segflg: uio_seg_t,
    pub uio_fmode: u16,
    pub uio_extflg: u16,
    pub _uio_limit: lloff_t,
    pub uio_resid: isize,
}
pub type uio_t = uio;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uioa_page_s {
    pub uioa_pfncnt: illumos_sys_hdrs::c_int,
    pub uioa_ppp: *mut *mut illumos_sys_hdrs::c_void,
    pub uioa_base: caddr_t,
    pub uioa_len: usize,
}
pub type uioa_page_t = uioa_page_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uioa_s {
    pub uio_iov: *mut iovec_t,
    pub uio_iovcnt: illumos_sys_hdrs::c_int,
    pub _uio_offset: lloff_t,
    pub uio_segflg: uio_seg_t,
    pub uio_fmode: u16,
    pub uio_extflg: u16,
    pub _uio_limit: lloff_t,
    pub uio_resid: isize,
    pub uioa_state: u32,
    pub uioa_mbytes: isize,
    pub uioa_lcur: *mut uioa_page_t,
    pub uioa_lppp: *mut *mut illumos_sys_hdrs::c_void,
    pub uioa_hwst: [*mut illumos_sys_hdrs::c_void; 4usize],
    pub uioa_locked: [uioa_page_t; 16usize],
}
pub type uioa_t = uioa_s;
pub const xuio_type_UIOTYPE_ASYNCIO: xuio_type = 0;
pub const xuio_type_UIOTYPE_ZEROCOPY: xuio_type = 1;
pub type xuio_type = illumos_sys_hdrs::c_uint;
pub use self::xuio_type as xuio_type_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xuio {
    pub xu_uio: uio_t,
    pub xu_type: xuio_type,
    pub xu_ext: xuio__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xuio__bindgen_ty_1 {
    pub xu_aio: xuio__bindgen_ty_1__bindgen_ty_1,
    pub xu_zc: xuio__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xuio__bindgen_ty_1__bindgen_ty_1 {
    pub xu_a_state: u32,
    pub xu_a_mbytes: isize,
    pub xu_a_lcur: *mut uioa_page_t,
    pub xu_a_lppp: *mut *mut illumos_sys_hdrs::c_void,
    pub xu_a_hwst: [*mut illumos_sys_hdrs::c_void; 4usize],
    pub xu_a_locked: [uioa_page_t; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xuio__bindgen_ty_1__bindgen_ty_2 {
    pub xu_zc_rw: illumos_sys_hdrs::c_int,
    pub xu_zc_priv: *mut illumos_sys_hdrs::c_void,
}
pub type xuio_t = xuio;
pub const uio_rw_UIO_READ: uio_rw = 0;
pub const uio_rw_UIO_WRITE: uio_rw = 1;
pub type uio_rw = illumos_sys_hdrs::c_uint;
pub use self::uio_rw as uio_rw_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uioasync_s {
    pub enabled: boolean_t,
    pub mincnt: usize,
}
pub type uioasync_t = uioasync_s;
unsafe extern "C" {
    pub fn uiomove(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: usize,
        arg3: uio_rw,
        arg4: *mut uio_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn uio_prefaultpages(arg1: isize, arg2: *mut uio_t);
}
unsafe extern "C" {
    pub fn uiocopy(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: usize,
        arg3: uio_rw,
        arg4: *mut uio_t,
        arg5: *mut usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ureadc(
        arg1: illumos_sys_hdrs::c_int,
        arg2: *mut uio_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn uwritec(arg1: *mut uio) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn uioskip(arg1: *mut uio_t, arg2: usize);
}
unsafe extern "C" {
    pub fn uiodup(
        arg1: *mut uio_t,
        arg2: *mut uio_t,
        arg3: *mut iovec_t,
        arg4: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn uioamove(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: usize,
        arg3: uio_rw,
        arg4: *mut uioa_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn uioainit(
        arg1: *mut uio_t,
        arg2: *mut uioa_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn uioafini(
        arg1: *mut uio_t,
        arg2: *mut uioa_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut uioasync: uioasync_t;
}
pub type rlim_t = illumos_sys_hdrs::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
pub type rlim64_t = u_longlong_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit64 {
    pub rlim_cur: rlim64_t,
    pub rlim_max: rlim64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: illumos_sys_hdrs::c_long,
    pub ru_ixrss: illumos_sys_hdrs::c_long,
    pub ru_idrss: illumos_sys_hdrs::c_long,
    pub ru_isrss: illumos_sys_hdrs::c_long,
    pub ru_minflt: illumos_sys_hdrs::c_long,
    pub ru_majflt: illumos_sys_hdrs::c_long,
    pub ru_nswap: illumos_sys_hdrs::c_long,
    pub ru_inblock: illumos_sys_hdrs::c_long,
    pub ru_oublock: illumos_sys_hdrs::c_long,
    pub ru_msgsnd: illumos_sys_hdrs::c_long,
    pub ru_msgrcv: illumos_sys_hdrs::c_long,
    pub ru_nsignals: illumos_sys_hdrs::c_long,
    pub ru_nvcsw: illumos_sys_hdrs::c_long,
    pub ru_nivcsw: illumos_sys_hdrs::c_long,
}
unsafe extern "C" {
    pub fn assfail(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
        arg3: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn assfail3(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: uintmax_t,
        arg3: *const illumos_sys_hdrs::c_char,
        arg4: uintmax_t,
        arg5: *const illumos_sys_hdrs::c_char,
        arg6: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn abort_sequence_enter(arg1: *mut illumos_sys_hdrs::c_char);
}
unsafe extern "C" {
    pub fn debug_enter(arg1: *mut illumos_sys_hdrs::c_char);
}
pub type model_t = illumos_sys_hdrs::c_uint;
unsafe extern "C" {
    pub fn lwp_getdatamodel(arg1: *mut _klwp) -> model_t;
}
unsafe extern "C" {
    pub fn get_udatamodel() -> model_t;
}
pub const fault_type_F_INVAL: fault_type = 0;
pub const fault_type_F_PROT: fault_type = 1;
pub const fault_type_F_SOFTLOCK: fault_type = 2;
pub const fault_type_F_SOFTUNLOCK: fault_type = 3;
pub type fault_type = illumos_sys_hdrs::c_uint;
pub const lock_type_L_PAGELOCK: lock_type = 0;
pub const lock_type_L_PAGEUNLOCK: lock_type = 1;
pub type lock_type = illumos_sys_hdrs::c_uint;
pub const seg_rw_S_OTHER: seg_rw = 0;
pub const seg_rw_S_READ: seg_rw = 1;
pub const seg_rw_S_WRITE: seg_rw = 2;
pub const seg_rw_S_EXEC: seg_rw = 3;
pub const seg_rw_S_CREATE: seg_rw = 4;
pub const seg_rw_S_READ_NOCOW: seg_rw = 5;
pub type seg_rw = illumos_sys_hdrs::c_uint;
pub const segcapability_t_S_CAPABILITY_NOMINFLT: segcapability_t = 0;
pub type segcapability_t = illumos_sys_hdrs::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmem {
    _unused: [u8; 0],
}
pub type vmem_t = vmem;
pub type vmem_alloc_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut vmem_t,
        arg2: usize,
        arg3: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_void,
>;
pub type vmem_free_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut vmem_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    ),
>;
pub type vmem_ximport_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut vmem_t,
        arg2: *mut usize,
        arg3: usize,
        arg4: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_void,
>;
unsafe extern "C" {
    pub fn vmem_init(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
        arg4: usize,
        arg5: vmem_alloc_t,
        arg6: vmem_free_t,
    ) -> *mut vmem_t;
}
unsafe extern "C" {
    pub fn vmem_update(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn vmem_is_populator() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut vmem_seg_size: usize;
}
unsafe extern "C" {
    pub fn vmem_create(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
        arg4: usize,
        arg5: vmem_alloc_t,
        arg6: vmem_free_t,
        arg7: *mut vmem_t,
        arg8: usize,
        arg9: illumos_sys_hdrs::c_int,
    ) -> *mut vmem_t;
}
unsafe extern "C" {
    pub fn vmem_xcreate(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
        arg4: usize,
        arg5: vmem_ximport_t,
        arg6: vmem_free_t,
        arg7: *mut vmem_t,
        arg8: usize,
        arg9: illumos_sys_hdrs::c_int,
    ) -> *mut vmem_t;
}
unsafe extern "C" {
    pub fn vmem_destroy(arg1: *mut vmem_t);
}
unsafe extern "C" {
    pub fn vmem_alloc(
        arg1: *mut vmem_t,
        arg2: usize,
        arg3: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn vmem_xalloc(
        arg1: *mut vmem_t,
        arg2: usize,
        arg3: usize,
        arg4: usize,
        arg5: usize,
        arg6: *mut illumos_sys_hdrs::c_void,
        arg7: *mut illumos_sys_hdrs::c_void,
        arg8: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn vmem_free(
        arg1: *mut vmem_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    );
}
unsafe extern "C" {
    pub fn vmem_xfree(
        arg1: *mut vmem_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    );
}
unsafe extern "C" {
    pub fn vmem_add(
        arg1: *mut vmem_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
        arg4: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn vmem_contains(
        arg1: *mut vmem_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vmem_walk(
        arg1: *mut vmem_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut illumos_sys_hdrs::c_void,
                arg2: *mut illumos_sys_hdrs::c_void,
                arg3: usize,
            ),
        >,
        arg4: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn vmem_size(arg1: *mut vmem_t, arg2: illumos_sys_hdrs::c_int)
        -> usize;
}
unsafe extern "C" {
    pub fn vmem_qcache_reap(vmp: *mut vmem_t);
}
unsafe extern "C" {
    pub fn kmem_alloc(
        size: usize,
        kmflags: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn kmem_zalloc(
        size: usize,
        kmflags: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn kmem_free(buf: *mut illumos_sys_hdrs::c_void, size: usize);
}
unsafe extern "C" {
    pub fn kmem_alloc_tryhard(
        size: usize,
        alloc_size: *mut usize,
        kmflags: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn kmem_dump_init(arg1: usize);
}
unsafe extern "C" {
    pub fn kmem_dump_begin();
}
unsafe extern "C" {
    pub fn kmem_dump_finish(
        buf: *mut illumos_sys_hdrs::c_char,
        size: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn kmem_rezalloc(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: usize,
        arg3: usize,
        arg4: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_void;
}
pub type kmem_cache_t = kmem_cache;
pub const kmem_cbrc_KMEM_CBRC_YES: kmem_cbrc = 0;
pub const kmem_cbrc_KMEM_CBRC_NO: kmem_cbrc = 1;
pub const kmem_cbrc_KMEM_CBRC_LATER: kmem_cbrc = 2;
pub const kmem_cbrc_KMEM_CBRC_DONT_NEED: kmem_cbrc = 3;
pub const kmem_cbrc_KMEM_CBRC_DONT_KNOW: kmem_cbrc = 4;
pub type kmem_cbrc = illumos_sys_hdrs::c_uint;
pub use self::kmem_cbrc as kmem_cbrc_t;
unsafe extern "C" {
    pub static mut kmem_ready: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut kmem_reapahead: pgcnt_t;
}
unsafe extern "C" {
    pub static mut kmem_max_cached: usize;
}
unsafe extern "C" {
    pub fn kmem_init();
}
unsafe extern "C" {
    pub fn kmem_thread_init();
}
unsafe extern "C" {
    pub fn kmem_mp_init();
}
unsafe extern "C" {
    pub fn kmem_reap();
}
unsafe extern "C" {
    pub fn kmem_reap_idspace();
}
unsafe extern "C" {
    pub fn kmem_debugging() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kmem_avail() -> usize;
}
unsafe extern "C" {
    pub fn kmem_maxavail() -> usize;
}
unsafe extern "C" {
    pub fn kmem_cache_create(
        arg1: *mut illumos_sys_hdrs::c_char,
        arg2: usize,
        arg3: usize,
        arg4: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut illumos_sys_hdrs::c_void,
                arg2: *mut illumos_sys_hdrs::c_void,
                arg3: illumos_sys_hdrs::c_int,
            ) -> illumos_sys_hdrs::c_int,
        >,
        arg5: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut illumos_sys_hdrs::c_void,
                arg2: *mut illumos_sys_hdrs::c_void,
            ),
        >,
        arg6: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
        >,
        arg7: *mut illumos_sys_hdrs::c_void,
        arg8: *mut vmem_t,
        arg9: illumos_sys_hdrs::c_int,
    ) -> *mut kmem_cache_t;
}
unsafe extern "C" {
    pub fn kmem_cache_set_move(
        arg1: *mut kmem_cache_t,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut illumos_sys_hdrs::c_void,
                arg2: *mut illumos_sys_hdrs::c_void,
                arg3: usize,
                arg4: *mut illumos_sys_hdrs::c_void,
            ) -> kmem_cbrc_t,
        >,
    );
}
unsafe extern "C" {
    pub fn kmem_cache_destroy(arg1: *mut kmem_cache_t);
}
unsafe extern "C" {
    pub fn kmem_cache_alloc(
        arg1: *mut kmem_cache_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn kmem_cache_free(
        arg1: *mut kmem_cache_t,
        arg2: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn kmem_cache_stat(
        arg1: *mut kmem_cache_t,
        arg2: *mut illumos_sys_hdrs::c_char,
    ) -> u64;
}
unsafe extern "C" {
    pub fn kmem_cache_reap_active() -> boolean_t;
}
unsafe extern "C" {
    pub fn kmem_cache_reap_soon(arg1: *mut kmem_cache_t);
}
unsafe extern "C" {
    pub fn kmem_cache_move_notify(
        arg1: *mut kmem_cache_t,
        arg2: *mut illumos_sys_hdrs::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_node {
    pub list_next: *mut list_node,
    pub list_prev: *mut list_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list {
    pub list_size: usize,
    pub list_offset: usize,
    pub list_head: list_node,
}
pub type list_node_t = list_node;
pub type list_t = list;
unsafe extern "C" {
    pub fn list_create(arg1: *mut list_t, arg2: usize, arg3: usize);
}
unsafe extern "C" {
    pub fn list_destroy(arg1: *mut list_t);
}
unsafe extern "C" {
    pub fn list_insert_after(
        arg1: *mut list_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn list_insert_before(
        arg1: *mut list_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn list_insert_head(
        arg1: *mut list_t,
        arg2: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn list_insert_tail(
        arg1: *mut list_t,
        arg2: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn list_remove(arg1: *mut list_t, arg2: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn list_remove_head(arg1: *mut list_t)
        -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn list_remove_tail(arg1: *mut list_t)
        -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn list_move_tail(arg1: *mut list_t, arg2: *mut list_t);
}
unsafe extern "C" {
    pub fn list_head(arg1: *mut list_t) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn list_tail(arg1: *mut list_t) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn list_next(
        arg1: *mut list_t,
        arg2: *mut illumos_sys_hdrs::c_void,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn list_prev(
        arg1: *mut list_t,
        arg2: *mut illumos_sys_hdrs::c_void,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn list_is_empty(arg1: *mut list_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn list_link_init(arg1: *mut list_node_t);
}
unsafe extern "C" {
    pub fn list_link_replace(arg1: *mut list_node_t, arg2: *mut list_node_t);
}
unsafe extern "C" {
    pub fn list_link_active(arg1: *mut list_node_t) -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct buf {
    pub b_flags: illumos_sys_hdrs::c_int,
    pub b_forw: *mut buf,
    pub b_back: *mut buf,
    pub av_forw: *mut buf,
    pub av_back: *mut buf,
    pub b_dev: o_dev_t,
    pub b_bcount: usize,
    pub b_un: buf__bindgen_ty_1,
    pub _b_blkno: lldaddr_t,
    pub b_obs1: illumos_sys_hdrs::c_char,
    pub b_resid: usize,
    pub b_start: clock_t,
    pub b_proc: *mut proc_,
    pub b_pages: *mut page,
    pub b_obs2: clock_t,
    pub b_bufsize: usize,
    pub b_iodone: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut buf) -> illumos_sys_hdrs::c_int,
    >,
    pub b_vp: *mut vnode,
    pub b_chain: *mut buf,
    pub b_obs3: illumos_sys_hdrs::c_int,
    pub b_error: illumos_sys_hdrs::c_int,
    pub b_private: *mut illumos_sys_hdrs::c_void,
    pub b_edev: dev_t,
    pub b_sem: ksema_t,
    pub b_io: ksema_t,
    pub b_list: *mut buf,
    pub b_shadow: *mut *mut page,
    pub b_dip: *mut illumos_sys_hdrs::c_void,
    pub b_file: *mut vnode,
    pub b_offset: offset_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union buf__bindgen_ty_1 {
    pub b_addr: caddr_t,
    pub b_fs: *mut fs,
    pub b_cg: *mut cg,
    pub b_dino: *mut dinode,
    pub b_daddr: *mut daddr32_t,
}
pub type buf_t = buf;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct diskhd {
    pub b_flags: illumos_sys_hdrs::c_int,
    pub b_forw: *mut buf,
    pub b_back: *mut buf,
    pub av_forw: *mut buf,
    pub av_back: *mut buf,
    pub b_dev: o_dev_t,
    pub b_bcount: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct biostats {
    pub bio_lookup: kstat_named_t,
    pub bio_hit: kstat_named_t,
    pub bio_bufwant: kstat_named_t,
    pub bio_bufwait: kstat_named_t,
    pub bio_bufbusy: kstat_named_t,
    pub bio_bufdup: kstat_named_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hbuf {
    pub b_flags: illumos_sys_hdrs::c_int,
    pub b_forw: *mut buf,
    pub b_back: *mut buf,
    pub av_forw: *mut buf,
    pub av_back: *mut buf,
    pub b_length: illumos_sys_hdrs::c_int,
    pub b_lock: kmutex_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dwbuf {
    pub b_flags: illumos_sys_hdrs::c_int,
    pub b_forw: *mut buf,
    pub b_back: *mut buf,
    pub av_forw: *mut buf,
    pub av_back: *mut buf,
}
unsafe extern "C" {
    pub static mut hbuf: *mut hbuf;
}
unsafe extern "C" {
    pub static mut dwbuf: *mut dwbuf;
}
unsafe extern "C" {
    pub static mut buf: *mut buf;
}
unsafe extern "C" {
    pub static mut bfreelist: buf;
}
unsafe extern "C" {
    pub static mut bio_lufs_strategy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut illumos_sys_hdrs::c_void,
            arg2: *mut buf_t,
        ),
    >;
}
unsafe extern "C" {
    pub static mut bio_snapshot_strategy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut illumos_sys_hdrs::c_void,
            arg2: *mut buf_t,
        ),
    >;
}
unsafe extern "C" {
    pub fn bcheck(arg1: dev_t, arg2: *mut buf) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn iowait(arg1: *mut buf) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn hash2ints(
        x: illumos_sys_hdrs::c_int,
        y: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn bio_busy(arg1: illumos_sys_hdrs::c_int) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn biowait(arg1: *mut buf) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn biomodified(arg1: *mut buf) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn geterror(arg1: *mut buf) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn minphys(arg1: *mut buf);
}
unsafe extern "C" {
    pub fn bwrite_common(
        ufsvfsp: *mut illumos_sys_hdrs::c_void,
        arg1: *mut buf,
        force_wait: illumos_sys_hdrs::c_int,
        do_relse: illumos_sys_hdrs::c_int,
        clear_flags: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn bwrite(arg1: *mut buf);
}
unsafe extern "C" {
    pub fn bwrite2(arg1: *mut buf);
}
unsafe extern "C" {
    pub fn bdwrite(arg1: *mut buf);
}
unsafe extern "C" {
    pub fn bawrite(arg1: *mut buf);
}
unsafe extern "C" {
    pub fn brelse(arg1: *mut buf);
}
unsafe extern "C" {
    pub fn iodone(arg1: *mut buf);
}
unsafe extern "C" {
    pub fn clrbuf(arg1: *mut buf);
}
unsafe extern "C" {
    pub fn bflush(arg1: dev_t);
}
unsafe extern "C" {
    pub fn blkflush(arg1: dev_t, arg2: daddr_t);
}
unsafe extern "C" {
    pub fn binval(arg1: dev_t);
}
unsafe extern "C" {
    pub fn bfinval(
        arg1: dev_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn binit();
}
unsafe extern "C" {
    pub fn biodone(arg1: *mut buf);
}
unsafe extern "C" {
    pub fn bioinit(arg1: *mut buf);
}
unsafe extern "C" {
    pub fn biofini(arg1: *mut buf);
}
unsafe extern "C" {
    pub fn bp_mapin(arg1: *mut buf);
}
unsafe extern "C" {
    pub fn bp_mapin_common(
        arg1: *mut buf,
        arg2: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn bp_mapout(arg1: *mut buf);
}
unsafe extern "C" {
    pub fn bp_copyin(
        arg1: *mut buf,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: offset_t,
        arg4: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn bp_copyout(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: *mut buf,
        arg3: offset_t,
        arg4: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn bp_init(arg1: usize, arg2: uint_t);
}
unsafe extern "C" {
    pub fn bp_color(arg1: *mut buf) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn pageio_done(arg1: *mut buf);
}
unsafe extern "C" {
    pub fn bread(
        arg1: dev_t,
        arg2: daddr_t,
        arg3: illumos_sys_hdrs::c_long,
    ) -> *mut buf;
}
unsafe extern "C" {
    pub fn bread_common(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: dev_t,
        arg3: daddr_t,
        arg4: illumos_sys_hdrs::c_long,
    ) -> *mut buf;
}
unsafe extern "C" {
    pub fn breada(
        arg1: dev_t,
        arg2: daddr_t,
        arg3: daddr_t,
        arg4: illumos_sys_hdrs::c_long,
    ) -> *mut buf;
}
unsafe extern "C" {
    pub fn getblk(
        arg1: dev_t,
        arg2: daddr_t,
        arg3: illumos_sys_hdrs::c_long,
    ) -> *mut buf;
}
unsafe extern "C" {
    pub fn getblk_common(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: dev_t,
        arg3: daddr_t,
        arg4: illumos_sys_hdrs::c_long,
        arg5: illumos_sys_hdrs::c_int,
    ) -> *mut buf;
}
unsafe extern "C" {
    pub fn ngeteblk(arg1: illumos_sys_hdrs::c_long) -> *mut buf;
}
unsafe extern "C" {
    pub fn geteblk() -> *mut buf;
}
unsafe extern "C" {
    pub fn pageio_setup(
        arg1: *mut page,
        arg2: usize,
        arg3: *mut vnode,
        arg4: illumos_sys_hdrs::c_int,
    ) -> *mut buf;
}
unsafe extern "C" {
    pub fn bioerror(bp: *mut buf, error: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn bioreset(bp: *mut buf);
}
unsafe extern "C" {
    pub fn bioclone(
        arg1: *mut buf,
        arg2: off_t,
        arg3: usize,
        arg4: dev_t,
        arg5: daddr_t,
        arg6: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut buf) -> illumos_sys_hdrs::c_int,
        >,
        arg7: *mut buf,
        arg8: illumos_sys_hdrs::c_int,
    ) -> *mut buf;
}
unsafe extern "C" {
    pub fn biosize() -> usize;
}
unsafe extern "C" {
    pub fn __dtrace_probe_set__error(arg1: usize);
}
unsafe extern "C" {
    pub static mut sdt_prefix: *const illumos_sys_hdrs::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdt_probedesc {
    pub sdpd_name: *mut illumos_sys_hdrs::c_char,
    pub sdpd_offset: illumos_sys_hdrs::c_ulong,
    pub sdpd_next: *mut sdt_probedesc,
}
pub type sdt_probedesc_t = sdt_probedesc;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vopstats {
    pub nopen: kstat_named_t,
    pub nclose: kstat_named_t,
    pub nread: kstat_named_t,
    pub read_bytes: kstat_named_t,
    pub nwrite: kstat_named_t,
    pub write_bytes: kstat_named_t,
    pub nioctl: kstat_named_t,
    pub nsetfl: kstat_named_t,
    pub ngetattr: kstat_named_t,
    pub nsetattr: kstat_named_t,
    pub naccess: kstat_named_t,
    pub nlookup: kstat_named_t,
    pub ncreate: kstat_named_t,
    pub nremove: kstat_named_t,
    pub nlink: kstat_named_t,
    pub nrename: kstat_named_t,
    pub nmkdir: kstat_named_t,
    pub nrmdir: kstat_named_t,
    pub nreaddir: kstat_named_t,
    pub readdir_bytes: kstat_named_t,
    pub nsymlink: kstat_named_t,
    pub nreadlink: kstat_named_t,
    pub nfsync: kstat_named_t,
    pub ninactive: kstat_named_t,
    pub nfid: kstat_named_t,
    pub nrwlock: kstat_named_t,
    pub nrwunlock: kstat_named_t,
    pub nseek: kstat_named_t,
    pub ncmp: kstat_named_t,
    pub nfrlock: kstat_named_t,
    pub nspace: kstat_named_t,
    pub nrealvp: kstat_named_t,
    pub ngetpage: kstat_named_t,
    pub nputpage: kstat_named_t,
    pub nmap: kstat_named_t,
    pub naddmap: kstat_named_t,
    pub ndelmap: kstat_named_t,
    pub npoll: kstat_named_t,
    pub ndump: kstat_named_t,
    pub npathconf: kstat_named_t,
    pub npageio: kstat_named_t,
    pub ndumpctl: kstat_named_t,
    pub ndispose: kstat_named_t,
    pub nsetsecattr: kstat_named_t,
    pub ngetsecattr: kstat_named_t,
    pub nshrlock: kstat_named_t,
    pub nvnevent: kstat_named_t,
    pub nreqzcbuf: kstat_named_t,
    pub nretzcbuf: kstat_named_t,
}
pub type vopstats_t = vopstats;
pub const vtype_VNON: vtype = 0;
pub const vtype_VREG: vtype = 1;
pub const vtype_VDIR: vtype = 2;
pub const vtype_VBLK: vtype = 3;
pub const vtype_VCHR: vtype = 4;
pub const vtype_VLNK: vtype = 5;
pub const vtype_VFIFO: vtype = 6;
pub const vtype_VDOOR: vtype = 7;
pub const vtype_VPROC: vtype = 8;
pub const vtype_VSOCK: vtype = 9;
pub const vtype_VPORT: vtype = 10;
pub const vtype_VBAD: vtype = 11;
pub type vtype = illumos_sys_hdrs::c_uint;
pub use self::vtype as vtype_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsd_node {
    pub vs_nodes: list_node_t,
    pub vs_nkeys: uint_t,
    pub vs_value: *mut *mut illumos_sys_hdrs::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fem_head {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnode {
    pub v_lock: kmutex_t,
    pub v_flag: uint_t,
    pub v_count: uint_t,
    pub v_data: *mut illumos_sys_hdrs::c_void,
    pub v_vfsp: *mut vfs,
    pub v_stream: *mut stdata,
    pub v_type: vtype,
    pub v_rdev: dev_t,
    pub v_vfsmountedhere: *mut vfs,
    pub v_op: *mut vnodeops,
    pub v_pages: *mut page,
    pub v_filocks: *mut filock,
    pub v_shrlocks: *mut shrlocklist,
    pub v_nbllock: krwlock_t,
    pub v_cv: kcondvar_t,
    pub v_locality: *mut illumos_sys_hdrs::c_void,
    pub v_femhead: *mut fem_head,
    pub v_path: *mut illumos_sys_hdrs::c_char,
    pub v_path_stamp: hrtime_t,
    pub v_rdcnt: uint_t,
    pub v_wrcnt: uint_t,
    pub v_mmap_read: u_longlong_t,
    pub v_mmap_write: u_longlong_t,
    pub v_mpssdata: *mut illumos_sys_hdrs::c_void,
    pub v_fopdata: *mut illumos_sys_hdrs::c_void,
    pub v_vsd_lock: kmutex_t,
    pub v_vsd: *mut vsd_node,
    pub v_xattrdir: *mut vnode,
    pub v_count_dnlc: uint_t,
}
pub type vnode_t = vnode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vn_vfslocks_entry {
    pub ve_lock: rwstlock_t,
    pub ve_vpvfs: *mut illumos_sys_hdrs::c_void,
    pub ve_next: *mut vn_vfslocks_entry,
    pub ve_refcnt: u32,
    pub pad: [illumos_sys_hdrs::c_char; 20usize],
}
pub type vn_vfslocks_entry_t = vn_vfslocks_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vattr {
    pub va_mask: uint_t,
    pub va_type: vtype_t,
    pub va_mode: mode_t,
    pub va_uid: uid_t,
    pub va_gid: gid_t,
    pub va_fsid: dev_t,
    pub va_nodeid: u_longlong_t,
    pub va_nlink: nlink_t,
    pub va_size: u_offset_t,
    pub va_atime: timestruc_t,
    pub va_mtime: timestruc_t,
    pub va_ctime: timestruc_t,
    pub va_rdev: dev_t,
    pub va_blksize: uint_t,
    pub va_nblocks: u_longlong_t,
    pub va_seq: uint_t,
}
pub type vattr_t = vattr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xoptattr {
    pub xoa_createtime: timestruc_t,
    pub xoa_archive: u8,
    pub xoa_system: u8,
    pub xoa_readonly: u8,
    pub xoa_hidden: u8,
    pub xoa_nounlink: u8,
    pub xoa_immutable: u8,
    pub xoa_appendonly: u8,
    pub xoa_nodump: u8,
    pub xoa_opaque: u8,
    pub xoa_av_quarantined: u8,
    pub xoa_av_modified: u8,
    pub xoa_av_scanstamp: [u8; 32usize],
    pub xoa_reparse: u8,
    pub xoa_generation: u64,
    pub xoa_offline: u8,
    pub xoa_sparse: u8,
    pub xoa_projinherit: u8,
    pub xoa_projid: u64,
}
pub type xoptattr_t = xoptattr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xvattr {
    pub xva_vattr: vattr_t,
    pub xva_magic: u32,
    pub xva_mapsize: u32,
    pub xva_rtnattrmapp: *mut u32,
    pub xva_reqattrmap: [u32; 3usize],
    pub xva_rtnattrmap: [u32; 3usize],
    pub xva_xoptattrs: xoptattr_t,
}
pub type xvattr_t = xvattr;
pub type vattr32_t = vattr_t;
pub const rm_RMFILE: rm = 0;
pub const rm_RMDIRECTORY: rm = 1;
pub type rm = illumos_sys_hdrs::c_uint;
pub const symfollow_NO_FOLLOW: symfollow = 0;
pub const symfollow_FOLLOW: symfollow = 1;
pub type symfollow = illumos_sys_hdrs::c_uint;
pub const vcexcl_NONEXCL: vcexcl = 0;
pub const vcexcl_EXCL: vcexcl = 1;
pub type vcexcl = illumos_sys_hdrs::c_uint;
pub const create_CRCREAT: create = 0;
pub const create_CRMKNOD: create = 1;
pub const create_CRMKDIR: create = 2;
pub type create = illumos_sys_hdrs::c_uint;
pub use self::create as create_t;
pub use self::rm as rm_t;
pub use self::symfollow as symfollow_t;
pub use self::vcexcl as vcexcl_t;
pub const vnevent_VE_SUPPORT: vnevent = 0;
pub const vnevent_VE_RENAME_SRC: vnevent = 1;
pub const vnevent_VE_RENAME_DEST: vnevent = 2;
pub const vnevent_VE_REMOVE: vnevent = 3;
pub const vnevent_VE_RMDIR: vnevent = 4;
pub const vnevent_VE_CREATE: vnevent = 5;
pub const vnevent_VE_LINK: vnevent = 6;
pub const vnevent_VE_RENAME_DEST_DIR: vnevent = 7;
pub const vnevent_VE_MOUNTEDOVER: vnevent = 8;
pub const vnevent_VE_TRUNCATE: vnevent = 9;
pub const vnevent_VE_PRE_RENAME_SRC: vnevent = 10;
pub const vnevent_VE_PRE_RENAME_DEST: vnevent = 11;
pub const vnevent_VE_PRE_RENAME_DEST_DIR: vnevent = 12;
pub type vnevent = illumos_sys_hdrs::c_uint;
pub use self::vnevent as vnevent_t;
pub const v_mode_V_READ: v_mode = 0;
pub const v_mode_V_WRITE: v_mode = 1;
pub const v_mode_V_RDORWR: v_mode = 2;
pub const v_mode_V_RDANDWR: v_mode = 3;
pub type v_mode = illumos_sys_hdrs::c_uint;
pub use self::v_mode as v_mode_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsecattr {
    pub vsa_mask: uint_t,
    pub vsa_aclcnt: illumos_sys_hdrs::c_int,
    pub vsa_aclentp: *mut illumos_sys_hdrs::c_void,
    pub vsa_dfaclcnt: illumos_sys_hdrs::c_int,
    pub vsa_dfaclentp: *mut illumos_sys_hdrs::c_void,
    pub vsa_aclentsz: usize,
    pub vsa_aclflags: uint_t,
}
pub type vsecattr_t = vsecattr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct caller_context {
    pub cc_pid: pid_t,
    pub cc_sysid: illumos_sys_hdrs::c_int,
    pub cc_caller_id: u_longlong_t,
    pub cc_flags: ulong_t,
}
pub type caller_context_t = caller_context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pathname {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fid {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock64 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flk_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shrlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seg {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct as_ {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct taskq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnodeops {
    pub vnop_name: *const illumos_sys_hdrs::c_char,
    pub vop_open: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut vnode_t,
            arg2: illumos_sys_hdrs::c_int,
            arg3: *mut cred_t,
            arg4: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: illumos_sys_hdrs::c_int,
            arg3: illumos_sys_hdrs::c_int,
            arg4: offset_t,
            arg5: *mut cred_t,
            arg6: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut uio_t,
            arg3: illumos_sys_hdrs::c_int,
            arg4: *mut cred_t,
            arg5: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut uio_t,
            arg3: illumos_sys_hdrs::c_int,
            arg4: *mut cred_t,
            arg5: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: illumos_sys_hdrs::c_int,
            arg3: isize,
            arg4: illumos_sys_hdrs::c_int,
            arg5: *mut cred_t,
            arg6: *mut illumos_sys_hdrs::c_int,
            arg7: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_setfl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: illumos_sys_hdrs::c_int,
            arg3: illumos_sys_hdrs::c_int,
            arg4: *mut cred_t,
            arg5: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_getattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut vattr_t,
            arg3: illumos_sys_hdrs::c_int,
            arg4: *mut cred_t,
            arg5: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_setattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut vattr_t,
            arg3: illumos_sys_hdrs::c_int,
            arg4: *mut cred_t,
            arg5: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_access: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: illumos_sys_hdrs::c_int,
            arg3: illumos_sys_hdrs::c_int,
            arg4: *mut cred_t,
            arg5: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_lookup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut illumos_sys_hdrs::c_char,
            arg3: *mut *mut vnode_t,
            arg4: *mut pathname,
            arg5: illumos_sys_hdrs::c_int,
            arg6: *mut vnode_t,
            arg7: *mut cred_t,
            arg8: *mut caller_context_t,
            arg9: *mut illumos_sys_hdrs::c_int,
            arg10: *mut pathname,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut illumos_sys_hdrs::c_char,
            arg3: *mut vattr_t,
            arg4: vcexcl_t,
            arg5: illumos_sys_hdrs::c_int,
            arg6: *mut *mut vnode_t,
            arg7: *mut cred_t,
            arg8: illumos_sys_hdrs::c_int,
            arg9: *mut caller_context_t,
            arg10: *mut vsecattr_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_remove: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut illumos_sys_hdrs::c_char,
            arg3: *mut cred_t,
            arg4: *mut caller_context_t,
            arg5: illumos_sys_hdrs::c_int,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut vnode_t,
            arg3: *mut illumos_sys_hdrs::c_char,
            arg4: *mut cred_t,
            arg5: *mut caller_context_t,
            arg6: illumos_sys_hdrs::c_int,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_rename: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut illumos_sys_hdrs::c_char,
            arg3: *mut vnode_t,
            arg4: *mut illumos_sys_hdrs::c_char,
            arg5: *mut cred_t,
            arg6: *mut caller_context_t,
            arg7: illumos_sys_hdrs::c_int,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut illumos_sys_hdrs::c_char,
            arg3: *mut vattr_t,
            arg4: *mut *mut vnode_t,
            arg5: *mut cred_t,
            arg6: *mut caller_context_t,
            arg7: illumos_sys_hdrs::c_int,
            arg8: *mut vsecattr_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_rmdir: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut illumos_sys_hdrs::c_char,
            arg3: *mut vnode_t,
            arg4: *mut cred_t,
            arg5: *mut caller_context_t,
            arg6: illumos_sys_hdrs::c_int,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_readdir: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut uio_t,
            arg3: *mut cred_t,
            arg4: *mut illumos_sys_hdrs::c_int,
            arg5: *mut caller_context_t,
            arg6: illumos_sys_hdrs::c_int,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_symlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut illumos_sys_hdrs::c_char,
            arg3: *mut vattr_t,
            arg4: *mut illumos_sys_hdrs::c_char,
            arg5: *mut cred_t,
            arg6: *mut caller_context_t,
            arg7: illumos_sys_hdrs::c_int,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_readlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut uio_t,
            arg3: *mut cred_t,
            arg4: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_fsync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: illumos_sys_hdrs::c_int,
            arg3: *mut cred_t,
            arg4: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_inactive: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut cred_t,
            arg3: *mut caller_context_t,
        ),
    >,
    pub vop_fid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut fid,
            arg3: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_rwlock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: illumos_sys_hdrs::c_int,
            arg3: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_rwunlock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: illumos_sys_hdrs::c_int,
            arg3: *mut caller_context_t,
        ),
    >,
    pub vop_seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: offset_t,
            arg3: *mut offset_t,
            arg4: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_cmp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut vnode_t,
            arg3: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_frlock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: illumos_sys_hdrs::c_int,
            arg3: *mut flock64,
            arg4: illumos_sys_hdrs::c_int,
            arg5: offset_t,
            arg6: *mut flk_callback,
            arg7: *mut cred_t,
            arg8: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_space: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: illumos_sys_hdrs::c_int,
            arg3: *mut flock64,
            arg4: illumos_sys_hdrs::c_int,
            arg5: offset_t,
            arg6: *mut cred_t,
            arg7: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_realvp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut *mut vnode_t,
            arg3: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_getpage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: offset_t,
            arg3: usize,
            arg4: *mut uint_t,
            arg5: *mut *mut page,
            arg6: usize,
            arg7: *mut seg,
            arg8: caddr_t,
            arg9: seg_rw,
            arg10: *mut cred_t,
            arg11: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_putpage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: offset_t,
            arg3: usize,
            arg4: illumos_sys_hdrs::c_int,
            arg5: *mut cred_t,
            arg6: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_map: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: offset_t,
            arg3: *mut as_,
            arg4: *mut caddr_t,
            arg5: usize,
            arg6: uchar_t,
            arg7: uchar_t,
            arg8: uint_t,
            arg9: *mut cred_t,
            arg10: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_addmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: offset_t,
            arg3: *mut as_,
            arg4: caddr_t,
            arg5: usize,
            arg6: uchar_t,
            arg7: uchar_t,
            arg8: uint_t,
            arg9: *mut cred_t,
            arg10: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_delmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: offset_t,
            arg3: *mut as_,
            arg4: caddr_t,
            arg5: usize,
            arg6: uint_t,
            arg7: uint_t,
            arg8: uint_t,
            arg9: *mut cred_t,
            arg10: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_poll: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: illumos_sys_hdrs::c_short,
            arg3: illumos_sys_hdrs::c_int,
            arg4: *mut illumos_sys_hdrs::c_short,
            arg5: *mut *mut pollhead,
            arg6: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: caddr_t,
            arg3: offset_t,
            arg4: offset_t,
            arg5: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_pathconf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: illumos_sys_hdrs::c_int,
            arg3: *mut ulong_t,
            arg4: *mut cred_t,
            arg5: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_pageio: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut page,
            arg3: u_offset_t,
            arg4: usize,
            arg5: illumos_sys_hdrs::c_int,
            arg6: *mut cred_t,
            arg7: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_dumpctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: illumos_sys_hdrs::c_int,
            arg3: *mut offset_t,
            arg4: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_dispose: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut page,
            arg3: illumos_sys_hdrs::c_int,
            arg4: illumos_sys_hdrs::c_int,
            arg5: *mut cred_t,
            arg6: *mut caller_context_t,
        ),
    >,
    pub vop_setsecattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut vsecattr_t,
            arg3: illumos_sys_hdrs::c_int,
            arg4: *mut cred_t,
            arg5: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_getsecattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut vsecattr_t,
            arg3: illumos_sys_hdrs::c_int,
            arg4: *mut cred_t,
            arg5: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_shrlock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: illumos_sys_hdrs::c_int,
            arg3: *mut shrlock,
            arg4: illumos_sys_hdrs::c_int,
            arg5: *mut cred_t,
            arg6: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_vnevent: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: vnevent_t,
            arg3: *mut vnode_t,
            arg4: *mut illumos_sys_hdrs::c_char,
            arg5: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_reqzcbuf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: uio_rw,
            arg3: *mut xuio_t,
            arg4: *mut cred_t,
            arg5: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub vop_retzcbuf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vnode_t,
            arg2: *mut xuio_t,
            arg3: *mut cred_t,
            arg4: *mut caller_context_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
}
pub type vnodeops_t = vnodeops;
pub type fs_generic_func_p =
    ::core::option::Option<unsafe extern "C" fn() -> illumos_sys_hdrs::c_int>;
unsafe extern "C" {
    pub fn fop_open(
        arg1: *mut *mut vnode_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut cred_t,
        arg4: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_close(
        arg1: *mut vnode_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: illumos_sys_hdrs::c_int,
        arg4: offset_t,
        arg5: *mut cred_t,
        arg6: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_read(
        arg1: *mut vnode_t,
        arg2: *mut uio_t,
        arg3: illumos_sys_hdrs::c_int,
        arg4: *mut cred_t,
        arg5: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_write(
        arg1: *mut vnode_t,
        arg2: *mut uio_t,
        arg3: illumos_sys_hdrs::c_int,
        arg4: *mut cred_t,
        arg5: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_ioctl(
        arg1: *mut vnode_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: isize,
        arg4: illumos_sys_hdrs::c_int,
        arg5: *mut cred_t,
        arg6: *mut illumos_sys_hdrs::c_int,
        arg7: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_setfl(
        arg1: *mut vnode_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: illumos_sys_hdrs::c_int,
        arg4: *mut cred_t,
        arg5: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_getattr(
        arg1: *mut vnode_t,
        arg2: *mut vattr_t,
        arg3: illumos_sys_hdrs::c_int,
        arg4: *mut cred_t,
        arg5: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_setattr(
        arg1: *mut vnode_t,
        arg2: *mut vattr_t,
        arg3: illumos_sys_hdrs::c_int,
        arg4: *mut cred_t,
        arg5: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_access(
        arg1: *mut vnode_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: illumos_sys_hdrs::c_int,
        arg4: *mut cred_t,
        arg5: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_lookup(
        arg1: *mut vnode_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: *mut *mut vnode_t,
        arg4: *mut pathname,
        arg5: illumos_sys_hdrs::c_int,
        arg6: *mut vnode_t,
        arg7: *mut cred_t,
        arg8: *mut caller_context_t,
        arg9: *mut illumos_sys_hdrs::c_int,
        arg10: *mut pathname,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_create(
        arg1: *mut vnode_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: *mut vattr_t,
        arg4: vcexcl_t,
        arg5: illumos_sys_hdrs::c_int,
        arg6: *mut *mut vnode_t,
        arg7: *mut cred_t,
        arg8: illumos_sys_hdrs::c_int,
        arg9: *mut caller_context_t,
        arg10: *mut vsecattr_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_remove(
        vp: *mut vnode_t,
        arg1: *mut illumos_sys_hdrs::c_char,
        arg2: *mut cred_t,
        arg3: *mut caller_context_t,
        arg4: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_link(
        arg1: *mut vnode_t,
        arg2: *mut vnode_t,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: *mut cred_t,
        arg5: *mut caller_context_t,
        arg6: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_rename(
        arg1: *mut vnode_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: *mut vnode_t,
        arg4: *mut illumos_sys_hdrs::c_char,
        arg5: *mut cred_t,
        arg6: *mut caller_context_t,
        arg7: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_mkdir(
        arg1: *mut vnode_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: *mut vattr_t,
        arg4: *mut *mut vnode_t,
        arg5: *mut cred_t,
        arg6: *mut caller_context_t,
        arg7: illumos_sys_hdrs::c_int,
        arg8: *mut vsecattr_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_rmdir(
        arg1: *mut vnode_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: *mut vnode_t,
        arg4: *mut cred_t,
        arg5: *mut caller_context_t,
        arg6: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_readdir(
        arg1: *mut vnode_t,
        arg2: *mut uio_t,
        arg3: *mut cred_t,
        arg4: *mut illumos_sys_hdrs::c_int,
        arg5: *mut caller_context_t,
        arg6: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_symlink(
        arg1: *mut vnode_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: *mut vattr_t,
        arg4: *mut illumos_sys_hdrs::c_char,
        arg5: *mut cred_t,
        arg6: *mut caller_context_t,
        arg7: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_readlink(
        arg1: *mut vnode_t,
        arg2: *mut uio_t,
        arg3: *mut cred_t,
        arg4: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_fsync(
        arg1: *mut vnode_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut cred_t,
        arg4: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_inactive(
        arg1: *mut vnode_t,
        arg2: *mut cred_t,
        arg3: *mut caller_context_t,
    );
}
unsafe extern "C" {
    pub fn fop_fid(
        arg1: *mut vnode_t,
        arg2: *mut fid,
        arg3: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_rwlock(
        arg1: *mut vnode_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_rwunlock(
        arg1: *mut vnode_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut caller_context_t,
    );
}
unsafe extern "C" {
    pub fn fop_seek(
        arg1: *mut vnode_t,
        arg2: offset_t,
        arg3: *mut offset_t,
        arg4: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_cmp(
        arg1: *mut vnode_t,
        arg2: *mut vnode_t,
        arg3: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_frlock(
        arg1: *mut vnode_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut flock64,
        arg4: illumos_sys_hdrs::c_int,
        arg5: offset_t,
        arg6: *mut flk_callback,
        arg7: *mut cred_t,
        arg8: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_space(
        arg1: *mut vnode_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut flock64,
        arg4: illumos_sys_hdrs::c_int,
        arg5: offset_t,
        arg6: *mut cred_t,
        arg7: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_realvp(
        arg1: *mut vnode_t,
        arg2: *mut *mut vnode_t,
        arg3: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_getpage(
        arg1: *mut vnode_t,
        arg2: offset_t,
        arg3: usize,
        arg4: *mut uint_t,
        arg5: *mut *mut page,
        arg6: usize,
        arg7: *mut seg,
        arg8: caddr_t,
        arg9: seg_rw,
        arg10: *mut cred_t,
        arg11: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_putpage(
        arg1: *mut vnode_t,
        arg2: offset_t,
        arg3: usize,
        arg4: illumos_sys_hdrs::c_int,
        arg5: *mut cred_t,
        arg6: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_map(
        arg1: *mut vnode_t,
        arg2: offset_t,
        arg3: *mut as_,
        arg4: *mut caddr_t,
        arg5: usize,
        arg6: uchar_t,
        arg7: uchar_t,
        arg8: uint_t,
        cr: *mut cred_t,
        arg9: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_addmap(
        arg1: *mut vnode_t,
        arg2: offset_t,
        arg3: *mut as_,
        arg4: caddr_t,
        arg5: usize,
        arg6: uchar_t,
        arg7: uchar_t,
        arg8: uint_t,
        arg9: *mut cred_t,
        arg10: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_delmap(
        arg1: *mut vnode_t,
        arg2: offset_t,
        arg3: *mut as_,
        arg4: caddr_t,
        arg5: usize,
        arg6: uint_t,
        arg7: uint_t,
        arg8: uint_t,
        arg9: *mut cred_t,
        arg10: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_poll(
        arg1: *mut vnode_t,
        arg2: illumos_sys_hdrs::c_short,
        arg3: illumos_sys_hdrs::c_int,
        arg4: *mut illumos_sys_hdrs::c_short,
        arg5: *mut *mut pollhead,
        arg6: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_dump(
        arg1: *mut vnode_t,
        arg2: caddr_t,
        arg3: offset_t,
        arg4: offset_t,
        arg5: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_pathconf(
        arg1: *mut vnode_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut ulong_t,
        arg4: *mut cred_t,
        arg5: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_pageio(
        arg1: *mut vnode_t,
        arg2: *mut page,
        arg3: u_offset_t,
        arg4: usize,
        arg5: illumos_sys_hdrs::c_int,
        arg6: *mut cred_t,
        arg7: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_dumpctl(
        arg1: *mut vnode_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut offset_t,
        arg4: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_dispose(
        arg1: *mut vnode_t,
        arg2: *mut page,
        arg3: illumos_sys_hdrs::c_int,
        arg4: illumos_sys_hdrs::c_int,
        arg5: *mut cred_t,
        arg6: *mut caller_context_t,
    );
}
unsafe extern "C" {
    pub fn fop_setsecattr(
        arg1: *mut vnode_t,
        arg2: *mut vsecattr_t,
        arg3: illumos_sys_hdrs::c_int,
        arg4: *mut cred_t,
        arg5: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_getsecattr(
        arg1: *mut vnode_t,
        arg2: *mut vsecattr_t,
        arg3: illumos_sys_hdrs::c_int,
        arg4: *mut cred_t,
        arg5: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_shrlock(
        arg1: *mut vnode_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut shrlock,
        arg4: illumos_sys_hdrs::c_int,
        arg5: *mut cred_t,
        arg6: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_vnevent(
        arg1: *mut vnode_t,
        arg2: vnevent_t,
        arg3: *mut vnode_t,
        arg4: *mut illumos_sys_hdrs::c_char,
        arg5: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_reqzcbuf(
        arg1: *mut vnode_t,
        arg2: uio_rw,
        arg3: *mut xuio_t,
        arg4: *mut cred_t,
        arg5: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fop_retzcbuf(
        arg1: *mut vnode_t,
        arg2: *mut xuio_t,
        arg3: *mut cred_t,
        arg4: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_alloc(arg1: illumos_sys_hdrs::c_int) -> *mut vnode_t;
}
unsafe extern "C" {
    pub fn vn_reinit(arg1: *mut vnode_t);
}
unsafe extern "C" {
    pub fn vn_recycle(arg1: *mut vnode_t);
}
unsafe extern "C" {
    pub fn vn_free(arg1: *mut vnode_t);
}
unsafe extern "C" {
    pub fn vn_is_readonly(arg1: *mut vnode_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_is_opened(
        arg1: *mut vnode_t,
        arg2: v_mode_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_is_mapped(
        arg1: *mut vnode_t,
        arg2: v_mode_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_has_other_opens(
        arg1: *mut vnode_t,
        arg2: v_mode_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_open_upgrade(arg1: *mut vnode_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn vn_open_downgrade(arg1: *mut vnode_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn vn_can_change_zones(vp: *mut vnode_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_has_flocks(arg1: *mut vnode_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_has_mandatory_locks(
        arg1: *mut vnode_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_has_cached_data(arg1: *mut vnode_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_setops(arg1: *mut vnode_t, arg2: *mut vnodeops_t);
}
unsafe extern "C" {
    pub fn vn_getops(arg1: *mut vnode_t) -> *mut vnodeops_t;
}
unsafe extern "C" {
    pub fn vn_matchops(
        arg1: *mut vnode_t,
        arg2: *mut vnodeops_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_matchopval(
        arg1: *mut vnode_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: fs_generic_func_p,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_ismntpt(arg1: *mut vnode_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_mountedvfs(arg1: *mut vnode_t) -> *mut vfs;
}
unsafe extern "C" {
    pub fn vn_in_dnlc(arg1: *mut vnode_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_create_cache();
}
unsafe extern "C" {
    pub fn vn_destroy_cache();
}
unsafe extern "C" {
    pub fn vn_freevnodeops(arg1: *mut vnodeops_t);
}
unsafe extern "C" {
    pub fn vn_open(
        pnamep: *mut illumos_sys_hdrs::c_char,
        seg: uio_seg,
        filemode: illumos_sys_hdrs::c_int,
        createmode: illumos_sys_hdrs::c_int,
        vpp: *mut *mut vnode,
        crwhy: create,
        umask: mode_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_openat(
        pnamep: *mut illumos_sys_hdrs::c_char,
        seg: uio_seg,
        filemode: illumos_sys_hdrs::c_int,
        createmode: illumos_sys_hdrs::c_int,
        vpp: *mut *mut vnode,
        crwhy: create,
        umask: mode_t,
        startvp: *mut vnode,
        fd: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_create(
        pnamep: *mut illumos_sys_hdrs::c_char,
        seg: uio_seg,
        vap: *mut vattr,
        excl: vcexcl,
        mode: illumos_sys_hdrs::c_int,
        vpp: *mut *mut vnode,
        why: create,
        flag: illumos_sys_hdrs::c_int,
        umask: mode_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_createat(
        pnamep: *mut illumos_sys_hdrs::c_char,
        seg: uio_seg,
        vap: *mut vattr,
        excl: vcexcl,
        mode: illumos_sys_hdrs::c_int,
        vpp: *mut *mut vnode,
        why: create,
        flag: illumos_sys_hdrs::c_int,
        umask: mode_t,
        startvp: *mut vnode,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_rdwr(
        rw: uio_rw,
        vp: *mut vnode,
        base: caddr_t,
        len: isize,
        offset: offset_t,
        seg: uio_seg,
        ioflag: illumos_sys_hdrs::c_int,
        ulimit: rlim64_t,
        cr: *mut cred_t,
        residp: *mut isize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_rele(vp: *mut vnode);
}
unsafe extern "C" {
    pub fn vn_rele_async(vp: *mut vnode, taskq: *mut taskq);
}
unsafe extern "C" {
    pub fn vn_rele_dnlc(vp: *mut vnode);
}
unsafe extern "C" {
    pub fn vn_rele_stream(vp: *mut vnode);
}
unsafe extern "C" {
    pub fn vn_link(
        from: *mut illumos_sys_hdrs::c_char,
        to: *mut illumos_sys_hdrs::c_char,
        seg: uio_seg,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_linkat(
        fstartvp: *mut vnode_t,
        from: *mut illumos_sys_hdrs::c_char,
        follow: symfollow,
        tstartvp: *mut vnode_t,
        to: *mut illumos_sys_hdrs::c_char,
        seg: uio_seg,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_rename(
        from: *mut illumos_sys_hdrs::c_char,
        to: *mut illumos_sys_hdrs::c_char,
        seg: uio_seg,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_renameat(
        fdvp: *mut vnode_t,
        fname: *mut illumos_sys_hdrs::c_char,
        tdvp: *mut vnode_t,
        tname: *mut illumos_sys_hdrs::c_char,
        seg: uio_seg,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_remove(
        fnamep: *mut illumos_sys_hdrs::c_char,
        seg: uio_seg,
        dirflag: rm,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_removeat(
        startvp: *mut vnode_t,
        fnamep: *mut illumos_sys_hdrs::c_char,
        seg: uio_seg,
        dirflag: rm,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_compare(
        vp1: *mut vnode_t,
        vp2: *mut vnode_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_vfswlock(vp: *mut vnode) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_vfswlock_wait(vp: *mut vnode) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_vfsrlock(vp: *mut vnode) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_vfsrlock_wait(vp: *mut vnode) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vn_vfsunlock(vp: *mut vnode);
}
unsafe extern "C" {
    pub fn vn_vfswlock_held(vp: *mut vnode) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn specvp(
        vp: *mut vnode,
        dev: dev_t,
        type_: vtype_t,
        cr: *mut cred,
    ) -> *mut vnode_t;
}
unsafe extern "C" {
    pub fn makespecvp(dev: dev_t, type_: vtype_t) -> *mut vnode_t;
}
unsafe extern "C" {
    pub fn vn_vfslocks_getlock(
        arg1: *mut illumos_sys_hdrs::c_void,
    ) -> *mut vn_vfslocks_entry_t;
}
unsafe extern "C" {
    pub fn vn_vfslocks_rele(arg1: *mut vn_vfslocks_entry_t);
}
unsafe extern "C" {
    pub fn vn_is_reparse(
        arg1: *mut vnode_t,
        arg2: *mut cred_t,
        arg3: *mut caller_context_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn vn_copypath(src: *mut vnode, dst: *mut vnode);
}
unsafe extern "C" {
    pub fn vn_setpath_str(
        vp: *mut vnode,
        str_: *const illumos_sys_hdrs::c_char,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn vn_setpath(
        rootvp: *mut vnode_t,
        startvp: *mut vnode,
        vp: *mut vnode,
        path: *const illumos_sys_hdrs::c_char,
        plen: usize,
    );
}
unsafe extern "C" {
    pub fn vn_renamepath(
        dvp: *mut vnode_t,
        vp: *mut vnode_t,
        nm: *const illumos_sys_hdrs::c_char,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn vn_clearpath(arg1: *mut vnode_t, arg2: hrtime_t);
}
unsafe extern "C" {
    pub fn vn_updatepath(
        arg1: *mut vnode_t,
        arg2: *mut vnode_t,
        arg3: *const illumos_sys_hdrs::c_char,
    );
}
unsafe extern "C" {
    pub fn vnevent_rename_src(
        arg1: *mut vnode_t,
        arg2: *mut vnode_t,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: *mut caller_context_t,
    );
}
unsafe extern "C" {
    pub fn vnevent_rename_dest(
        arg1: *mut vnode_t,
        arg2: *mut vnode_t,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: *mut caller_context_t,
    );
}
unsafe extern "C" {
    pub fn vnevent_remove(
        arg1: *mut vnode_t,
        arg2: *mut vnode_t,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: *mut caller_context_t,
    );
}
unsafe extern "C" {
    pub fn vnevent_rmdir(
        arg1: *mut vnode_t,
        arg2: *mut vnode_t,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: *mut caller_context_t,
    );
}
unsafe extern "C" {
    pub fn vnevent_create(arg1: *mut vnode_t, arg2: *mut caller_context_t);
}
unsafe extern "C" {
    pub fn vnevent_link(arg1: *mut vnode_t, arg2: *mut caller_context_t);
}
unsafe extern "C" {
    pub fn vnevent_rename_dest_dir(
        arg1: *mut vnode_t,
        ct: *mut caller_context_t,
    );
}
unsafe extern "C" {
    pub fn vnevent_mountedover(arg1: *mut vnode_t, arg2: *mut caller_context_t);
}
unsafe extern "C" {
    pub fn vnevent_truncate(arg1: *mut vnode_t, arg2: *mut caller_context_t);
}
unsafe extern "C" {
    pub fn vnevent_support(
        arg1: *mut vnode_t,
        arg2: *mut caller_context_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vnevent_pre_rename_src(
        arg1: *mut vnode_t,
        arg2: *mut vnode_t,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: *mut caller_context_t,
    );
}
unsafe extern "C" {
    pub fn vnevent_pre_rename_dest(
        arg1: *mut vnode_t,
        arg2: *mut vnode_t,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: *mut caller_context_t,
    );
}
unsafe extern "C" {
    pub fn vnevent_pre_rename_dest_dir(
        arg1: *mut vnode_t,
        arg2: *mut vnode_t,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: *mut caller_context_t,
    );
}
unsafe extern "C" {
    pub fn vsd_create(
        arg1: *mut uint_t,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
        >,
    );
}
unsafe extern "C" {
    pub fn vsd_destroy(arg1: *mut uint_t);
}
unsafe extern "C" {
    pub fn vsd_get(
        arg1: *mut vnode_t,
        arg2: uint_t,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn vsd_set(
        arg1: *mut vnode_t,
        arg2: uint_t,
        arg3: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vsd_free(arg1: *mut vnode_t);
}
unsafe extern "C" {
    pub fn xva_init(arg1: *mut xvattr_t);
}
unsafe extern "C" {
    pub fn xva_getxoptattr(arg1: *mut xvattr_t) -> *mut xoptattr_t;
}
unsafe extern "C" {
    pub fn xattr_init();
}
unsafe extern "C" {
    pub fn xattr_dir_lookup(
        arg1: *mut vnode_t,
        arg2: *mut *mut vnode_t,
        arg3: illumos_sys_hdrs::c_int,
        arg4: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn reparse_point_init();
}
unsafe extern "C" {
    pub fn fs_new_caller_id() -> u_longlong_t;
}
unsafe extern "C" {
    pub fn vn_vmpss_usepageio(arg1: *mut vnode_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut vn_vpath_empty: *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub static mut pvn_vmodsort_supported: uint_t;
}
unsafe extern "C" {
    pub static mut kvps: [vnode; 0usize];
}
pub const kvps_index_t_KV_KVP: kvps_index_t = 0;
pub const kvps_index_t_KV_ZVP: kvps_index_t = 1;
pub const kvps_index_t_KV_VVP: kvps_index_t = 2;
pub const kvps_index_t_KV_MAX: kvps_index_t = 3;
pub type kvps_index_t = illumos_sys_hdrs::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct async_reqs {
    pub a_next: *mut async_reqs,
    pub a_vp: *mut vnode,
    pub a_off: u_offset_t,
    pub a_len: uint_t,
    pub a_flags: illumos_sys_hdrs::c_int,
    pub a_cred: *mut cred,
    pub a_prealloced: ushort_t,
}
pub type _Classification = i16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Classification_t {
    pub class_u: Classification_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Classification_t__bindgen_ty_1 {
    pub class_ar: [u8; 2usize],
    pub class_chunk: _Classification,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Compartments_t {
    pub c1: u32,
    pub c2: u32,
    pub c3: u32,
    pub c4: u32,
    pub c5: u32,
    pub c6: u32,
    pub c7: u32,
    pub c8: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Markings_t {
    pub m1: u32,
    pub m2: u32,
    pub m3: u32,
    pub m4: u32,
    pub m5: u32,
    pub m6: u32,
    pub m7: u32,
    pub m8: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mac_label_impl {
    pub id: u8,
    pub _c_len: u8,
    pub classification: Classification_t,
    pub compartments: Compartments_t,
}
pub type _mac_label_impl_t = _mac_label_impl;
pub type _blevel_impl_t = _mac_label_impl_t;
pub type _bslabel_impl_t = _mac_label_impl_t;
pub type _bclear_impl_t = _mac_label_impl_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _binary_information_label_impl {
    pub binformation_level: _mac_label_impl_t,
    pub markings: Markings_t,
}
pub type _bilabel_impl_t = _binary_information_label_impl;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _binary_cmw_label_impl {
    pub bcl_sensitivity_label: _bslabel_impl_t,
    pub bcl_information_label: _bilabel_impl_t,
}
pub type _bclabel_impl_t = _binary_cmw_label_impl;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _binary_level_range_impl {
    pub lower_bound: _mac_label_impl_t,
    pub upper_bound: _mac_label_impl_t,
}
pub type _brange_impl_t = _binary_level_range_impl;
pub type brange_t = _binary_level_range_impl;
pub type blset_t = [_mac_label_impl_t; 4usize];
pub type m_label_t = _mac_label_impl;
pub type blevel_t = m_label_t;
pub type bslabel_t = m_label_t;
pub type bclear_t = m_label_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tsol_binary_level_lrange {
    pub lower_bound: *mut m_label_t,
    pub upper_bound: *mut m_label_t,
}
pub type m_range_t = _tsol_binary_level_lrange;
pub type blrange_t = m_range_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tsol_mlp_s {
    pub mlp_ipp: uchar_t,
    pub mlp_port: u16,
    pub mlp_port_upper: u16,
}
pub type tsol_mlp_t = tsol_mlp_s;
unsafe extern "C" {
    pub fn bltype(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: u8,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn blequal(
        arg1: *const m_label_t,
        arg2: *const m_label_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn bldominates(
        arg1: *const m_label_t,
        arg2: *const m_label_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn blstrictdom(
        arg1: *const m_label_t,
        arg2: *const m_label_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn blinrange(
        arg1: *const m_label_t,
        arg2: *const m_range_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn blmaximum(arg1: *mut m_label_t, arg2: *const m_label_t);
}
unsafe extern "C" {
    pub fn blminimum(arg1: *mut m_label_t, arg2: *const m_label_t);
}
unsafe extern "C" {
    pub fn bsllow(arg1: *mut m_label_t);
}
unsafe extern "C" {
    pub fn bslhigh(arg1: *mut m_label_t);
}
unsafe extern "C" {
    pub fn bclearlow(arg1: *mut m_label_t);
}
unsafe extern "C" {
    pub fn bclearhigh(arg1: *mut m_label_t);
}
unsafe extern "C" {
    pub fn bslundef(arg1: *mut m_label_t);
}
unsafe extern "C" {
    pub fn bclearundef(arg1: *mut m_label_t);
}
unsafe extern "C" {
    pub fn setbltype(arg1: *mut illumos_sys_hdrs::c_void, arg2: u8);
}
unsafe extern "C" {
    pub fn bisinvalid(arg1: *const illumos_sys_hdrs::c_void) -> boolean_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tsol_mlp_entry_s {
    pub mlpe_next: *mut tsol_mlp_entry_s,
    pub mlpe_prev: *mut tsol_mlp_entry_s,
    pub mlpe_zoneid: zoneid_t,
    pub mlpe_mlp: tsol_mlp_t,
}
pub type tsol_mlp_entry_t = tsol_mlp_entry_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tsol_mlp_list_s {
    pub mlpl_rwlock: krwlock_t,
    pub mlpl_first: *mut tsol_mlp_entry_t,
    pub mlpl_last: *mut tsol_mlp_entry_t,
}
pub type tsol_mlp_list_t = tsol_mlp_list_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ts_label_s {
    pub tsl_ref: uint_t,
    pub tsl_doi: u32,
    pub tsl_flags: u32,
    pub tsl_label: m_label_t,
}
pub type ts_label_t = ts_label_s;
unsafe extern "C" {
    pub static mut l_admin_low: *mut ts_label_t;
}
unsafe extern "C" {
    pub static mut l_admin_high: *mut ts_label_t;
}
unsafe extern "C" {
    pub static mut default_doi: u32;
}
unsafe extern "C" {
    pub static mut sys_labeling: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn label_init();
}
unsafe extern "C" {
    pub fn labelalloc(
        arg1: *const m_label_t,
        arg2: u32,
        arg3: illumos_sys_hdrs::c_int,
    ) -> *mut ts_label_t;
}
unsafe extern "C" {
    pub fn labeldup(
        arg1: *const ts_label_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> *mut ts_label_t;
}
unsafe extern "C" {
    pub fn label_hold(arg1: *mut ts_label_t);
}
unsafe extern "C" {
    pub fn label_rele(arg1: *mut ts_label_t);
}
unsafe extern "C" {
    pub fn label2bslabel(arg1: *mut ts_label_t) -> *mut m_label_t;
}
unsafe extern "C" {
    pub fn label2doi(arg1: *mut ts_label_t) -> u32;
}
unsafe extern "C" {
    pub fn label_equal(
        arg1: *const ts_label_t,
        arg2: *const ts_label_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn newcred_from_bslabel(
        arg1: *mut m_label_t,
        arg2: u32,
        arg3: illumos_sys_hdrs::c_int,
    ) -> *mut cred_t;
}
unsafe extern "C" {
    pub fn copycred_from_bslabel(
        arg1: *const cred_t,
        arg2: *mut m_label_t,
        arg3: u32,
        arg4: illumos_sys_hdrs::c_int,
    ) -> *mut cred_t;
}
unsafe extern "C" {
    pub fn copycred_from_tslabel(
        arg1: *const cred_t,
        arg2: *mut ts_label_t,
        arg3: illumos_sys_hdrs::c_int,
    ) -> *mut cred_t;
}
unsafe extern "C" {
    pub fn getflabel(arg1: *mut vnode_t) -> *mut ts_label_t;
}
unsafe extern "C" {
    pub fn getlabel(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut m_label_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fgetlabel(
        arg1: illumos_sys_hdrs::c_int,
        arg2: *mut m_label_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn _blinrange(
        arg1: *const m_label_t,
        arg2: *const brange_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn blinlset(
        arg1: *const m_label_t,
        arg2: *const _mac_label_impl_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn l_to_str_internal(
        arg1: *const m_label_t,
        arg2: *mut *mut illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn hexstr_to_label(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut m_label_t,
    ) -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Octet_s {
    pub o_length: illumos_sys_hdrs::c_int,
    pub o_bytes: [illumos_sys_hdrs::c_char; 32usize],
}
pub type Octet_t = Octet_s;
pub type Counter = u32;
pub type Counter32 = u32;
pub type Counter64 = u64;
pub type Gauge = u32;
pub type IpAddress = u32;
pub type Ip6Address = in6_addr;
pub type DeviceName = Octet_t;
pub type PhysAddress = Octet_t;
pub type DeviceIndex = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mib2_ip {
    pub ipForwarding: illumos_sys_hdrs::c_int,
    pub ipDefaultTTL: illumos_sys_hdrs::c_int,
    pub ipInReceives: Counter,
    pub ipInHdrErrors: Counter,
    pub ipInAddrErrors: Counter,
    pub ipForwDatagrams: Counter,
    pub ipInUnknownProtos: Counter,
    pub ipInDiscards: Counter,
    pub ipInDelivers: Counter,
    pub ipOutRequests: Counter,
    pub ipOutDiscards: Counter,
    pub ipOutNoRoutes: Counter,
    pub ipReasmTimeout: illumos_sys_hdrs::c_int,
    pub ipReasmReqds: Counter,
    pub ipReasmOKs: Counter,
    pub ipReasmFails: Counter,
    pub ipFragOKs: Counter,
    pub ipFragFails: Counter,
    pub ipFragCreates: Counter,
    pub ipAddrEntrySize: illumos_sys_hdrs::c_int,
    pub ipRouteEntrySize: illumos_sys_hdrs::c_int,
    pub ipNetToMediaEntrySize: illumos_sys_hdrs::c_int,
    pub ipRoutingDiscards: Counter,
    pub tcpInErrs: Counter,
    pub udpNoPorts: Counter,
    pub ipInCksumErrs: Counter,
    pub ipReasmDuplicates: Counter,
    pub ipReasmPartDups: Counter,
    pub ipForwProhibits: Counter,
    pub udpInCksumErrs: Counter,
    pub udpInOverflows: Counter,
    pub rawipInOverflows: Counter,
    pub ipsecInSucceeded: Counter,
    pub ipsecInFailed: Counter,
    pub ipMemberEntrySize: illumos_sys_hdrs::c_int,
    pub ipGroupSourceEntrySize: illumos_sys_hdrs::c_int,
    pub ipInIPv6: Counter,
    pub ipOutIPv6: Counter,
    pub ipOutSwitchIPv6: Counter,
    pub ipRouteAttributeSize: illumos_sys_hdrs::c_int,
    pub transportMLPSize: illumos_sys_hdrs::c_int,
    pub ipDestEntrySize: illumos_sys_hdrs::c_int,
}
pub type mib2_ip_t = mib2_ip;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mib2_ipv6IfStatsEntry {
    pub ipv6IfIndex: DeviceIndex,
    pub ipv6Forwarding: illumos_sys_hdrs::c_int,
    pub ipv6DefaultHopLimit: illumos_sys_hdrs::c_int,
    pub ipv6IfStatsEntrySize: illumos_sys_hdrs::c_int,
    pub ipv6AddrEntrySize: illumos_sys_hdrs::c_int,
    pub ipv6RouteEntrySize: illumos_sys_hdrs::c_int,
    pub ipv6NetToMediaEntrySize: illumos_sys_hdrs::c_int,
    pub ipv6MemberEntrySize: illumos_sys_hdrs::c_int,
    pub ipv6GroupSourceEntrySize: illumos_sys_hdrs::c_int,
    pub ipv6InReceives: Counter,
    pub ipv6InHdrErrors: Counter,
    pub ipv6InTooBigErrors: Counter,
    pub ipv6InNoRoutes: Counter,
    pub ipv6InAddrErrors: Counter,
    pub ipv6InUnknownProtos: Counter,
    pub ipv6InTruncatedPkts: Counter,
    pub ipv6InDiscards: Counter,
    pub ipv6InDelivers: Counter,
    pub ipv6OutForwDatagrams: Counter,
    pub ipv6OutRequests: Counter,
    pub ipv6OutDiscards: Counter,
    pub ipv6OutFragOKs: Counter,
    pub ipv6OutFragFails: Counter,
    pub ipv6OutFragCreates: Counter,
    pub ipv6ReasmReqds: Counter,
    pub ipv6ReasmOKs: Counter,
    pub ipv6ReasmFails: Counter,
    pub ipv6InMcastPkts: Counter,
    pub ipv6OutMcastPkts: Counter,
    pub ipv6OutNoRoutes: Counter,
    pub ipv6ReasmDuplicates: Counter,
    pub ipv6ReasmPartDups: Counter,
    pub ipv6ForwProhibits: Counter,
    pub udpInCksumErrs: Counter,
    pub udpInOverflows: Counter,
    pub rawipInOverflows: Counter,
    pub ipv6InIPv4: Counter,
    pub ipv6OutIPv4: Counter,
    pub ipv6OutSwitchIPv4: Counter,
}
pub type mib2_ipv6IfStatsEntry_t = mib2_ipv6IfStatsEntry;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mib2_ipIfStatsEntry {
    pub ipIfStatsIfIndex: DeviceIndex,
    pub ipIfStatsForwarding: illumos_sys_hdrs::c_int,
    pub ipIfStatsDefaultHopLimit: illumos_sys_hdrs::c_int,
    pub ipIfStatsEntrySize: illumos_sys_hdrs::c_int,
    pub ipIfStatsAddrEntrySize: illumos_sys_hdrs::c_int,
    pub ipIfStatsRouteEntrySize: illumos_sys_hdrs::c_int,
    pub ipIfStatsNetToMediaEntrySize: illumos_sys_hdrs::c_int,
    pub ipIfStatsMemberEntrySize: illumos_sys_hdrs::c_int,
    pub ipIfStatsGroupSourceEntrySize: illumos_sys_hdrs::c_int,
    pub ipIfStatsInReceives: Counter,
    pub ipIfStatsInHdrErrors: Counter,
    pub ipIfStatsInTooBigErrors: Counter,
    pub ipIfStatsInNoRoutes: Counter,
    pub ipIfStatsInAddrErrors: Counter,
    pub ipIfStatsInUnknownProtos: Counter,
    pub ipIfStatsInTruncatedPkts: Counter,
    pub ipIfStatsInDiscards: Counter,
    pub ipIfStatsInDelivers: Counter,
    pub ipIfStatsOutForwDatagrams: Counter,
    pub ipIfStatsOutRequests: Counter,
    pub ipIfStatsOutDiscards: Counter,
    pub ipIfStatsOutFragOKs: Counter,
    pub ipIfStatsOutFragFails: Counter,
    pub ipIfStatsOutFragCreates: Counter,
    pub ipIfStatsReasmReqds: Counter,
    pub ipIfStatsReasmOKs: Counter,
    pub ipIfStatsReasmFails: Counter,
    pub ipIfStatsInMcastPkts: Counter,
    pub ipIfStatsOutMcastPkts: Counter,
    pub ipIfStatsOutNoRoutes: Counter,
    pub ipIfStatsReasmDuplicates: Counter,
    pub ipIfStatsReasmPartDups: Counter,
    pub ipIfStatsForwProhibits: Counter,
    pub udpInCksumErrs: Counter,
    pub udpInOverflows: Counter,
    pub rawipInOverflows: Counter,
    pub ipIfStatsInWrongIPVersion: Counter,
    pub ipIfStatsOutWrongIPVersion: Counter,
    pub ipIfStatsOutSwitchIPVersion: Counter,
    pub ipIfStatsIPVersion: illumos_sys_hdrs::c_int,
    pub ipIfStatsHCInReceives: Counter64,
    pub ipIfStatsHCInOctets: Counter64,
    pub ipIfStatsHCInForwDatagrams: Counter64,
    pub ipIfStatsHCInDelivers: Counter64,
    pub ipIfStatsHCOutRequests: Counter64,
    pub ipIfStatsHCOutForwDatagrams: Counter64,
    pub ipIfStatsOutFragReqds: Counter,
    pub ipIfStatsHCOutTransmits: Counter64,
    pub ipIfStatsHCOutOctets: Counter64,
    pub ipIfStatsHCInMcastPkts: Counter64,
    pub ipIfStatsHCInMcastOctets: Counter64,
    pub ipIfStatsHCOutMcastPkts: Counter64,
    pub ipIfStatsHCOutMcastOctets: Counter64,
    pub ipIfStatsHCInBcastPkts: Counter64,
    pub ipIfStatsHCOutBcastPkts: Counter64,
    pub ipsecInSucceeded: Counter,
    pub ipsecInFailed: Counter,
    pub ipInCksumErrs: Counter,
    pub tcpInErrs: Counter,
    pub udpNoPorts: Counter,
}
pub type mib2_ipIfStatsEntry_t = mib2_ipIfStatsEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mib2_ipAddrEntry {
    pub ipAdEntAddr: IpAddress,
    pub ipAdEntIfIndex: DeviceName,
    pub ipAdEntNetMask: IpAddress,
    pub ipAdEntBcastAddr: illumos_sys_hdrs::c_int,
    pub ipAdEntReasmMaxSize: illumos_sys_hdrs::c_int,
    pub ipAdEntInfo: mib2_ipAddrEntry_ipAdEntInfo_s,
    pub ipAdEntRetransmitTime: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mib2_ipAddrEntry_ipAdEntInfo_s {
    pub ae_mtu: Gauge,
    pub ae_metric: illumos_sys_hdrs::c_int,
    pub ae_broadcast_addr: IpAddress,
    pub ae_pp_dst_addr: IpAddress,
    pub ae_flags: illumos_sys_hdrs::c_int,
    pub ae_ibcnt: Counter,
    pub ae_obcnt: Counter,
    pub ae_focnt: Counter,
    pub ae_subnet: IpAddress,
    pub ae_subnet_len: illumos_sys_hdrs::c_int,
    pub ae_src_addr: IpAddress,
}
pub type mib2_ipAddrEntry_t = mib2_ipAddrEntry;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mib2_ipv6AddrEntry {
    pub ipv6AddrIfIndex: DeviceName,
    pub ipv6AddrAddress: Ip6Address,
    pub ipv6AddrPfxLength: uint_t,
    pub ipv6AddrType: uint_t,
    pub ipv6AddrAnycastFlag: uint_t,
    pub ipv6AddrStatus: uint_t,
    pub ipv6AddrInfo: mib2_ipv6AddrEntry_ipv6AddrInfo_s,
    pub ipv6AddrReasmMaxSize: u32,
    pub ipv6AddrIdentifier: Ip6Address,
    pub ipv6AddrIdentifierLen: u32,
    pub ipv6AddrReachableTime: u32,
    pub ipv6AddrRetransmitTime: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mib2_ipv6AddrEntry_ipv6AddrInfo_s {
    pub ae_mtu: Gauge,
    pub ae_metric: illumos_sys_hdrs::c_int,
    pub ae_pp_dst_addr: Ip6Address,
    pub ae_flags: illumos_sys_hdrs::c_int,
    pub ae_ibcnt: Counter,
    pub ae_obcnt: Counter,
    pub ae_focnt: Counter,
    pub ae_subnet: Ip6Address,
    pub ae_subnet_len: illumos_sys_hdrs::c_int,
    pub ae_src_addr: Ip6Address,
}
pub type mib2_ipv6AddrEntry_t = mib2_ipv6AddrEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mib2_ipRouteEntry {
    pub ipRouteDest: IpAddress,
    pub ipRouteIfIndex: DeviceName,
    pub ipRouteMetric1: illumos_sys_hdrs::c_int,
    pub ipRouteMetric2: illumos_sys_hdrs::c_int,
    pub ipRouteMetric3: illumos_sys_hdrs::c_int,
    pub ipRouteMetric4: illumos_sys_hdrs::c_int,
    pub ipRouteNextHop: IpAddress,
    pub ipRouteType: illumos_sys_hdrs::c_int,
    pub ipRouteProto: illumos_sys_hdrs::c_int,
    pub ipRouteAge: illumos_sys_hdrs::c_int,
    pub ipRouteMask: IpAddress,
    pub ipRouteMetric5: illumos_sys_hdrs::c_int,
    pub ipRouteInfo: mib2_ipRouteEntry_ipRouteInfo_s,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mib2_ipRouteEntry_ipRouteInfo_s {
    pub re_max_frag: Gauge,
    pub re_rtt: Gauge,
    pub re_ref: Counter,
    pub re_frag_flag: illumos_sys_hdrs::c_int,
    pub re_src_addr: IpAddress,
    pub re_ire_type: illumos_sys_hdrs::c_int,
    pub re_obpkt: Counter,
    pub re_ibpkt: Counter,
    pub re_flags: illumos_sys_hdrs::c_int,
    pub re_in_ill: DeviceName,
    pub re_in_src_addr: IpAddress,
}
pub type mib2_ipRouteEntry_t = mib2_ipRouteEntry;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mib2_ipv6RouteEntry {
    pub ipv6RouteDest: Ip6Address,
    pub ipv6RoutePfxLength: illumos_sys_hdrs::c_int,
    pub ipv6RouteIndex: illumos_sys_hdrs::c_uint,
    pub ipv6RouteIfIndex: DeviceName,
    pub ipv6RouteNextHop: Ip6Address,
    pub ipv6RouteType: illumos_sys_hdrs::c_int,
    pub ipv6RouteProtocol: illumos_sys_hdrs::c_int,
    pub ipv6RoutePolicy: illumos_sys_hdrs::c_uint,
    pub ipv6RouteAge: illumos_sys_hdrs::c_int,
    pub ipv6RouteNextHopRDI: illumos_sys_hdrs::c_uint,
    pub ipv6RouteMetric: illumos_sys_hdrs::c_uint,
    pub ipv6RouteWeight: illumos_sys_hdrs::c_uint,
    pub ipv6RouteInfo: mib2_ipv6RouteEntry_ipv6RouteInfo_s,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mib2_ipv6RouteEntry_ipv6RouteInfo_s {
    pub re_max_frag: Gauge,
    pub re_rtt: Gauge,
    pub re_ref: Counter,
    pub re_frag_flag: illumos_sys_hdrs::c_int,
    pub re_src_addr: Ip6Address,
    pub re_ire_type: illumos_sys_hdrs::c_int,
    pub re_obpkt: Counter,
    pub re_ibpkt: Counter,
    pub re_flags: illumos_sys_hdrs::c_int,
}
pub type mib2_ipv6RouteEntry_t = mib2_ipv6RouteEntry;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mib2_ipAttributeEntry {
    pub iae_routeidx: uint_t,
    pub iae_doi: illumos_sys_hdrs::c_int,
    pub iae_slrange: brange_t,
}
pub type mib2_ipAttributeEntry_t = mib2_ipAttributeEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mib2_ipNetToMediaEntry {
    pub ipNetToMediaIfIndex: DeviceName,
    pub ipNetToMediaPhysAddress: PhysAddress,
    pub ipNetToMediaNetAddress: IpAddress,
    pub ipNetToMediaType: illumos_sys_hdrs::c_int,
    pub ipNetToMediaInfo: mib2_ipNetToMediaEntry_ipNetToMediaInfo_s,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mib2_ipNetToMediaEntry_ipNetToMediaInfo_s {
    pub ntm_mask: PhysAddress,
    pub ntm_flags: illumos_sys_hdrs::c_int,
}
pub type mib2_ipNetToMediaEntry_t = mib2_ipNetToMediaEntry;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mib2_ipv6NetToMediaEntry {
    pub ipv6NetToMediaIfIndex: DeviceIndex,
    pub ipv6NetToMediaNetAddress: Ip6Address,
    pub ipv6NetToMediaPhysAddress: PhysAddress,
    pub ipv6NetToMediaType: illumos_sys_hdrs::c_int,
    pub ipv6NetToMediaState: illumos_sys_hdrs::c_int,
    pub ipv6NetToMediaLastUpdated: illumos_sys_hdrs::c_int,
}
pub type mib2_ipv6NetToMediaEntry_t = mib2_ipv6NetToMediaEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_member {
    pub ipGroupMemberIfIndex: DeviceName,
    pub ipGroupMemberAddress: IpAddress,
    pub ipGroupMemberRefCnt: Counter,
    pub ipGroupMemberFilterMode: illumos_sys_hdrs::c_int,
}
pub type ip_member_t = ip_member;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_member {
    pub ipv6GroupMemberIfIndex: DeviceIndex,
    pub ipv6GroupMemberAddress: Ip6Address,
    pub ipv6GroupMemberRefCnt: Counter,
    pub ipv6GroupMemberFilterMode: illumos_sys_hdrs::c_int,
}
pub type ipv6_member_t = ipv6_member;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mib2_transportMLPEntry {
    pub tme_connidx: uint_t,
    pub tme_flags: uint_t,
    pub tme_doi: illumos_sys_hdrs::c_int,
    pub tme_label: bslabel_t,
}
pub type mib2_transportMLPEntry_t = mib2_transportMLPEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mib2_socketInfoEntry {
    pub sie_connidx: u64,
    pub sie_inode: u64,
    pub sie_flags: u64,
    pub sie_dev: u64,
}
pub type mib2_socketInfoEntry_t = mib2_socketInfoEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_grpsrc {
    pub ipGroupSourceIfIndex: DeviceName,
    pub ipGroupSourceGroup: IpAddress,
    pub ipGroupSourceAddress: IpAddress,
}
pub type ip_grpsrc_t = ip_grpsrc;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_grpsrc {
    pub ipv6GroupSourceIfIndex: DeviceIndex,
    pub ipv6GroupSourceGroup: Ip6Address,
    pub ipv6GroupSourceAddress: Ip6Address,
}
pub type ipv6_grpsrc_t = ipv6_grpsrc;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dest_cache_entry {
    pub DestIpv4Address: IpAddress,
    pub DestIpv6Address: Ip6Address,
    pub DestFlags: uint_t,
    pub DestPmtu: u32,
    pub DestIdent: u32,
    pub DestIfindex: DeviceIndex,
    pub DestAge: u32,
}
pub type dest_cache_entry_t = dest_cache_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mib2_icmp {
    pub icmpInMsgs: Counter,
    pub icmpInErrors: Counter,
    pub icmpInDestUnreachs: Counter,
    pub icmpInTimeExcds: Counter,
    pub icmpInParmProbs: Counter,
    pub icmpInSrcQuenchs: Counter,
    pub icmpInRedirects: Counter,
    pub icmpInEchos: Counter,
    pub icmpInEchoReps: Counter,
    pub icmpInTimestamps: Counter,
    pub icmpInTimestampReps: Counter,
    pub icmpInAddrMasks: Counter,
    pub icmpInAddrMaskReps: Counter,
    pub icmpOutMsgs: Counter,
    pub icmpOutErrors: Counter,
    pub icmpOutDestUnreachs: Counter,
    pub icmpOutTimeExcds: Counter,
    pub icmpOutParmProbs: Counter,
    pub icmpOutSrcQuenchs: Counter,
    pub icmpOutRedirects: Counter,
    pub icmpOutEchos: Counter,
    pub icmpOutEchoReps: Counter,
    pub icmpOutTimestamps: Counter,
    pub icmpOutTimestampReps: Counter,
    pub icmpOutAddrMasks: Counter,
    pub icmpOutAddrMaskReps: Counter,
    pub icmpInCksumErrs: Counter,
    pub icmpInUnknowns: Counter,
    pub icmpInFragNeeded: Counter,
    pub icmpOutFragNeeded: Counter,
    pub icmpOutDrops: Counter,
    pub icmpInOverflows: Counter,
    pub icmpInBadRedirects: Counter,
}
pub type mib2_icmp_t = mib2_icmp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mib2_ipv6IfIcmpEntry {
    pub ipv6IfIcmpIfIndex: DeviceIndex,
    pub ipv6IfIcmpEntrySize: illumos_sys_hdrs::c_int,
    pub ipv6IfIcmpInMsgs: Counter32,
    pub ipv6IfIcmpInErrors: Counter32,
    pub ipv6IfIcmpInDestUnreachs: Counter32,
    pub ipv6IfIcmpInAdminProhibs: Counter32,
    pub ipv6IfIcmpInTimeExcds: Counter32,
    pub ipv6IfIcmpInParmProblems: Counter32,
    pub ipv6IfIcmpInPktTooBigs: Counter32,
    pub ipv6IfIcmpInEchos: Counter32,
    pub ipv6IfIcmpInEchoReplies: Counter32,
    pub ipv6IfIcmpInRouterSolicits: Counter32,
    pub ipv6IfIcmpInRouterAdvertisements: Counter32,
    pub ipv6IfIcmpInNeighborSolicits: Counter32,
    pub ipv6IfIcmpInNeighborAdvertisements: Counter32,
    pub ipv6IfIcmpInRedirects: Counter32,
    pub ipv6IfIcmpInGroupMembQueries: Counter32,
    pub ipv6IfIcmpInGroupMembResponses: Counter32,
    pub ipv6IfIcmpInGroupMembReductions: Counter32,
    pub ipv6IfIcmpOutMsgs: Counter32,
    pub ipv6IfIcmpOutErrors: Counter32,
    pub ipv6IfIcmpOutDestUnreachs: Counter32,
    pub ipv6IfIcmpOutAdminProhibs: Counter32,
    pub ipv6IfIcmpOutTimeExcds: Counter32,
    pub ipv6IfIcmpOutParmProblems: Counter32,
    pub ipv6IfIcmpOutPktTooBigs: Counter32,
    pub ipv6IfIcmpOutEchos: Counter32,
    pub ipv6IfIcmpOutEchoReplies: Counter32,
    pub ipv6IfIcmpOutRouterSolicits: Counter32,
    pub ipv6IfIcmpOutRouterAdvertisements: Counter32,
    pub ipv6IfIcmpOutNeighborSolicits: Counter32,
    pub ipv6IfIcmpOutNeighborAdvertisements: Counter32,
    pub ipv6IfIcmpOutRedirects: Counter32,
    pub ipv6IfIcmpOutGroupMembQueries: Counter32,
    pub ipv6IfIcmpOutGroupMembResponses: Counter32,
    pub ipv6IfIcmpOutGroupMembReductions: Counter32,
    pub ipv6IfIcmpInOverflows: Counter32,
    pub ipv6IfIcmpBadHoplimit: Counter32,
    pub ipv6IfIcmpInBadNeighborAdvertisements: Counter32,
    pub ipv6IfIcmpInBadNeighborSolicitations: Counter32,
    pub ipv6IfIcmpInBadRedirects: Counter32,
    pub ipv6IfIcmpInGroupMembTotal: Counter32,
    pub ipv6IfIcmpInGroupMembBadQueries: Counter32,
    pub ipv6IfIcmpInGroupMembBadReports: Counter32,
    pub ipv6IfIcmpInGroupMembOurReports: Counter32,
}
pub type mib2_ipv6IfIcmpEntry_t = mib2_ipv6IfIcmpEntry;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mib2_tcp {
    pub tcpRtoAlgorithm: illumos_sys_hdrs::c_int,
    pub tcpRtoMin: illumos_sys_hdrs::c_int,
    pub tcpRtoMax: illumos_sys_hdrs::c_int,
    pub tcpMaxConn: illumos_sys_hdrs::c_int,
    pub tcpActiveOpens: Counter,
    pub tcpPassiveOpens: Counter,
    pub tcpAttemptFails: Counter,
    pub tcpEstabResets: Counter,
    pub tcpCurrEstab: Gauge,
    pub tcpInSegs: Counter,
    pub tcpOutSegs: Counter,
    pub tcpRetransSegs: Counter,
    pub tcpConnTableSize: illumos_sys_hdrs::c_int,
    pub tcpOutRsts: Counter,
    pub tcpOutDataSegs: Counter,
    pub tcpOutDataBytes: Counter,
    pub tcpRetransBytes: Counter,
    pub tcpOutAck: Counter,
    pub tcpOutAckDelayed: Counter,
    pub tcpOutUrg: Counter,
    pub tcpOutWinUpdate: Counter,
    pub tcpOutWinProbe: Counter,
    pub tcpOutControl: Counter,
    pub tcpOutFastRetrans: Counter,
    pub tcpInAckSegs: Counter,
    pub tcpInAckBytes: Counter,
    pub tcpInDupAck: Counter,
    pub tcpInAckUnsent: Counter,
    pub tcpInDataInorderSegs: Counter,
    pub tcpInDataInorderBytes: Counter,
    pub tcpInDataUnorderSegs: Counter,
    pub tcpInDataUnorderBytes: Counter,
    pub tcpInDataDupSegs: Counter,
    pub tcpInDataDupBytes: Counter,
    pub tcpInDataPartDupSegs: Counter,
    pub tcpInDataPartDupBytes: Counter,
    pub tcpInDataPastWinSegs: Counter,
    pub tcpInDataPastWinBytes: Counter,
    pub tcpInWinProbe: Counter,
    pub tcpInWinUpdate: Counter,
    pub tcpInClosed: Counter,
    pub tcpRttNoUpdate: Counter,
    pub tcpRttUpdate: Counter,
    pub tcpTimRetrans: Counter,
    pub tcpTimRetransDrop: Counter,
    pub tcpTimKeepalive: Counter,
    pub tcpTimKeepaliveProbe: Counter,
    pub tcpTimKeepaliveDrop: Counter,
    pub tcpListenDrop: Counter,
    pub tcpListenDropQ0: Counter,
    pub tcpHalfOpenDrop: Counter,
    pub tcpOutSackRetransSegs: Counter,
    pub tcp6ConnTableSize: illumos_sys_hdrs::c_int,
    pub tcpHCInSegs: Counter64,
    pub tcpHCOutSegs: Counter64,
}
pub type mib2_tcp_t = mib2_tcp;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct tcpConnEntryInfo_s {
    pub ce_in_data_inorder_bytes: Counter64,
    pub ce_in_data_inorder_segs: Counter64,
    pub ce_in_data_unorder_bytes: Counter64,
    pub ce_in_data_unorder_segs: Counter64,
    pub ce_in_zwnd_probes: Counter64,
    pub ce_out_data_bytes: Counter64,
    pub ce_out_data_segs: Counter64,
    pub ce_out_retrans_bytes: Counter64,
    pub ce_out_retrans_segs: Counter64,
    pub ce_out_zwnd_probes: Counter64,
    pub ce_rtt_sum: Counter64,
    pub ce_snxt: Gauge,
    pub ce_suna: Gauge,
    pub ce_swnd: Gauge,
    pub ce_cwnd: Gauge,
    pub ce_rnxt: Gauge,
    pub ce_rack: Gauge,
    pub ce_unsent: Gauge,
    pub ce_rwnd: Gauge,
    pub ce_rtt_sa: Gauge,
    pub ce_rto: Gauge,
    pub ce_rtt_cnt: Gauge,
    pub ce_mss: Gauge,
    pub ce_state: illumos_sys_hdrs::c_int,
}
pub type tcpConnEntryInfo_t = tcpConnEntryInfo_s;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mib2_tcpConnEntry {
    pub tcpConnState: illumos_sys_hdrs::c_int,
    pub tcpConnLocalAddress: IpAddress,
    pub tcpConnLocalPort: illumos_sys_hdrs::c_int,
    pub tcpConnRemAddress: IpAddress,
    pub tcpConnRemPort: illumos_sys_hdrs::c_int,
    pub tcpConnEntryInfo: tcpConnEntryInfo_t,
    pub tcpConnCreationProcess: u32,
    pub tcpConnCreationTime: u64,
}
pub type mib2_tcpConnEntry_t = mib2_tcpConnEntry;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct mib2_tcp6ConnEntry {
    pub tcp6ConnLocalAddress: Ip6Address,
    pub tcp6ConnLocalPort: illumos_sys_hdrs::c_int,
    pub tcp6ConnRemAddress: Ip6Address,
    pub tcp6ConnRemPort: illumos_sys_hdrs::c_int,
    pub tcp6ConnIfIndex: DeviceIndex,
    pub tcp6ConnState: illumos_sys_hdrs::c_int,
    pub tcp6ConnEntryInfo: tcpConnEntryInfo_t,
    pub tcp6ConnCreationProcess: u32,
    pub tcp6ConnCreationTime: u64,
}
pub type mib2_tcp6ConnEntry_t = mib2_tcp6ConnEntry;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mib2_udp {
    pub udpInDatagrams: Counter,
    pub udpInErrors: Counter,
    pub udpOutDatagrams: Counter,
    pub udpEntrySize: illumos_sys_hdrs::c_int,
    pub udp6EntrySize: illumos_sys_hdrs::c_int,
    pub udpOutErrors: Counter,
    pub udpHCInDatagrams: Counter64,
    pub udpHCOutDatagrams: Counter64,
}
pub type mib2_udp_t = mib2_udp;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mib2_udpEntry {
    pub udpLocalAddress: IpAddress,
    pub udpLocalPort: illumos_sys_hdrs::c_int,
    pub udpEntryInfo: mib2_udpEntry_udpEntryInfo_s,
    pub udpInstance: u32,
    pub udpCreationProcess: u32,
    pub udpCreationTime: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mib2_udpEntry_udpEntryInfo_s {
    pub ue_state: illumos_sys_hdrs::c_int,
    pub ue_RemoteAddress: IpAddress,
    pub ue_RemotePort: illumos_sys_hdrs::c_int,
}
pub type mib2_udpEntry_t = mib2_udpEntry;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct mib2_udp6Entry {
    pub udp6LocalAddress: Ip6Address,
    pub udp6LocalPort: illumos_sys_hdrs::c_int,
    pub udp6IfIndex: DeviceIndex,
    pub udp6EntryInfo: mib2_udp6Entry_udp6EntryInfo_s,
    pub udp6Instance: u32,
    pub udp6CreationProcess: u32,
    pub udp6CreationTime: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mib2_udp6Entry_udp6EntryInfo_s {
    pub ue_state: illumos_sys_hdrs::c_int,
    pub ue_RemoteAddress: Ip6Address,
    pub ue_RemotePort: illumos_sys_hdrs::c_int,
}
pub type mib2_udp6Entry_t = mib2_udp6Entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mib2_rawip {
    pub rawipInDatagrams: Counter,
    pub rawipInCksumErrs: Counter,
    pub rawipInErrors: Counter,
    pub rawipOutDatagrams: Counter,
    pub rawipOutErrors: Counter,
}
pub type mib2_rawip_t = mib2_rawip;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mib2_sctpConnEntry {
    pub sctpAssocId: u32,
    pub sctpAssocRemHostName: Octet_t,
    pub sctpAssocLocalPort: u32,
    pub sctpAssocRemPort: u32,
    pub sctpAssocRemPrimAddrType: illumos_sys_hdrs::c_int,
    pub sctpAssocRemPrimAddr: Ip6Address,
    pub sctpAssocLocPrimAddr: Ip6Address,
    pub sctpAssocHeartBeatInterval: u32,
    pub sctpAssocState: illumos_sys_hdrs::c_int,
    pub sctpAssocInStreams: u32,
    pub sctpAssocOutStreams: u32,
    pub sctpAssocMaxRetr: u32,
    pub sctpAssocPrimProcess: u32,
    pub sctpAssocT1expired: Counter32,
    pub sctpAssocT2expired: Counter32,
    pub sctpAssocRtxChunks: Counter32,
    pub sctpAssocStartTime: u32,
    pub sctpConnEntryInfo: mib2_sctpConnEntry_sctpConnEntryInfo_s,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mib2_sctpConnEntry_sctpConnEntryInfo_s {
    pub ce_sendq: Gauge,
    pub ce_recvq: Gauge,
    pub ce_swnd: Gauge,
    pub ce_rwnd: Gauge,
    pub ce_mss: Gauge,
}
pub type mib2_sctpConnEntry_t = mib2_sctpConnEntry;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mib2_sctpConnLocalAddrEntry {
    pub sctpAssocId: u32,
    pub sctpAssocLocalAddrType: illumos_sys_hdrs::c_int,
    pub sctpAssocLocalAddr: Ip6Address,
}
pub type mib2_sctpConnLocalEntry_t = mib2_sctpConnLocalAddrEntry;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mib2_sctpConnRemoteAddrEntry {
    pub sctpAssocId: u32,
    pub sctpAssocRemAddrType: illumos_sys_hdrs::c_int,
    pub sctpAssocRemAddr: Ip6Address,
    pub sctpAssocRemAddrActive: illumos_sys_hdrs::c_int,
    pub sctpAssocRemAddrHBActive: illumos_sys_hdrs::c_int,
    pub sctpAssocRemAddrRTO: u32,
    pub sctpAssocRemAddrMaxPathRtx: u32,
    pub sctpAssocRemAddrRtx: u32,
}
pub type mib2_sctpConnRemoteEntry_t = mib2_sctpConnRemoteAddrEntry;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mib2_sctp {
    pub sctpRtoAlgorithm: illumos_sys_hdrs::c_int,
    pub sctpRtoMin: u32,
    pub sctpRtoMax: u32,
    pub sctpRtoInitial: u32,
    pub sctpMaxAssocs: i32,
    pub sctpValCookieLife: u32,
    pub sctpMaxInitRetr: u32,
    pub sctpCurrEstab: Counter32,
    pub sctpActiveEstab: Counter32,
    pub sctpPassiveEstab: Counter32,
    pub sctpAborted: Counter32,
    pub sctpShutdowns: Counter32,
    pub sctpOutOfBlue: Counter32,
    pub sctpChecksumError: Counter32,
    pub sctpOutCtrlChunks: Counter64,
    pub sctpOutOrderChunks: Counter64,
    pub sctpOutUnorderChunks: Counter64,
    pub sctpRetransChunks: Counter64,
    pub sctpOutAck: Counter,
    pub sctpOutAckDelayed: Counter,
    pub sctpOutWinUpdate: Counter,
    pub sctpOutFastRetrans: Counter,
    pub sctpOutWinProbe: Counter,
    pub sctpInCtrlChunks: Counter64,
    pub sctpInOrderChunks: Counter64,
    pub sctpInUnorderChunks: Counter64,
    pub sctpInAck: Counter,
    pub sctpInDupAck: Counter,
    pub sctpInAckUnsent: Counter,
    pub sctpFragUsrMsgs: Counter64,
    pub sctpReasmUsrMsgs: Counter64,
    pub sctpOutSCTPPkts: Counter64,
    pub sctpInSCTPPkts: Counter64,
    pub sctpInInvalidCookie: Counter,
    pub sctpTimRetrans: Counter,
    pub sctpTimRetransDrop: Counter,
    pub sctpTimHeartBeatProbe: Counter,
    pub sctpTimHeartBeatDrop: Counter,
    pub sctpListenDrop: Counter,
    pub sctpInClosed: Counter,
    pub sctpEntrySize: illumos_sys_hdrs::c_int,
    pub sctpLocalEntrySize: illumos_sys_hdrs::c_int,
    pub sctpRemoteEntrySize: illumos_sys_hdrs::c_int,
}
pub type mib2_sctp_t = mib2_sctp;
unsafe extern "C" {
    pub static mut byte_to_bcd: [illumos_sys_hdrs::c_uchar; 256usize];
}
unsafe extern "C" {
    pub static mut bcd_to_byte: [illumos_sys_hdrs::c_uchar; 256usize];
}
pub type pfi_t =
    ::core::option::Option<unsafe extern "C" fn() -> illumos_sys_hdrs::c_int>;
pub type pfv_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type IDP = *mut illumos_sys_hdrs::c_char;
pub type MBLKP = *mut msgb;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    pub fd: illumos_sys_hdrs::c_int,
    pub events: illumos_sys_hdrs::c_short,
    pub revents: illumos_sys_hdrs::c_short,
}
pub type pollfd_t = pollfd;
pub type nfds_t = illumos_sys_hdrs::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpollinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollhead {
    pub ph_list: *mut polldat,
    pub ph_pad1: *mut illumos_sys_hdrs::c_void,
    pub ph_pad2: illumos_sys_hdrs::c_short,
}
pub type pollhead_t = pollhead;
unsafe extern "C" {
    pub fn pollwakeup(arg1: *mut pollhead_t, arg2: illumos_sys_hdrs::c_short);
}
unsafe extern "C" {
    pub fn polllock(
        arg1: *mut pollhead_t,
        arg2: *mut kmutex_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn pollunlock(
        arg1: *mut illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn pollrelock(arg1: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn pollcleanup();
}
unsafe extern "C" {
    pub fn pollblockexit(arg1: *mut fpollinfo);
}
unsafe extern "C" {
    pub fn pollcacheclean(arg1: *mut fpollinfo, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn pollhead_clean(arg1: *mut pollhead_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct queue {
    pub q_qinfo: *mut qinit,
    pub q_first: *mut msgb,
    pub q_last: *mut msgb,
    pub q_next: *mut queue,
    pub q_link: *mut queue,
    pub q_ptr: *mut illumos_sys_hdrs::c_void,
    pub q_count: usize,
    pub q_flag: uint_t,
    pub q_minpsz: isize,
    pub q_maxpsz: isize,
    pub q_hiwat: usize,
    pub q_lowat: usize,
    pub q_bandp: *mut qband,
    pub q_lock: kmutex_t,
    pub q_stream: *mut stdata,
    pub q_syncq: *mut syncq,
    pub q_nband: illumos_sys_hdrs::c_uchar,
    pub q_wait: kcondvar_t,
    pub q_nfsrv: *mut queue,
    pub q_draining: ushort_t,
    pub q_struiot: illumos_sys_hdrs::c_short,
    pub q_qtstamp: clock_t,
    pub q_mblkcnt: usize,
    pub q_syncqmsgs: uint_t,
    pub q_rwcnt: usize,
    pub q_spri: pri_t,
    pub q_sqhead: *mut msgb,
    pub q_sqtail: *mut msgb,
    pub q_sqnext: *mut queue,
    pub q_sqprev: *mut queue,
    pub q_sqflags: uint_t,
    pub q_sqtstamp: clock_t,
    pub q_fp: *mut fmodsw_impl,
}
pub type queue_t = queue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qband {
    pub qb_next: *mut qband,
    pub qb_count: usize,
    pub qb_first: *mut msgb,
    pub qb_last: *mut msgb,
    pub qb_hiwat: usize,
    pub qb_lowat: usize,
    pub qb_flag: uint_t,
    pub qb_mblkcnt: usize,
}
pub type qband_t = qband;
pub const qfields_QHIWAT: qfields = 0;
pub const qfields_QLOWAT: qfields = 1;
pub const qfields_QMAXPSZ: qfields = 2;
pub const qfields_QMINPSZ: qfields = 3;
pub const qfields_QCOUNT: qfields = 4;
pub const qfields_QFIRST: qfields = 5;
pub const qfields_QLAST: qfields = 6;
pub const qfields_QFLAG: qfields = 7;
pub const qfields_QSTRUIOT: qfields = 8;
pub const qfields_QBAD: qfields = 9;
pub type qfields = illumos_sys_hdrs::c_uint;
pub use self::qfields as qfields_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_info {
    pub mi_idnum: ushort_t,
    pub mi_idname: *mut illumos_sys_hdrs::c_char,
    pub mi_minpsz: isize,
    pub mi_maxpsz: isize,
    pub mi_hiwat: usize,
    pub mi_lowat: usize,
}
pub type mblk_t = msgb;
pub type struiod_t = struiod;
pub type infod_t = infod;
pub type qi_putp_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut queue_t,
        arg2: *mut mblk_t,
    ) -> illumos_sys_hdrs::c_int,
>;
pub type qi_srvp_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut queue_t) -> illumos_sys_hdrs::c_int,
>;
pub type qi_qopen_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut queue_t,
        arg2: *mut dev_t,
        arg3: illumos_sys_hdrs::c_int,
        arg4: illumos_sys_hdrs::c_int,
        arg5: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int,
>;
pub type qi_qclose_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut queue_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int,
>;
pub type qi_qadmin_t =
    ::core::option::Option<unsafe extern "C" fn() -> illumos_sys_hdrs::c_int>;
pub type qi_rwp_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut queue_t,
        arg2: *mut struiod_t,
    ) -> illumos_sys_hdrs::c_int,
>;
pub type qi_infop_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut queue_t,
        arg2: *mut infod_t,
    ) -> illumos_sys_hdrs::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qinit {
    pub qi_putp: qi_putp_t,
    pub qi_srvp: qi_srvp_t,
    pub qi_qopen: qi_qopen_t,
    pub qi_qclose: qi_qclose_t,
    pub qi_qadmin: qi_qadmin_t,
    pub qi_minfo: *mut module_info,
    pub qi_mstat: *mut module_stat,
    pub qi_rwp: qi_rwp_t,
    pub qi_infop: qi_infop_t,
    pub qi_struiot: illumos_sys_hdrs::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct streamtab {
    pub st_rdinit: *mut qinit,
    pub st_wrinit: *mut qinit,
    pub st_muxrinit: *mut qinit,
    pub st_muxwinit: *mut qinit,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linkblk {
    pub l_qtop: *mut queue_t,
    pub l_qbot: *mut queue_t,
    pub l_index: illumos_sys_hdrs::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct free_rtn {
    pub free_func: ::core::option::Option<unsafe extern "C" fn()>,
    pub free_arg: caddr_t,
}
pub type frtn_t = free_rtn;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct datab {
    pub db_frtnp: *mut frtn_t,
    pub db_base: *mut illumos_sys_hdrs::c_uchar,
    pub db_lim: *mut illumos_sys_hdrs::c_uchar,
    pub db_ref: illumos_sys_hdrs::c_uchar,
    pub db_type: illumos_sys_hdrs::c_uchar,
    pub db_flags: illumos_sys_hdrs::c_uchar,
    pub db_struioflag: illumos_sys_hdrs::c_uchar,
    pub db_cpid: pid_t,
    pub db_cache: *mut illumos_sys_hdrs::c_void,
    pub db_mblk: *mut msgb,
    pub db_free: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut msgb, arg2: *mut datab),
    >,
    pub db_lastfree: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut msgb, arg2: *mut datab),
    >,
    pub db_cksumstart: isize,
    pub db_cksumend: isize,
    pub db_cksumstuff: isize,
    pub db_struioun: datab__bindgen_ty_1,
    pub db_fthdr: *mut fthdr,
    pub db_credp: *mut cred_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union datab__bindgen_ty_1 {
    pub enforce_alignment: f64,
    pub data: [illumos_sys_hdrs::c_uchar; 8usize],
    pub cksum: datab__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct datab__bindgen_ty_1__bindgen_ty_1 {
    pub cksum_val: datab__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub flags: u16,
    pub pad: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union datab__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub u32_: u32,
    pub u16_: u16,
}
pub type dblk_t = datab;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msgb {
    pub b_next: *mut msgb,
    pub b_prev: *mut msgb,
    pub b_cont: *mut msgb,
    pub b_rptr: *mut illumos_sys_hdrs::c_uchar,
    pub b_wptr: *mut illumos_sys_hdrs::c_uchar,
    pub b_datap: *mut datab,
    pub b_band: illumos_sys_hdrs::c_uchar,
    pub b_tag: illumos_sys_hdrs::c_uchar,
    pub b_flag: illumos_sys_hdrs::c_ushort,
    pub b_queue: *mut queue_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bcache {
    pub mutex: kmutex_t,
    pub buffer_cache: *mut kmem_cache,
    pub dblk_cache: *mut kmem_cache,
    pub alloc: illumos_sys_hdrs::c_int,
    pub destroy: illumos_sys_hdrs::c_int,
    pub size: usize,
    pub align: uint_t,
}
pub type bcache_t = bcache;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iocblk {
    pub ioc_cmd: illumos_sys_hdrs::c_int,
    pub ioc_cr: *mut cred_t,
    pub ioc_id: uint_t,
    pub ioc_flag: uint_t,
    pub ioc_count: usize,
    pub ioc_rval: illumos_sys_hdrs::c_int,
    pub ioc_error: illumos_sys_hdrs::c_int,
}
pub type IOCP = *mut iocblk;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct copyreq {
    pub cq_cmd: illumos_sys_hdrs::c_int,
    pub cq_cr: *mut cred_t,
    pub cq_id: uint_t,
    pub cq_flag: uint_t,
    pub cq_private: *mut mblk_t,
    pub cq_addr: caddr_t,
    pub cq_size: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct copyresp {
    pub cp_cmd: illumos_sys_hdrs::c_int,
    pub cp_cr: *mut cred_t,
    pub cp_id: uint_t,
    pub cp_flag: uint_t,
    pub cp_private: *mut mblk_t,
    pub cp_rval: caddr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ioctypes {
    pub iocblk: iocblk,
    pub copyreq: copyreq,
    pub copyresp: copyresp,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stroptions {
    pub so_flags: uint_t,
    pub so_readopt: illumos_sys_hdrs::c_short,
    pub so_wroff: ushort_t,
    pub so_minpsz: isize,
    pub so_maxpsz: isize,
    pub so_hiwat: usize,
    pub so_lowat: usize,
    pub so_band: illumos_sys_hdrs::c_uchar,
    pub so_erropt: ushort_t,
    pub so_maxblk: isize,
    pub so_copyopt: ushort_t,
    pub so_tail: ushort_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct struiod {
    pub d_mp: *mut mblk_t,
    pub d_uio: uio_t,
    pub d_iov: *mut iovec_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct infod {
    pub d_cmd: illumos_sys_hdrs::c_uchar,
    pub d_res: illumos_sys_hdrs::c_uchar,
    pub d_bytes: illumos_sys_hdrs::c_int,
    pub d_count: illumos_sys_hdrs::c_int,
    pub d_uiop: *mut uio_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmdblk {
    pub cb_cmd: illumos_sys_hdrs::c_int,
    pub cb_cr: *mut cred_t,
    pub cb_len: uint_t,
    pub cb_error: illumos_sys_hdrs::c_int,
}
pub type cmdblk_t = cmdblk;
unsafe extern "C" {
    pub fn allocb(arg1: usize, arg2: uint_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn desballoc(
        arg1: *mut illumos_sys_hdrs::c_uchar,
        arg2: usize,
        arg3: uint_t,
        arg4: *mut frtn_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn esballoc(
        arg1: *mut illumos_sys_hdrs::c_uchar,
        arg2: usize,
        arg3: uint_t,
        arg4: *mut frtn_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn bcache_create(
        arg1: *mut illumos_sys_hdrs::c_char,
        arg2: usize,
        arg3: uint_t,
    ) -> *mut bcache_t;
}
unsafe extern "C" {
    pub fn bcache_destroy(arg1: *mut bcache_t);
}
unsafe extern "C" {
    pub fn bcache_allocb(arg1: *mut bcache_t, arg2: uint_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn mkiocb(arg1: uint_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn testb(arg1: usize, arg2: uint_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn bufcall(
        arg1: usize,
        arg2: uint_t,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
        >,
        arg4: *mut illumos_sys_hdrs::c_void,
    ) -> bufcall_id_t;
}
unsafe extern "C" {
    pub fn esbbcall(
        arg1: uint_t,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
        >,
        arg3: *mut illumos_sys_hdrs::c_void,
    ) -> bufcall_id_t;
}
unsafe extern "C" {
    pub fn freeb(arg1: *mut msgb);
}
unsafe extern "C" {
    pub fn freemsg(arg1: *mut mblk_t);
}
unsafe extern "C" {
    pub fn dupb(arg1: *mut mblk_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn dupmsg(arg1: *mut mblk_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn dupmsg_noloan(arg1: *mut mblk_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn copyb(arg1: *mut mblk_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn copymsg(arg1: *mut mblk_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn linkb(arg1: *mut mblk_t, arg2: *mut mblk_t);
}
unsafe extern "C" {
    pub fn unlinkb(arg1: *mut mblk_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn reallocb(
        arg1: *mut mblk_t,
        arg2: usize,
        arg3: uint_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn rmvb(arg1: *mut mblk_t, arg2: *mut mblk_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn pullupmsg(arg1: *mut msgb, arg2: isize) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn msgpullup(arg1: *mut msgb, arg2: isize) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn adjmsg(arg1: *mut msgb, arg2: isize) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn msgdsize(arg1: *mut msgb) -> usize;
}
unsafe extern "C" {
    pub fn getq(arg1: *mut queue_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn rmvq(arg1: *mut queue_t, arg2: *mut mblk_t);
}
unsafe extern "C" {
    pub fn flushq(arg1: *mut queue_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn flushq_common(
        arg1: *mut queue_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn flushband(
        arg1: *mut queue_t,
        arg2: illumos_sys_hdrs::c_uchar,
        arg3: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn canput(arg1: *mut queue_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn bcanput(
        arg1: *mut queue_t,
        arg2: illumos_sys_hdrs::c_uchar,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn canputnext(arg1: *mut queue_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn bcanputnext(
        arg1: *mut queue_t,
        arg2: illumos_sys_hdrs::c_uchar,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn putq(
        arg1: *mut queue_t,
        arg2: *mut mblk_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn putbq(
        arg1: *mut queue_t,
        arg2: *mut mblk_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn insq(
        arg1: *mut queue_t,
        arg2: *mut mblk_t,
        arg3: *mut mblk_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn put(arg1: *mut queue_t, arg2: *mut mblk_t);
}
unsafe extern "C" {
    pub fn putnext(arg1: *mut queue_t, arg2: *mut mblk_t);
}
unsafe extern "C" {
    pub fn putctl(
        arg1: *mut queue_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn putctl1(
        arg1: *mut queue_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn putnextctl(
        arg1: *mut queue_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn putnextctl1(
        arg1: *mut queue_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn backq(arg1: *mut queue_t) -> *mut queue_t;
}
unsafe extern "C" {
    pub fn qreply(arg1: *mut queue_t, arg2: *mut mblk_t);
}
unsafe extern "C" {
    pub fn qenable(arg1: *mut queue_t);
}
unsafe extern "C" {
    pub fn qsize(arg1: *mut queue_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn noenable(arg1: *mut queue_t);
}
unsafe extern "C" {
    pub fn enableok(arg1: *mut queue_t);
}
unsafe extern "C" {
    pub fn strqset(
        arg1: *mut queue_t,
        arg2: qfields_t,
        arg3: illumos_sys_hdrs::c_uchar,
        arg4: isize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn strqget(
        arg1: *mut queue_t,
        arg2: qfields_t,
        arg3: illumos_sys_hdrs::c_uchar,
        arg4: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn unbufcall(arg1: bufcall_id_t);
}
unsafe extern "C" {
    pub fn qprocson(arg1: *mut queue_t);
}
unsafe extern "C" {
    pub fn qprocsoff(arg1: *mut queue_t);
}
unsafe extern "C" {
    pub fn freezestr(arg1: *mut queue_t);
}
unsafe extern "C" {
    pub fn unfreezestr(arg1: *mut queue_t);
}
unsafe extern "C" {
    pub fn qwait(arg1: *mut queue_t);
}
unsafe extern "C" {
    pub fn qwait_sig(arg1: *mut queue_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn qwait_rw(arg1: *mut queue_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn qwriter(
        arg1: *mut queue_t,
        arg2: *mut mblk_t,
        func: ::core::option::Option<unsafe extern "C" fn()>,
        arg3: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn qtimeout(
        arg1: *mut queue_t,
        func: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
        >,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: clock_t,
    ) -> timeout_id_t;
}
unsafe extern "C" {
    pub fn qbufcall(
        arg1: *mut queue_t,
        arg2: usize,
        arg3: uint_t,
        arg4: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
        >,
        arg5: *mut illumos_sys_hdrs::c_void,
    ) -> bufcall_id_t;
}
unsafe extern "C" {
    pub fn quntimeout(arg1: *mut queue_t, arg2: timeout_id_t) -> clock_t;
}
unsafe extern "C" {
    pub fn qunbufcall(arg1: *mut queue_t, arg2: bufcall_id_t);
}
unsafe extern "C" {
    pub fn strwakeq(arg1: *mut queue_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn struioget(
        arg1: *mut queue_t,
        arg2: *mut mblk_t,
        arg3: *mut struiod_t,
        arg4: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rwnext(
        arg1: *mut queue_t,
        arg2: *mut struiod_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn infonext(
        arg1: *mut queue_t,
        arg2: *mut infod_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn isuioq(arg1: *mut queue_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn create_putlocks(arg1: *mut queue_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn mp_cont_len(
        arg1: *mut mblk_t,
        arg2: *mut illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut nstrpush: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn inet_minor_create(
        arg1: *mut illumos_sys_hdrs::c_char,
        arg2: dev_t,
        arg3: dev_t,
        arg4: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn inet_minor_destroy(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn inet_minor_alloc(arg1: *mut illumos_sys_hdrs::c_void) -> dev_t;
}
unsafe extern "C" {
    pub fn inet_minor_free(arg1: *mut illumos_sys_hdrs::c_void, arg2: dev_t);
}
unsafe extern "C" {
    pub fn inet_freemsg(arg1: *mut mblk_t);
}
pub type ndgetf_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut queue_t,
        arg2: MBLKP,
        arg3: caddr_t,
        arg4: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int,
>;
pub type ndsetf_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut queue_t,
        arg2: MBLKP,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: caddr_t,
        arg5: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nde_s {
    pub nde_name: *mut illumos_sys_hdrs::c_char,
    pub nde_get_pfi: pfi_t,
    pub nde_set_pfi: pfi_t,
    pub nde_data: caddr_t,
}
pub type NDE = nde_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nd_s {
    pub nd_free_count: illumos_sys_hdrs::c_int,
    pub nd_size: illumos_sys_hdrs::c_int,
    pub nd_tbl: *mut NDE,
}
pub type ND = nd_s;
unsafe extern "C" {
    pub fn nd_load(
        arg1: *mut caddr_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: ndgetf_t,
        arg4: ndsetf_t,
        arg5: caddr_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn nd_unload(arg1: *mut caddr_t, arg2: *mut illumos_sys_hdrs::c_char);
}
unsafe extern "C" {
    pub fn nd_free(arg1: *mut caddr_t);
}
unsafe extern "C" {
    pub fn nd_getset(
        arg1: *mut queue_t,
        arg2: caddr_t,
        arg3: MBLKP,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn nd_get_default(
        arg1: *mut queue_t,
        arg2: MBLKP,
        arg3: caddr_t,
        arg4: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn nd_get_long(
        arg1: *mut queue_t,
        arg2: MBLKP,
        arg3: caddr_t,
        arg4: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn nd_get_names(
        arg1: *mut queue_t,
        arg2: MBLKP,
        arg3: caddr_t,
        arg4: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn nd_set_default(
        arg1: *mut queue_t,
        arg2: MBLKP,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: caddr_t,
        arg5: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn nd_set_long(
        arg1: *mut queue_t,
        arg2: MBLKP,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: caddr_t,
        arg5: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn atomic_inc_8(arg1: *mut u8);
}
unsafe extern "C" {
    pub fn atomic_inc_uchar(arg1: *mut uchar_t);
}
unsafe extern "C" {
    pub fn atomic_inc_16(arg1: *mut u16);
}
unsafe extern "C" {
    pub fn atomic_inc_ushort(arg1: *mut ushort_t);
}
unsafe extern "C" {
    pub fn atomic_inc_32(arg1: *mut u32);
}
unsafe extern "C" {
    pub fn atomic_inc_uint(arg1: *mut uint_t);
}
unsafe extern "C" {
    pub fn atomic_inc_ulong(arg1: *mut ulong_t);
}
unsafe extern "C" {
    pub fn atomic_inc_64(arg1: *mut u64);
}
unsafe extern "C" {
    pub fn atomic_dec_8(arg1: *mut u8);
}
unsafe extern "C" {
    pub fn atomic_dec_uchar(arg1: *mut uchar_t);
}
unsafe extern "C" {
    pub fn atomic_dec_16(arg1: *mut u16);
}
unsafe extern "C" {
    pub fn atomic_dec_ushort(arg1: *mut ushort_t);
}
unsafe extern "C" {
    pub fn atomic_dec_32(arg1: *mut u32);
}
unsafe extern "C" {
    pub fn atomic_dec_uint(arg1: *mut uint_t);
}
unsafe extern "C" {
    pub fn atomic_dec_ulong(arg1: *mut ulong_t);
}
unsafe extern "C" {
    pub fn atomic_dec_64(arg1: *mut u64);
}
unsafe extern "C" {
    pub fn atomic_add_8(arg1: *mut u8, arg2: i8);
}
unsafe extern "C" {
    pub fn atomic_add_char(arg1: *mut uchar_t, arg2: illumos_sys_hdrs::c_schar);
}
unsafe extern "C" {
    pub fn atomic_add_16(arg1: *mut u16, arg2: i16);
}
unsafe extern "C" {
    pub fn atomic_add_short(
        arg1: *mut ushort_t,
        arg2: illumos_sys_hdrs::c_short,
    );
}
unsafe extern "C" {
    pub fn atomic_add_32(arg1: *mut u32, arg2: i32);
}
unsafe extern "C" {
    pub fn atomic_add_int(arg1: *mut uint_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn atomic_add_ptr(arg1: *mut illumos_sys_hdrs::c_void, arg2: isize);
}
unsafe extern "C" {
    pub fn atomic_add_long(arg1: *mut ulong_t, arg2: illumos_sys_hdrs::c_long);
}
unsafe extern "C" {
    pub fn atomic_add_64(arg1: *mut u64, arg2: i64);
}
unsafe extern "C" {
    pub fn atomic_or_8(arg1: *mut u8, arg2: u8);
}
unsafe extern "C" {
    pub fn atomic_or_uchar(arg1: *mut uchar_t, arg2: uchar_t);
}
unsafe extern "C" {
    pub fn atomic_or_16(arg1: *mut u16, arg2: u16);
}
unsafe extern "C" {
    pub fn atomic_or_ushort(arg1: *mut ushort_t, arg2: ushort_t);
}
unsafe extern "C" {
    pub fn atomic_or_32(arg1: *mut u32, arg2: u32);
}
unsafe extern "C" {
    pub fn atomic_or_uint(arg1: *mut uint_t, arg2: uint_t);
}
unsafe extern "C" {
    pub fn atomic_or_ulong(arg1: *mut ulong_t, arg2: ulong_t);
}
unsafe extern "C" {
    pub fn atomic_or_64(arg1: *mut u64, arg2: u64);
}
unsafe extern "C" {
    pub fn atomic_and_8(arg1: *mut u8, arg2: u8);
}
unsafe extern "C" {
    pub fn atomic_and_uchar(arg1: *mut uchar_t, arg2: uchar_t);
}
unsafe extern "C" {
    pub fn atomic_and_16(arg1: *mut u16, arg2: u16);
}
unsafe extern "C" {
    pub fn atomic_and_ushort(arg1: *mut ushort_t, arg2: ushort_t);
}
unsafe extern "C" {
    pub fn atomic_and_32(arg1: *mut u32, arg2: u32);
}
unsafe extern "C" {
    pub fn atomic_and_uint(arg1: *mut uint_t, arg2: uint_t);
}
unsafe extern "C" {
    pub fn atomic_and_ulong(arg1: *mut ulong_t, arg2: ulong_t);
}
unsafe extern "C" {
    pub fn atomic_and_64(arg1: *mut u64, arg2: u64);
}
unsafe extern "C" {
    pub fn atomic_inc_8_nv(arg1: *mut u8) -> u8;
}
unsafe extern "C" {
    pub fn atomic_inc_uchar_nv(arg1: *mut uchar_t) -> uchar_t;
}
unsafe extern "C" {
    pub fn atomic_inc_16_nv(arg1: *mut u16) -> u16;
}
unsafe extern "C" {
    pub fn atomic_inc_ushort_nv(arg1: *mut ushort_t) -> ushort_t;
}
unsafe extern "C" {
    pub fn atomic_inc_32_nv(arg1: *mut u32) -> u32;
}
unsafe extern "C" {
    pub fn atomic_inc_uint_nv(arg1: *mut uint_t) -> uint_t;
}
unsafe extern "C" {
    pub fn atomic_inc_ulong_nv(arg1: *mut ulong_t) -> ulong_t;
}
unsafe extern "C" {
    pub fn atomic_inc_64_nv(arg1: *mut u64) -> u64;
}
unsafe extern "C" {
    pub fn atomic_dec_8_nv(arg1: *mut u8) -> u8;
}
unsafe extern "C" {
    pub fn atomic_dec_uchar_nv(arg1: *mut uchar_t) -> uchar_t;
}
unsafe extern "C" {
    pub fn atomic_dec_16_nv(arg1: *mut u16) -> u16;
}
unsafe extern "C" {
    pub fn atomic_dec_ushort_nv(arg1: *mut ushort_t) -> ushort_t;
}
unsafe extern "C" {
    pub fn atomic_dec_32_nv(arg1: *mut u32) -> u32;
}
unsafe extern "C" {
    pub fn atomic_dec_uint_nv(arg1: *mut uint_t) -> uint_t;
}
unsafe extern "C" {
    pub fn atomic_dec_ulong_nv(arg1: *mut ulong_t) -> ulong_t;
}
unsafe extern "C" {
    pub fn atomic_dec_64_nv(arg1: *mut u64) -> u64;
}
unsafe extern "C" {
    pub fn atomic_add_8_nv(arg1: *mut u8, arg2: i8) -> u8;
}
unsafe extern "C" {
    pub fn atomic_add_char_nv(
        arg1: *mut uchar_t,
        arg2: illumos_sys_hdrs::c_schar,
    ) -> uchar_t;
}
unsafe extern "C" {
    pub fn atomic_add_16_nv(arg1: *mut u16, arg2: i16) -> u16;
}
unsafe extern "C" {
    pub fn atomic_add_short_nv(
        arg1: *mut ushort_t,
        arg2: illumos_sys_hdrs::c_short,
    ) -> ushort_t;
}
unsafe extern "C" {
    pub fn atomic_add_32_nv(arg1: *mut u32, arg2: i32) -> u32;
}
unsafe extern "C" {
    pub fn atomic_add_int_nv(
        arg1: *mut uint_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> uint_t;
}
unsafe extern "C" {
    pub fn atomic_add_ptr_nv(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: isize,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn atomic_add_long_nv(
        arg1: *mut ulong_t,
        arg2: illumos_sys_hdrs::c_long,
    ) -> ulong_t;
}
unsafe extern "C" {
    pub fn atomic_add_64_nv(arg1: *mut u64, arg2: i64) -> u64;
}
unsafe extern "C" {
    pub fn atomic_or_8_nv(arg1: *mut u8, arg2: u8) -> u8;
}
unsafe extern "C" {
    pub fn atomic_or_uchar_nv(arg1: *mut uchar_t, arg2: uchar_t) -> uchar_t;
}
unsafe extern "C" {
    pub fn atomic_or_16_nv(arg1: *mut u16, arg2: u16) -> u16;
}
unsafe extern "C" {
    pub fn atomic_or_ushort_nv(arg1: *mut ushort_t, arg2: ushort_t)
        -> ushort_t;
}
unsafe extern "C" {
    pub fn atomic_or_32_nv(arg1: *mut u32, arg2: u32) -> u32;
}
unsafe extern "C" {
    pub fn atomic_or_uint_nv(arg1: *mut uint_t, arg2: uint_t) -> uint_t;
}
unsafe extern "C" {
    pub fn atomic_or_ulong_nv(arg1: *mut ulong_t, arg2: ulong_t) -> ulong_t;
}
unsafe extern "C" {
    pub fn atomic_or_64_nv(arg1: *mut u64, arg2: u64) -> u64;
}
unsafe extern "C" {
    pub fn atomic_and_8_nv(arg1: *mut u8, arg2: u8) -> u8;
}
unsafe extern "C" {
    pub fn atomic_and_uchar_nv(arg1: *mut uchar_t, arg2: uchar_t) -> uchar_t;
}
unsafe extern "C" {
    pub fn atomic_and_16_nv(arg1: *mut u16, arg2: u16) -> u16;
}
unsafe extern "C" {
    pub fn atomic_and_ushort_nv(
        arg1: *mut ushort_t,
        arg2: ushort_t,
    ) -> ushort_t;
}
unsafe extern "C" {
    pub fn atomic_and_32_nv(arg1: *mut u32, arg2: u32) -> u32;
}
unsafe extern "C" {
    pub fn atomic_and_uint_nv(arg1: *mut uint_t, arg2: uint_t) -> uint_t;
}
unsafe extern "C" {
    pub fn atomic_and_ulong_nv(arg1: *mut ulong_t, arg2: ulong_t) -> ulong_t;
}
unsafe extern "C" {
    pub fn atomic_and_64_nv(arg1: *mut u64, arg2: u64) -> u64;
}
unsafe extern "C" {
    pub fn atomic_cas_8(arg1: *mut u8, arg2: u8, arg3: u8) -> u8;
}
unsafe extern "C" {
    pub fn atomic_cas_uchar(
        arg1: *mut uchar_t,
        arg2: uchar_t,
        arg3: uchar_t,
    ) -> uchar_t;
}
unsafe extern "C" {
    pub fn atomic_cas_16(arg1: *mut u16, arg2: u16, arg3: u16) -> u16;
}
unsafe extern "C" {
    pub fn atomic_cas_ushort(
        arg1: *mut ushort_t,
        arg2: ushort_t,
        arg3: ushort_t,
    ) -> ushort_t;
}
unsafe extern "C" {
    pub fn atomic_cas_32(arg1: *mut u32, arg2: u32, arg3: u32) -> u32;
}
unsafe extern "C" {
    pub fn atomic_cas_uint(
        arg1: *mut uint_t,
        arg2: uint_t,
        arg3: uint_t,
    ) -> uint_t;
}
unsafe extern "C" {
    pub fn atomic_cas_ptr(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: *mut illumos_sys_hdrs::c_void,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn atomic_cas_ulong(
        arg1: *mut ulong_t,
        arg2: ulong_t,
        arg3: ulong_t,
    ) -> ulong_t;
}
unsafe extern "C" {
    pub fn atomic_cas_64(arg1: *mut u64, arg2: u64, arg3: u64) -> u64;
}
unsafe extern "C" {
    pub fn atomic_swap_8(arg1: *mut u8, arg2: u8) -> u8;
}
unsafe extern "C" {
    pub fn atomic_swap_uchar(arg1: *mut uchar_t, arg2: uchar_t) -> uchar_t;
}
unsafe extern "C" {
    pub fn atomic_swap_16(arg1: *mut u16, arg2: u16) -> u16;
}
unsafe extern "C" {
    pub fn atomic_swap_ushort(arg1: *mut ushort_t, arg2: ushort_t) -> ushort_t;
}
unsafe extern "C" {
    pub fn atomic_swap_32(arg1: *mut u32, arg2: u32) -> u32;
}
unsafe extern "C" {
    pub fn atomic_swap_uint(arg1: *mut uint_t, arg2: uint_t) -> uint_t;
}
unsafe extern "C" {
    pub fn atomic_swap_ptr(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn atomic_swap_ulong(arg1: *mut ulong_t, arg2: ulong_t) -> ulong_t;
}
unsafe extern "C" {
    pub fn atomic_swap_64(arg1: *mut u64, arg2: u64) -> u64;
}
unsafe extern "C" {
    pub fn atomic_set_long_excl(
        arg1: *mut ulong_t,
        arg2: uint_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn atomic_clear_long_excl(
        arg1: *mut ulong_t,
        arg2: uint_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn membar_enter();
}
unsafe extern "C" {
    pub fn membar_exit();
}
unsafe extern "C" {
    pub fn membar_producer();
}
unsafe extern "C" {
    pub fn membar_consumer();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct so_snd_bufinfo {
    pub sbi_wroff: ushort_t,
    pub sbi_maxblk: isize,
    pub sbi_maxpsz: isize,
    pub sbi_tail: ushort_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fil_info {
    pub fi_flags: illumos_sys_hdrs::c_int,
    pub fi_pos: illumos_sys_hdrs::c_int,
    pub fi_name: [illumos_sys_hdrs::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: illumos_sys_hdrs::c_int,
    pub l_linger: illumos_sys_hdrs::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut illumos_sys_hdrs::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: illumos_sys_hdrs::c_int,
    pub msg_control: *mut illumos_sys_hdrs::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: illumos_sys_hdrs::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct omsghdr {
    pub msg_name: *mut illumos_sys_hdrs::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: illumos_sys_hdrs::c_int,
    pub msg_accrights: caddr_t,
    pub msg_accrightslen: illumos_sys_hdrs::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: illumos_sys_hdrs::c_int,
    pub cmsg_type: illumos_sys_hdrs::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifnet {
    pub if_name: *mut illumos_sys_hdrs::c_char,
    pub if_unit: illumos_sys_hdrs::c_short,
    pub if_mtu: illumos_sys_hdrs::c_short,
    pub if_flags: illumos_sys_hdrs::c_short,
    pub if_timer: illumos_sys_hdrs::c_short,
    pub if_promisc: ushort_t,
    pub if_metric: illumos_sys_hdrs::c_int,
    pub if_addrlist: *mut ifaddr,
    pub if_snd: ifnet_ifqueue,
    pub if_init: ::core::option::Option<
        unsafe extern "C" fn() -> illumos_sys_hdrs::c_int,
    >,
    pub if_output: ::core::option::Option<
        unsafe extern "C" fn() -> illumos_sys_hdrs::c_int,
    >,
    pub if_ioctl: ::core::option::Option<
        unsafe extern "C" fn() -> illumos_sys_hdrs::c_int,
    >,
    pub if_reset: ::core::option::Option<
        unsafe extern "C" fn() -> illumos_sys_hdrs::c_int,
    >,
    pub if_watchdog: ::core::option::Option<
        unsafe extern "C" fn() -> illumos_sys_hdrs::c_int,
    >,
    pub if_ipackets: illumos_sys_hdrs::c_int,
    pub if_ierrors: illumos_sys_hdrs::c_int,
    pub if_opackets: illumos_sys_hdrs::c_int,
    pub if_oerrors: illumos_sys_hdrs::c_int,
    pub if_collisions: illumos_sys_hdrs::c_int,
    pub if_next: *mut ifnet,
    pub if_upper: *mut ifnet,
    pub if_lower: *mut ifnet,
    pub if_input: ::core::option::Option<
        unsafe extern "C" fn() -> illumos_sys_hdrs::c_int,
    >,
    pub if_ctlin: ::core::option::Option<
        unsafe extern "C" fn() -> illumos_sys_hdrs::c_int,
    >,
    pub if_ctlout: ::core::option::Option<
        unsafe extern "C" fn() -> illumos_sys_hdrs::c_int,
    >,
    pub if_memmap: *mut map,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifnet_ifqueue {
    pub ifq_head: *mut mbuf,
    pub ifq_tail: *mut mbuf,
    pub ifq_len: illumos_sys_hdrs::c_int,
    pub ifq_maxlen: illumos_sys_hdrs::c_int,
    pub ifq_drops: illumos_sys_hdrs::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifaddr {
    pub ifa_addr: sockaddr,
    pub ifa_ifu: ifaddr__bindgen_ty_1,
    pub ifa_ifp: *mut ifnet,
    pub ifa_next: *mut ifaddr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifaddr__bindgen_ty_1 {
    pub ifu_broadaddr: sockaddr,
    pub ifu_dstaddr: sockaddr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lif_nd_req {
    pub lnr_addr: sockaddr_storage,
    pub lnr_state_create: u8,
    pub lnr_state_same_lla: u8,
    pub lnr_state_diff_lla: u8,
    pub lnr_hdw_len: illumos_sys_hdrs::c_int,
    pub lnr_flags: illumos_sys_hdrs::c_int,
    pub lnr_pad0: illumos_sys_hdrs::c_int,
    pub lnr_hdw_addr: [illumos_sys_hdrs::c_char; 64usize],
}
pub type lif_nd_req_t = lif_nd_req;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lif_ifinfo_req {
    pub lir_maxhops: u8,
    pub lir_reachtime: u32,
    pub lir_reachretrans: u32,
    pub lir_maxmtu: u32,
}
pub type lif_ifinfo_req_t = lif_ifinfo_req;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lifreq {
    pub lifr_name: [illumos_sys_hdrs::c_char; 32usize],
    pub lifr_lifru1: lifreq__bindgen_ty_1,
    pub lifr_type: uint_t,
    pub lifr_lifru: lifreq__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lifreq__bindgen_ty_1 {
    pub lifru_addrlen: illumos_sys_hdrs::c_int,
    pub lifru_ppa: uint_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lifreq__bindgen_ty_2 {
    pub lifru_addr: sockaddr_storage,
    pub lifru_dstaddr: sockaddr_storage,
    pub lifru_broadaddr: sockaddr_storage,
    pub lifru_token: sockaddr_storage,
    pub lifru_subnet: sockaddr_storage,
    pub lifru_index: illumos_sys_hdrs::c_int,
    pub lifru_flags: u64,
    pub lifru_metric: illumos_sys_hdrs::c_int,
    pub lifru_mtu: uint_t,
    pub lif_muxid: [illumos_sys_hdrs::c_int; 2usize],
    pub lifru_nd_req: lif_nd_req,
    pub lifru_ifinfo_req: lif_ifinfo_req,
    pub lifru_groupname: [illumos_sys_hdrs::c_char; 32usize],
    pub lifru_binding: [illumos_sys_hdrs::c_char; 32usize],
    pub lifru_zoneid: zoneid_t,
    pub lifru_dadstate: uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sioc_addrreq {
    pub sa_addr: sockaddr_storage,
    pub sa_res: illumos_sys_hdrs::c_int,
    pub sa_pad: illumos_sys_hdrs::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sioc_lsg_req {
    pub slr_src: sockaddr_storage,
    pub slr_grp: sockaddr_storage,
    pub slr_pktcnt: uint_t,
    pub slr_bytecnt: uint_t,
    pub slr_wrong_if: uint_t,
    pub slr_pad: uint_t,
}
pub const glif_dad_state_t_DAD_IN_PROGRESS: glif_dad_state_t = 1;
pub const glif_dad_state_t_DAD_DONE: glif_dad_state_t = 2;
pub type glif_dad_state_t = illumos_sys_hdrs::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifreq {
    pub ifr_name: [illumos_sys_hdrs::c_char; 16usize],
    pub ifr_ifru: ifreq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifreq__bindgen_ty_1 {
    pub ifru_addr: sockaddr,
    pub ifru_dstaddr: sockaddr,
    pub ifru_oname: [illumos_sys_hdrs::c_char; 16usize],
    pub ifru_broadaddr: sockaddr,
    pub ifru_index: illumos_sys_hdrs::c_int,
    pub ifru_mtu: uint_t,
    pub ifru_flags: illumos_sys_hdrs::c_short,
    pub ifru_metric: illumos_sys_hdrs::c_int,
    pub ifru_data: [illumos_sys_hdrs::c_char; 1usize],
    pub ifru_enaddr: [illumos_sys_hdrs::c_char; 6usize],
    pub if_muxid: [illumos_sys_hdrs::c_int; 2usize],
    pub ifru_ppaflags: ifreq__bindgen_ty_1_ifr_ppaflags,
    pub ifru_dnld_req: ifreq__bindgen_ty_1_ifr_dnld_reqs,
    pub ifru_fddi_stat: ifreq__bindgen_ty_1_ifr_fddi_stats,
    pub ifru_netmapent: ifreq__bindgen_ty_1_ifr_netmapents,
    pub ifru_fddi_gstruct: ifreq__bindgen_ty_1_ifr_fddi_gen_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifreq__bindgen_ty_1_ifr_ppaflags {
    pub ifrup_flags: illumos_sys_hdrs::c_short,
    pub ifrup_filler: illumos_sys_hdrs::c_short,
    pub ifrup_ppa: uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifreq__bindgen_ty_1_ifr_dnld_reqs {
    pub v_addr: u32,
    pub m_addr: u32,
    pub ex_addr: u32,
    pub size: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifreq__bindgen_ty_1_ifr_fddi_stats {
    pub stat_size: u32,
    pub fddi_stats: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifreq__bindgen_ty_1_ifr_netmapents {
    pub map_ent_size: u32,
    pub entry_number: u32,
    pub fddi_map_ent: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifreq__bindgen_ty_1_ifr_fddi_gen_struct {
    pub ifru_fddi_gioctl: u32,
    pub ifru_fddi_gaddr: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lifnum {
    pub lifn_family: sa_family_t,
    pub lifn_flags: illumos_sys_hdrs::c_int,
    pub lifn_count: illumos_sys_hdrs::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lifconf {
    pub lifc_family: sa_family_t,
    pub lifc_flags: illumos_sys_hdrs::c_int,
    pub lifc_len: illumos_sys_hdrs::c_int,
    pub lifc_lifcu: lifconf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lifconf__bindgen_ty_1 {
    pub lifcu_buf: caddr_t,
    pub lifcu_req: *mut lifreq,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lifsrcof {
    pub lifs_ifindex: uint_t,
    pub lifs_maxlen: usize,
    pub lifs_len: usize,
    pub lifs_lifsu: lifsrcof__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lifsrcof__bindgen_ty_1 {
    pub lifsu_buf: caddr_t,
    pub lifsu_req: *mut lifreq,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lifgroupinfo {
    pub gi_grname: [illumos_sys_hdrs::c_char; 32usize],
    pub gi_grifname: [illumos_sys_hdrs::c_char; 32usize],
    pub gi_m4ifname: [illumos_sys_hdrs::c_char; 32usize],
    pub gi_m6ifname: [illumos_sys_hdrs::c_char; 32usize],
    pub gi_bcifname: [illumos_sys_hdrs::c_char; 32usize],
    pub gi_v4: boolean_t,
    pub gi_v6: boolean_t,
    pub gi_nv4: uint_t,
    pub gi_nv6: uint_t,
    pub gi_mactype: uint_t,
}
pub type lifgroupinfo_t = lifgroupinfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifconf {
    pub ifc_len: illumos_sys_hdrs::c_int,
    pub ifc_ifcu: ifconf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifconf__bindgen_ty_1 {
    pub ifcu_buf: caddr_t,
    pub ifcu_req: *mut ifreq,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_data {
    pub ifi_type: uchar_t,
    pub ifi_addrlen: uchar_t,
    pub ifi_hdrlen: uchar_t,
    pub ifi_mtu: uint_t,
    pub ifi_metric: uint_t,
    pub ifi_baudrate: uint_t,
    pub ifi_ipackets: uint_t,
    pub ifi_ierrors: uint_t,
    pub ifi_opackets: uint_t,
    pub ifi_oerrors: uint_t,
    pub ifi_collisions: uint_t,
    pub ifi_ibytes: uint_t,
    pub ifi_obytes: uint_t,
    pub ifi_imcasts: uint_t,
    pub ifi_omcasts: uint_t,
    pub ifi_iqdrops: uint_t,
    pub ifi_noproto: uint_t,
    pub ifi_lastchange: timeval32,
}
pub type if_data_t = if_data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_msghdr {
    pub ifm_msglen: ushort_t,
    pub ifm_version: uchar_t,
    pub ifm_type: uchar_t,
    pub ifm_addrs: illumos_sys_hdrs::c_int,
    pub ifm_flags: illumos_sys_hdrs::c_int,
    pub ifm_index: ushort_t,
    pub ifm_data: if_data,
}
pub type if_msghdr_t = if_msghdr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifa_msghdr {
    pub ifam_msglen: ushort_t,
    pub ifam_version: uchar_t,
    pub ifam_type: uchar_t,
    pub ifam_addrs: illumos_sys_hdrs::c_int,
    pub ifam_flags: illumos_sys_hdrs::c_int,
    pub ifam_index: ushort_t,
    pub ifam_metric: illumos_sys_hdrs::c_int,
}
pub type ifa_msghdr_t = ifa_msghdr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_nameindex {
    pub if_index: illumos_sys_hdrs::c_uint,
    pub if_name: *mut illumos_sys_hdrs::c_char,
}
unsafe extern "C" {
    pub fn if_nametoindex(
        arg1: *const illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_uint;
}
unsafe extern "C" {
    pub fn if_indextoname(
        arg1: illumos_sys_hdrs::c_uint,
        arg2: *mut illumos_sys_hdrs::c_char,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn if_nameindex() -> *mut if_nameindex;
}
unsafe extern "C" {
    pub fn if_freenameindex(arg1: *mut if_nameindex);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct igmp {
    pub igmp_type: uchar_t,
    pub igmp_code: uchar_t,
    pub igmp_cksum: ushort_t,
    pub igmp_group: in_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct igmp3r {
    pub igmp3r_type: uchar_t,
    pub igmp3r_code: uchar_t,
    pub igmp3r_cksum: ushort_t,
    pub igmp3r_res: ushort_t,
    pub igmp3r_numrec: ushort_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct grphdr {
    pub grphdr_type: uchar_t,
    pub grphdr_auxlen: uchar_t,
    pub grphdr_numsrc: ushort_t,
    pub grphdr_group: in_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct igmp3q {
    pub igmp3q_type: uchar_t,
    pub igmp3q_mxrt: uchar_t,
    pub igmp3q_cksum: ushort_t,
    pub igmp3q_group: in_addr,
    pub igmp3q_res: ushort_t,
    pub igmp3q_numsrc: ushort_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct igmp_s {
    pub igmp_type: u8,
    pub igmp_code: u8,
    pub igmp_cksum: [u8; 2usize],
    pub igmp_group: [u8; 4usize],
}
pub type igmp_t = igmp_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct igmpa_s {
    pub igmpa_type: u8,
    pub igmpa_code: u8,
    pub igmpa_cksum: u16,
    pub igmpa_group: ipaddr_t,
}
pub type igmpa_t = igmpa_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct igmp3ra_s {
    pub igmp3ra_type: u8,
    pub igmp3ra_res: u8,
    pub igmp3ra_cksum: u16,
    pub igmp3ra_res1: u16,
    pub igmp3ra_numrec: u16,
}
pub type igmp3ra_t = igmp3ra_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grphdra_s {
    pub grphdra_type: u8,
    pub grphdra_auxlen: u8,
    pub grphdra_numsrc: u16,
    pub grphdra_group: ipaddr_t,
}
pub type grphdra_t = grphdra_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct igmp3qa_s {
    pub igmp3qa_type: u8,
    pub igmp3qa_mxrc: u8,
    pub igmp3qa_cksum: u16,
    pub igmp3qa_group: ipaddr_t,
    pub igmp3qa_sqrv: u8,
    pub igmp3qa_qqic: u8,
    pub igmp3qa_numsrc: u16,
}
pub type igmp3qa_t = igmp3qa_s;
pub const mcast_record_t_MODE_IS_INCLUDE: mcast_record_t = 1;
pub const mcast_record_t_MODE_IS_EXCLUDE: mcast_record_t = 2;
pub const mcast_record_t_CHANGE_TO_INCLUDE: mcast_record_t = 3;
pub const mcast_record_t_CHANGE_TO_EXCLUDE: mcast_record_t = 4;
pub const mcast_record_t_ALLOW_NEW_SOURCES: mcast_record_t = 5;
pub const mcast_record_t_BLOCK_OLD_SOURCES: mcast_record_t = 6;
pub type mcast_record_t = illumos_sys_hdrs::c_uint;
pub type hook_data_t = usize;
pub type hook_event_token_t = *mut hook_event_int;
pub type hook_token_t = *mut hook_int;
pub type hook_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: hook_event_token_t,
        arg2: hook_data_t,
        arg3: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int,
>;
pub const hook_notify_cmd_e_HN_NONE: hook_notify_cmd_e = 0;
pub const hook_notify_cmd_e_HN_REGISTER: hook_notify_cmd_e = 1;
pub const hook_notify_cmd_e_HN_UNREGISTER: hook_notify_cmd_e = 2;
pub type hook_notify_cmd_e = illumos_sys_hdrs::c_uint;
pub use self::hook_notify_cmd_e as hook_notify_cmd_t;
pub const hook_hint_e_HH_NONE: hook_hint_e = 0;
pub const hook_hint_e_HH_FIRST: hook_hint_e = 1;
pub const hook_hint_e_HH_LAST: hook_hint_e = 2;
pub const hook_hint_e_HH_BEFORE: hook_hint_e = 3;
pub const hook_hint_e_HH_AFTER: hook_hint_e = 4;
pub type hook_hint_e = illumos_sys_hdrs::c_uint;
pub use self::hook_hint_e as hook_hint_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_s {
    pub h_version: illumos_sys_hdrs::c_int,
    pub h_func: hook_func_t,
    pub h_name: *mut illumos_sys_hdrs::c_char,
    pub h_flags: uint_t,
    pub h_hint: hook_hint_t,
    pub h_hintvalue: usize,
    pub h_arg: *mut illumos_sys_hdrs::c_void,
}
pub type hook_t = hook_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_family_s {
    pub hf_version: illumos_sys_hdrs::c_int,
    pub hf_name: *mut illumos_sys_hdrs::c_char,
}
pub type hook_family_t = hook_family_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_event_s {
    pub he_version: illumos_sys_hdrs::c_int,
    pub he_name: *mut illumos_sys_hdrs::c_char,
    pub he_flags: illumos_sys_hdrs::c_int,
    pub he_interested: boolean_t,
}
pub type hook_event_t = hook_event_s;
pub type hook_notify_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: hook_notify_cmd_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: *const illumos_sys_hdrs::c_char,
        arg4: *const illumos_sys_hdrs::c_char,
        arg5: *const illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_int,
>;
unsafe extern "C" {
    pub fn hook_alloc(version: illumos_sys_hdrs::c_int) -> *mut hook_t;
}
unsafe extern "C" {
    pub fn hook_free(arg1: *mut hook_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _condvar_impl {
    pub cv_waiters: ushort_t,
}
pub type condvar_impl_t = _condvar_impl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvwaitlock_s {
    pub cvw_lock: kmutex_t,
    pub cvw_waiter: kcondvar_t,
    pub cvw_refcnt: illumos_sys_hdrs::c_int,
}
pub type cvwaitlock_t = cvwaitlock_s;
pub const fwflag_e_FWF_NONE: fwflag_e = 0;
pub const fwflag_e_FWF_DESTROY_ACTIVE: fwflag_e = 1;
pub const fwflag_e_FWF_ADD_ACTIVE: fwflag_e = 4;
pub const fwflag_e_FWF_DEL_ACTIVE: fwflag_e = 8;
pub const fwflag_e_FWF_DESTROY_WANTED: fwflag_e = 16;
pub const fwflag_e_FWF_ADD_WANTED: fwflag_e = 64;
pub const fwflag_e_FWF_DEL_WANTED: fwflag_e = 128;
pub const fwflag_e_FWF_NOT_READY: fwflag_e = 256;
pub type fwflag_e = illumos_sys_hdrs::c_uint;
pub use self::fwflag_e as fwflag_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flagwait_s {
    pub fw_cv: kcondvar_t,
    pub fw_lock: kmutex_t,
    pub fw_flags: u32,
    pub fw_owner: *mut cvwaitlock_t,
}
pub type flagwait_t = flagwait_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hook_hook_kstat {
    pub hook_version: kstat_named_t,
    pub hook_flags: kstat_named_t,
    pub hook_hint: kstat_named_t,
    pub hook_hintvalue: kstat_named_t,
    pub hook_position: kstat_named_t,
    pub hook_hits: kstat_named_t,
}
pub type hook_hook_kstat_t = hook_hook_kstat;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hook_int {
    pub hi_entry: hook_int__bindgen_ty_1,
    pub hi_hook: hook_t,
    pub hi_kstats: hook_hook_kstat_t,
    pub hi_kstatp: *mut kstat_t,
    pub hi_ksname: *mut illumos_sys_hdrs::c_char,
    pub hi_notify_lock: cvwaitlock_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_int__bindgen_ty_1 {
    pub tqe_next: *mut hook_int,
    pub tqe_prev: *mut *mut hook_int,
}
pub type hook_int_t = hook_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_int_head {
    pub tqh_first: *mut hook_int,
    pub tqh_last: *mut *mut hook_int,
}
pub type hook_int_head_t = hook_int_head;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_notify {
    pub hn_entry: hook_notify__bindgen_ty_1,
    pub hn_func: hook_notify_fn_t,
    pub hn_arg: *mut illumos_sys_hdrs::c_void,
    pub hn_flags: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_notify__bindgen_ty_1 {
    pub tqe_next: *mut hook_notify,
    pub tqe_prev: *mut *mut hook_notify,
}
pub type hook_notify_t = hook_notify;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_notify_head {
    pub tqh_first: *mut hook_notify,
    pub tqh_last: *mut *mut hook_notify,
}
pub type hook_notify_head_t = hook_notify_head;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hook_event_kstat {
    pub hooks_added: kstat_named_t,
    pub hooks_removed: kstat_named_t,
    pub events: kstat_named_t,
}
pub type hook_event_kstat_t = hook_event_kstat;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hook_event_int {
    pub hei_lock: cvwaitlock_t,
    pub hei_entry: hook_event_int__bindgen_ty_1,
    pub hei_event: *mut hook_event_t,
    pub hei_head: hook_int_head_t,
    pub hei_kstatp: *mut kstat_t,
    pub hei_kstats: hook_event_kstat_t,
    pub hei_nhead: hook_notify_head_t,
    pub hei_waiter: flagwait_t,
    pub hei_condemned: boolean_t,
    pub hei_shutdown: boolean_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_event_int__bindgen_ty_1 {
    pub sle_next: *mut hook_event_int,
}
pub type hook_event_int_t = hook_event_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_event_int_head {
    pub slh_first: *mut hook_event_int,
}
pub type hook_event_int_head_t = hook_event_int_head;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_family_int {
    pub hfi_lock: cvwaitlock_t,
    pub hfi_entry: hook_family_int__bindgen_ty_1,
    pub hfi_head: hook_event_int_head_t,
    pub hfi_family: hook_family_t,
    pub hfi_kstat: *mut kstat_t,
    pub hfi_stack: *mut hook_stack,
    pub hfi_nhead: hook_notify_head_t,
    pub hfi_waiter: flagwait_t,
    pub hfi_condemned: boolean_t,
    pub hfi_shutdown: boolean_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_family_int__bindgen_ty_1 {
    pub sle_next: *mut hook_family_int,
}
pub type hook_family_int_t = hook_family_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_family_int_head {
    pub slh_first: *mut hook_family_int,
}
pub type hook_family_int_head_t = hook_family_int_head;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_stack {
    pub hks_lock: cvwaitlock_t,
    pub hks_entry: hook_stack__bindgen_ty_1,
    pub hks_familylist: hook_family_int_head_t,
    pub hks_netstack: *mut netstack_t,
    pub hks_netstackid: netstackid_t,
    pub hks_nhead: hook_notify_head_t,
    pub hks_shutdown: illumos_sys_hdrs::c_int,
    pub hks_waiter: flagwait_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_stack__bindgen_ty_1 {
    pub sle_next: *mut hook_stack,
}
pub type hook_stack_t = hook_stack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_stack_head {
    pub slh_first: *mut hook_stack,
}
pub type hook_stack_head_t = hook_stack_head;
unsafe extern "C" {
    pub fn hook_run(
        arg1: *mut hook_family_int_t,
        arg2: hook_event_token_t,
        arg3: hook_data_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn hook_register(
        arg1: *mut hook_family_int_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: *mut hook_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn hook_unregister(
        arg1: *mut hook_family_int_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: *mut hook_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn hook_event_add(
        arg1: *mut hook_family_int_t,
        arg2: *mut hook_event_t,
    ) -> *mut hook_event_int_t;
}
unsafe extern "C" {
    pub fn hook_event_notify_register(
        arg1: *mut hook_family_int_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: hook_notify_fn_t,
        arg4: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn hook_event_notify_unregister(
        arg1: *mut hook_family_int_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: hook_notify_fn_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn hook_event_remove(
        arg1: *mut hook_family_int_t,
        arg2: *mut hook_event_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn hook_event_shutdown(
        arg1: *mut hook_family_int_t,
        arg2: *mut hook_event_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn hook_family_add(
        arg1: *mut hook_family_t,
        arg2: *mut hook_stack_t,
        arg3: *mut *mut illumos_sys_hdrs::c_void,
    ) -> *mut hook_family_int_t;
}
unsafe extern "C" {
    pub fn hook_family_notify_register(
        arg1: *mut hook_family_int_t,
        arg2: hook_notify_fn_t,
        arg3: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn hook_family_notify_unregister(
        arg1: *mut hook_family_int_t,
        arg2: hook_notify_fn_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn hook_family_remove(
        arg1: *mut hook_family_int_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn hook_family_shutdown(
        arg1: *mut hook_family_int_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn hook_stack_notify_register(
        arg1: netstackid_t,
        arg2: hook_notify_fn_t,
        arg3: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn hook_stack_notify_unregister(
        arg1: netstackid_t,
        arg2: hook_notify_fn_t,
    ) -> illumos_sys_hdrs::c_int;
}
pub type phy_if_t = usize;
pub type lif_if_t = isize;
pub type net_ifdata_t = usize;
pub type netid_t = id_t;
pub const net_ifaddr_NA_ADDRESS: net_ifaddr = 1;
pub const net_ifaddr_NA_PEER: net_ifaddr = 2;
pub const net_ifaddr_NA_BROADCAST: net_ifaddr = 3;
pub const net_ifaddr_NA_NETMASK: net_ifaddr = 4;
pub type net_ifaddr = illumos_sys_hdrs::c_uint;
pub use self::net_ifaddr as net_ifaddr_t;
pub const inject_NI_QUEUE_IN: inject = 1;
pub const inject_NI_QUEUE_OUT: inject = 2;
pub const inject_NI_DIRECT_OUT: inject = 3;
pub type inject = illumos_sys_hdrs::c_uint;
pub use self::inject as inject_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_inject {
    pub ni_version: illumos_sys_hdrs::c_int,
    pub ni_netid: netid_t,
    pub ni_packet: *mut msgb,
    pub ni_addr: sockaddr_storage,
    pub ni_physical: phy_if_t,
}
pub type net_inject_t = net_inject;
pub type net_handle_t = *mut net_data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_protocol_s {
    pub netp_version: illumos_sys_hdrs::c_int,
    pub netp_name: *mut illumos_sys_hdrs::c_char,
    pub netp_getifname: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: net_handle_t,
            arg2: phy_if_t,
            arg3: *mut illumos_sys_hdrs::c_char,
            arg4: usize,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub netp_getmtu: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: net_handle_t,
            arg2: phy_if_t,
            arg3: lif_if_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub netp_getpmtuenabled: ::core::option::Option<
        unsafe extern "C" fn(arg1: net_handle_t) -> illumos_sys_hdrs::c_int,
    >,
    pub netp_getlifaddr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: net_handle_t,
            arg2: phy_if_t,
            arg3: lif_if_t,
            arg4: usize,
            arg5: *mut net_ifaddr_t,
            arg6: *mut illumos_sys_hdrs::c_void,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub neti_getlifzone: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: net_handle_t,
            arg2: phy_if_t,
            arg3: lif_if_t,
            arg4: *mut zoneid_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub neti_getlifflags: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: net_handle_t,
            arg2: phy_if_t,
            arg3: lif_if_t,
            arg4: *mut u64,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub netp_phygetnext: ::core::option::Option<
        unsafe extern "C" fn(arg1: net_handle_t, arg2: phy_if_t) -> phy_if_t,
    >,
    pub netp_phylookup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: net_handle_t,
            arg2: *const illumos_sys_hdrs::c_char,
        ) -> phy_if_t,
    >,
    pub netp_lifgetnext: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: net_handle_t,
            arg2: phy_if_t,
            arg3: lif_if_t,
        ) -> lif_if_t,
    >,
    pub netp_inject: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: net_handle_t,
            arg2: inject_t,
            arg3: *mut net_inject_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub netp_routeto: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: net_handle_t,
            arg2: *mut sockaddr,
            arg3: *mut sockaddr,
        ) -> phy_if_t,
    >,
    pub netp_ispartialchecksum: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: net_handle_t,
            arg2: *mut msgb,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub netp_isvalidchecksum: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: net_handle_t,
            arg2: *mut msgb,
        ) -> illumos_sys_hdrs::c_int,
    >,
}
pub type net_protocol_t = net_protocol_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_data {
    pub netd_list: net_data__bindgen_ty_1,
    pub netd_info: net_protocol_t,
    pub netd_refcnt: illumos_sys_hdrs::c_int,
    pub netd_hooks: *mut hook_family_int_t,
    pub netd_stack: *mut neti_stack_s,
    pub netd_condemned: illumos_sys_hdrs::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_data__bindgen_ty_1 {
    pub le_next: *mut net_data,
    pub le_prev: *mut *mut net_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct injection_s {
    pub inj_data: net_inject_t,
    pub inj_isv6: boolean_t,
    pub inj_ptr: *mut illumos_sys_hdrs::c_void,
}
pub type injection_t = injection_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_instance_s {
    pub nin_version: illumos_sys_hdrs::c_int,
    pub nin_name: *mut illumos_sys_hdrs::c_char,
    pub nin_create: ::core::option::Option<
        unsafe extern "C" fn(arg1: netid_t) -> *mut illumos_sys_hdrs::c_void,
    >,
    pub nin_destroy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: netid_t,
            arg2: *mut illumos_sys_hdrs::c_void,
        ),
    >,
    pub nin_shutdown: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: netid_t,
            arg2: *mut illumos_sys_hdrs::c_void,
        ),
    >,
}
pub type net_instance_t = net_instance_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_instance_int_s {
    pub nini_next: net_instance_int_s__bindgen_ty_1,
    pub nini_ref: uint_t,
    pub nini_created: *mut illumos_sys_hdrs::c_void,
    pub nini_parent: *mut net_instance_int_s,
    pub nini_instance: *mut net_instance_t,
    pub nini_notify: hook_notify_t,
    pub nini_flags: u32,
    pub nini_cv: kcondvar_t,
    pub nini_condemned: boolean_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_instance_int_s__bindgen_ty_1 {
    pub le_next: *mut net_instance_int_s,
    pub le_prev: *mut *mut net_instance_int_s,
}
pub type net_instance_int_t = net_instance_int_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nini_head_s {
    pub lh_first: *mut net_instance_int_s,
}
pub type nini_head_t = nini_head_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct neti_stack_s {
    pub nts_lock: kmutex_t,
    pub nts_next: neti_stack_s__bindgen_ty_1,
    pub nts_id: netid_t,
    pub nts_zoneid: zoneid_t,
    pub nts_stackid: netstackid_t,
    pub nts_netstack: *mut netstack_t,
    pub nts_instances: nini_head_t,
    pub nts_flags: u32,
    pub nts_cv: kcondvar_t,
    pub nts_netd_head: neti_stack_s_netd_listhead,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct neti_stack_s__bindgen_ty_1 {
    pub le_next: *mut neti_stack_s,
    pub le_prev: *mut *mut neti_stack_s,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct neti_stack_s_netd_listhead {
    pub lh_first: *mut net_data,
}
pub type neti_stack_t = neti_stack_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct neti_stack_head_s {
    pub lh_first: *mut neti_stack_s,
}
pub type neti_stack_head_t = neti_stack_head_s;
unsafe extern "C" {
    pub fn neti_init();
}
unsafe extern "C" {
    pub fn neti_fini();
}
unsafe extern "C" {
    pub fn net_getnetistackbyid(arg1: netid_t) -> *mut neti_stack_t;
}
unsafe extern "C" {
    pub fn net_getnetstackidbynetid(arg1: netid_t) -> netstackid_t;
}
unsafe extern "C" {
    pub fn net_getnetidbynetstackid(arg1: netstackid_t) -> netid_t;
}
unsafe extern "C" {
    pub fn net_zoneidtonetid(arg1: zoneid_t) -> netid_t;
}
unsafe extern "C" {
    pub fn net_getzoneidbynetid(arg1: netid_t) -> zoneid_t;
}
unsafe extern "C" {
    pub fn net_event_register(
        arg1: net_handle_t,
        arg2: *mut hook_event_t,
    ) -> hook_event_token_t;
}
unsafe extern "C" {
    pub fn net_event_shutdown(
        arg1: net_handle_t,
        arg2: *mut hook_event_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_event_unregister(
        arg1: net_handle_t,
        arg2: *mut hook_event_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_event_notify_register(
        arg1: net_handle_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: hook_notify_fn_t,
        arg4: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_event_notify_unregister(
        arg1: net_handle_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: hook_notify_fn_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_family_register(
        arg1: net_handle_t,
        arg2: *mut hook_family_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_family_shutdown(
        arg1: net_handle_t,
        arg2: *mut hook_family_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_family_unregister(
        arg1: net_handle_t,
        arg2: *mut hook_family_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_hook_register(
        arg1: net_handle_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: *mut hook_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_hook_unregister(
        arg1: net_handle_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: *mut hook_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_inject(
        arg1: net_handle_t,
        arg2: inject_t,
        arg3: *mut net_inject_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_inject_alloc(arg1: illumos_sys_hdrs::c_int)
        -> *mut net_inject_t;
}
unsafe extern "C" {
    pub fn net_inject_free(arg1: *mut net_inject_t);
}
unsafe extern "C" {
    pub fn net_instance_alloc(
        version: illumos_sys_hdrs::c_int,
    ) -> *mut net_instance_t;
}
unsafe extern "C" {
    pub fn net_instance_free(arg1: *mut net_instance_t);
}
unsafe extern "C" {
    pub fn net_instance_register(
        arg1: *mut net_instance_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_instance_unregister(
        arg1: *mut net_instance_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_instance_notify_register(
        arg1: netid_t,
        arg2: hook_notify_fn_t,
        arg3: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_instance_notify_unregister(
        netid: netid_t,
        arg1: hook_notify_fn_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_kstat_create(
        arg1: netid_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: illumos_sys_hdrs::c_int,
        arg4: *mut illumos_sys_hdrs::c_char,
        arg5: *mut illumos_sys_hdrs::c_char,
        arg6: uchar_t,
        arg7: ulong_t,
        arg8: uchar_t,
    ) -> *mut kstat_t;
}
unsafe extern "C" {
    pub fn net_kstat_delete(arg1: netid_t, arg2: *mut kstat_t);
}
unsafe extern "C" {
    pub fn net_protocol_lookup(
        arg1: netid_t,
        arg2: *const illumos_sys_hdrs::c_char,
    ) -> net_handle_t;
}
unsafe extern "C" {
    pub fn net_protocol_register(
        arg1: netid_t,
        arg2: *const net_protocol_t,
    ) -> net_handle_t;
}
unsafe extern "C" {
    pub fn net_protocol_release(arg1: net_handle_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_protocol_unregister(
        arg1: net_handle_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_protocol_walk(arg1: netid_t, arg2: net_handle_t)
        -> net_handle_t;
}
unsafe extern "C" {
    pub fn net_protocol_notify_register(
        arg1: net_handle_t,
        arg2: hook_notify_fn_t,
        arg3: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_protocol_notify_unregister(
        arg1: net_handle_t,
        arg2: hook_notify_fn_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_getifname(
        arg1: net_handle_t,
        arg2: phy_if_t,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_getmtu(
        arg1: net_handle_t,
        arg2: phy_if_t,
        arg3: lif_if_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_getpmtuenabled(arg1: net_handle_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_getlifaddr(
        arg1: net_handle_t,
        arg2: phy_if_t,
        arg3: lif_if_t,
        arg4: illumos_sys_hdrs::c_int,
        arg5: *mut net_ifaddr_t,
        arg6: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_getlifzone(
        arg1: net_handle_t,
        arg2: phy_if_t,
        arg3: lif_if_t,
        arg4: *mut zoneid_t,
    ) -> zoneid_t;
}
unsafe extern "C" {
    pub fn net_getlifflags(
        arg1: net_handle_t,
        arg2: phy_if_t,
        arg3: lif_if_t,
        arg4: *mut u64,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_phygetnext(arg1: net_handle_t, arg2: phy_if_t) -> phy_if_t;
}
unsafe extern "C" {
    pub fn net_phylookup(
        arg1: net_handle_t,
        arg2: *const illumos_sys_hdrs::c_char,
    ) -> phy_if_t;
}
unsafe extern "C" {
    pub fn net_lifgetnext(
        arg1: net_handle_t,
        arg2: phy_if_t,
        arg3: lif_if_t,
    ) -> lif_if_t;
}
unsafe extern "C" {
    pub fn net_routeto(
        arg1: net_handle_t,
        arg2: *mut sockaddr,
        arg3: *mut sockaddr,
    ) -> phy_if_t;
}
unsafe extern "C" {
    pub fn net_ispartialchecksum(
        arg1: net_handle_t,
        arg2: *mut msgb,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn net_isvalidchecksum(
        arg1: net_handle_t,
        arg2: *mut msgb,
    ) -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_pkt_event {
    pub hpe_protocol: net_handle_t,
    pub hpe_ifp: phy_if_t,
    pub hpe_ofp: phy_if_t,
    pub hpe_hdr: *mut illumos_sys_hdrs::c_void,
    pub hpe_mp: *mut *mut msgb,
    pub hpe_mb: *mut msgb,
    pub hpe_flags: illumos_sys_hdrs::c_int,
    pub hpe_reserved: [*mut illumos_sys_hdrs::c_void; 2usize],
}
pub type hook_pkt_event_t = hook_pkt_event;
pub const nic_event_NE_PLUMB: nic_event = 1;
pub const nic_event_NE_UNPLUMB: nic_event = 2;
pub const nic_event_NE_UP: nic_event = 3;
pub const nic_event_NE_DOWN: nic_event = 4;
pub const nic_event_NE_ADDRESS_CHANGE: nic_event = 5;
pub const nic_event_NE_LIF_UP: nic_event = 6;
pub const nic_event_NE_LIF_DOWN: nic_event = 7;
pub const nic_event_NE_IFINDEX_CHANGE: nic_event = 8;
pub type nic_event = illumos_sys_hdrs::c_uint;
pub use self::nic_event as nic_event_t;
pub type nic_event_data_t = *mut illumos_sys_hdrs::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_nic_event {
    pub hne_protocol: net_handle_t,
    pub hne_nic: phy_if_t,
    pub hne_lif: lif_if_t,
    pub hne_event: nic_event_t,
    pub hne_data: nic_event_data_t,
    pub hne_datalen: usize,
}
pub type hook_nic_event_t = hook_nic_event;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_nic_event_int {
    pub hnei_stackid: netstackid_t,
    pub hnei_event: hook_nic_event_t,
}
pub type hook_nic_event_int_t = hook_nic_event_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_pkt_observe_s {
    pub hpo_version: u8,
    pub hpo_family: u8,
    pub hpo_htype: u16,
    pub hpo_pktlen: u32,
    pub hpo_ifindex: u32,
    pub hpo_grifindex: u32,
    pub hpo_zsrc: u32,
    pub hpo_zdst: u32,
    pub hpo_pkt: *mut msgb,
    pub hpo_ctx: *mut illumos_sys_hdrs::c_void,
}
pub type hook_pkt_observe_t = hook_pkt_observe_s;
pub const ipobs_hook_type_IPOBS_HOOK_INBOUND: ipobs_hook_type = 0;
pub const ipobs_hook_type_IPOBS_HOOK_OUTBOUND: ipobs_hook_type = 1;
pub const ipobs_hook_type_IPOBS_HOOK_LOCAL: ipobs_hook_type = 2;
pub type ipobs_hook_type = illumos_sys_hdrs::c_uint;
pub use self::ipobs_hook_type as ipobs_hook_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct igmpstat {
    pub igps_rcv_total: uint_t,
    pub igps_rcv_tooshort: uint_t,
    pub igps_rcv_badsum: uint_t,
    pub igps_rcv_queries: uint_t,
    pub igps_rcv_badqueries: uint_t,
    pub igps_rcv_reports: uint_t,
    pub igps_rcv_badreports: uint_t,
    pub igps_rcv_ourreports: uint_t,
    pub igps_snd_reports: uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rnd_stats {
    pub rs_rndOut: u64,
    pub rs_rndcOut: u64,
    pub rs_urndOut: u64,
}
pub type rnd_stats_t = rnd_stats;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swrand_stats {
    pub ss_entEst: u32,
    pub ss_entIn: u64,
    pub ss_entOut: u64,
    pub ss_bytesIn: u64,
    pub ss_bytesOut: u64,
}
pub type swrand_stats_t = swrand_stats;
unsafe extern "C" {
    pub fn random_add_entropy(
        arg1: *mut u8,
        arg2: usize,
        arg3: uint_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn random_get_bytes(
        arg1: *mut u8,
        arg2: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn random_get_blocking_bytes(
        arg1: *mut u8,
        arg2: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn random_get_pseudo_bytes(
        arg1: *mut u8,
        arg2: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn getrandom(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: usize,
        arg3: illumos_sys_hdrs::c_uint,
    ) -> isize;
}
pub type mod_hash_val_t = *mut illumos_sys_hdrs::c_void;
pub type mod_hash_key_t = *mut illumos_sys_hdrs::c_void;
pub type mod_hash_hndl_t = *mut illumos_sys_hdrs::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_hash {
    _unused: [u8; 0],
}
pub type mod_hash_t = mod_hash;
unsafe extern "C" {
    pub fn mod_hash_create_strhash(
        arg1: *mut illumos_sys_hdrs::c_char,
        arg2: usize,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(arg1: mod_hash_val_t),
        >,
    ) -> *mut mod_hash_t;
}
unsafe extern "C" {
    pub fn mod_hash_destroy_strhash(arg1: *mut mod_hash_t);
}
unsafe extern "C" {
    pub fn mod_hash_strkey_cmp(
        arg1: mod_hash_key_t,
        arg2: mod_hash_key_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn mod_hash_strkey_dtor(arg1: mod_hash_key_t);
}
unsafe extern "C" {
    pub fn mod_hash_strval_dtor(arg1: mod_hash_val_t);
}
unsafe extern "C" {
    pub fn mod_hash_bystr(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: mod_hash_key_t,
    ) -> uint_t;
}
unsafe extern "C" {
    pub fn mod_hash_create_ptrhash(
        arg1: *mut illumos_sys_hdrs::c_char,
        arg2: usize,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(arg1: mod_hash_val_t),
        >,
        arg4: usize,
    ) -> *mut mod_hash_t;
}
unsafe extern "C" {
    pub fn mod_hash_destroy_ptrhash(arg1: *mut mod_hash_t);
}
unsafe extern "C" {
    pub fn mod_hash_ptrkey_cmp(
        arg1: mod_hash_key_t,
        arg2: mod_hash_key_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn mod_hash_byptr(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: mod_hash_key_t,
    ) -> uint_t;
}
unsafe extern "C" {
    pub fn mod_hash_create_idhash(
        arg1: *mut illumos_sys_hdrs::c_char,
        arg2: usize,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(arg1: mod_hash_val_t),
        >,
    ) -> *mut mod_hash_t;
}
unsafe extern "C" {
    pub fn mod_hash_destroy_idhash(arg1: *mut mod_hash_t);
}
unsafe extern "C" {
    pub fn mod_hash_idkey_cmp(
        arg1: mod_hash_key_t,
        arg2: mod_hash_key_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn mod_hash_byid(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: mod_hash_key_t,
    ) -> uint_t;
}
unsafe extern "C" {
    pub fn mod_hash_iddata_gen(arg1: usize) -> uint_t;
}
unsafe extern "C" {
    pub fn mod_hash_create_extended(
        arg1: *mut illumos_sys_hdrs::c_char,
        arg2: usize,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(arg1: mod_hash_key_t),
        >,
        arg4: ::core::option::Option<
            unsafe extern "C" fn(arg1: mod_hash_val_t),
        >,
        arg5: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut illumos_sys_hdrs::c_void,
                arg2: mod_hash_key_t,
            ) -> uint_t,
        >,
        arg6: *mut illumos_sys_hdrs::c_void,
        arg7: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: mod_hash_key_t,
                arg2: mod_hash_key_t,
            ) -> illumos_sys_hdrs::c_int,
        >,
        arg8: illumos_sys_hdrs::c_int,
    ) -> *mut mod_hash_t;
}
unsafe extern "C" {
    pub fn mod_hash_destroy_hash(arg1: *mut mod_hash_t);
}
unsafe extern "C" {
    pub fn mod_hash_clear(arg1: *mut mod_hash_t);
}
unsafe extern "C" {
    pub fn mod_hash_null_keydtor(arg1: mod_hash_key_t);
}
unsafe extern "C" {
    pub fn mod_hash_null_valdtor(arg1: mod_hash_val_t);
}
unsafe extern "C" {
    pub fn mod_hash_insert(
        arg1: *mut mod_hash_t,
        arg2: mod_hash_key_t,
        arg3: mod_hash_val_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn mod_hash_replace(
        arg1: *mut mod_hash_t,
        arg2: mod_hash_key_t,
        arg3: mod_hash_val_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn mod_hash_remove(
        arg1: *mut mod_hash_t,
        arg2: mod_hash_key_t,
        arg3: *mut mod_hash_val_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn mod_hash_destroy(
        arg1: *mut mod_hash_t,
        arg2: mod_hash_key_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn mod_hash_find(
        arg1: *mut mod_hash_t,
        arg2: mod_hash_key_t,
        arg3: *mut mod_hash_val_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn mod_hash_find_cb(
        arg1: *mut mod_hash_t,
        arg2: mod_hash_key_t,
        arg3: *mut mod_hash_val_t,
        arg4: ::core::option::Option<
            unsafe extern "C" fn(arg1: mod_hash_key_t, arg2: mod_hash_val_t),
        >,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn mod_hash_find_cb_rval(
        arg1: *mut mod_hash_t,
        arg2: mod_hash_key_t,
        arg3: *mut mod_hash_val_t,
        arg4: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: mod_hash_key_t,
                arg2: mod_hash_val_t,
            ) -> illumos_sys_hdrs::c_int,
        >,
        arg5: *mut illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn mod_hash_walk(
        arg1: *mut mod_hash_t,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: mod_hash_key_t,
                arg2: *mut mod_hash_val_t,
                arg3: *mut illumos_sys_hdrs::c_void,
            ) -> uint_t,
        >,
        arg3: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn mod_hash_reserve(
        arg1: *mut mod_hash_t,
        arg2: *mut mod_hash_hndl_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn mod_hash_reserve_nosleep(
        arg1: *mut mod_hash_t,
        arg2: *mut mod_hash_hndl_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn mod_hash_cancel(arg1: *mut mod_hash_t, arg2: *mut mod_hash_hndl_t);
}
unsafe extern "C" {
    pub fn mod_hash_insert_reserve(
        arg1: *mut mod_hash_t,
        arg2: mod_hash_key_t,
        arg3: mod_hash_val_t,
        arg4: mod_hash_hndl_t,
    ) -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_stat {
    pub ip_udp_fannorm: kstat_named_t,
    pub ip_udp_fanmb: kstat_named_t,
    pub ip_recv_pullup: kstat_named_t,
    pub ip_db_ref: kstat_named_t,
    pub ip_notaligned: kstat_named_t,
    pub ip_multimblk: kstat_named_t,
    pub ip_opt: kstat_named_t,
    pub ipsec_proto_ahesp: kstat_named_t,
    pub ip_conn_flputbq: kstat_named_t,
    pub ip_conn_walk_drain: kstat_named_t,
    pub ip_out_sw_cksum: kstat_named_t,
    pub ip_out_sw_cksum_bytes: kstat_named_t,
    pub ip_in_sw_cksum: kstat_named_t,
    pub ip_ire_reclaim_calls: kstat_named_t,
    pub ip_ire_reclaim_deleted: kstat_named_t,
    pub ip_nce_reclaim_calls: kstat_named_t,
    pub ip_nce_reclaim_deleted: kstat_named_t,
    pub ip_nce_mcast_reclaim_calls: kstat_named_t,
    pub ip_nce_mcast_reclaim_deleted: kstat_named_t,
    pub ip_nce_mcast_reclaim_tqfail: kstat_named_t,
    pub ip_dce_reclaim_calls: kstat_named_t,
    pub ip_dce_reclaim_deleted: kstat_named_t,
    pub ip_tcp_in_full_hw_cksum_err: kstat_named_t,
    pub ip_tcp_in_part_hw_cksum_err: kstat_named_t,
    pub ip_tcp_in_sw_cksum_err: kstat_named_t,
    pub ip_udp_in_full_hw_cksum_err: kstat_named_t,
    pub ip_udp_in_part_hw_cksum_err: kstat_named_t,
    pub ip_udp_in_sw_cksum_err: kstat_named_t,
    pub conn_in_recvdstaddr: kstat_named_t,
    pub conn_in_recvopts: kstat_named_t,
    pub conn_in_recvif: kstat_named_t,
    pub conn_in_recvslla: kstat_named_t,
    pub conn_in_recvucred: kstat_named_t,
    pub conn_in_recvttl: kstat_named_t,
    pub conn_in_recvtos: kstat_named_t,
    pub conn_in_recvhopopts: kstat_named_t,
    pub conn_in_recvhoplimit: kstat_named_t,
    pub conn_in_recvdstopts: kstat_named_t,
    pub conn_in_recvrthdrdstopts: kstat_named_t,
    pub conn_in_recvrthdr: kstat_named_t,
    pub conn_in_recvpktinfo: kstat_named_t,
    pub conn_in_recvtclass: kstat_named_t,
    pub conn_in_timestamp: kstat_named_t,
}
pub type ip_stat_t = ip_stat;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_stat {
    pub ip6_udp_fannorm: kstat_named_t,
    pub ip6_udp_fanmb: kstat_named_t,
    pub ip6_recv_pullup: kstat_named_t,
    pub ip6_db_ref: kstat_named_t,
    pub ip6_notaligned: kstat_named_t,
    pub ip6_multimblk: kstat_named_t,
    pub ipsec_proto_ahesp: kstat_named_t,
    pub ip6_out_sw_cksum: kstat_named_t,
    pub ip6_out_sw_cksum_bytes: kstat_named_t,
    pub ip6_in_sw_cksum: kstat_named_t,
    pub ip6_tcp_in_full_hw_cksum_err: kstat_named_t,
    pub ip6_tcp_in_part_hw_cksum_err: kstat_named_t,
    pub ip6_tcp_in_sw_cksum_err: kstat_named_t,
    pub ip6_udp_in_full_hw_cksum_err: kstat_named_t,
    pub ip6_udp_in_part_hw_cksum_err: kstat_named_t,
    pub ip6_udp_in_sw_cksum_err: kstat_named_t,
}
pub type ip6_stat_t = ip6_stat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ire_stats {
    pub ire_stats_alloced: u64,
    pub ire_stats_freed: u64,
    pub ire_stats_inserted: u64,
    pub ire_stats_deleted: u64,
}
pub type ire_stats_t = ire_stats;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcid_map {
    pub sm_next: *mut srcid_map,
    pub sm_addr: in6_addr_t,
    pub sm_srcid: uint_t,
    pub sm_refcnt: uint_t,
    pub sm_zoneid: zoneid_t,
}
pub type srcid_map_t = srcid_map;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_stack {
    pub ips_netstack: *mut netstack_t,
    pub ips_src_generation: uint_t,
    pub ips_propinfo_tbl: *mut mod_prop_info_s,
    pub ips_ip_mib: mib2_ipIfStatsEntry_t,
    pub ips_icmp_mib: mib2_icmp_t,
    pub ips_ip6_mib: mib2_ipIfStatsEntry_t,
    pub ips_icmp6_mib: mib2_ipv6IfIcmpEntry_t,
    pub ips_igmpstat: igmpstat,
    pub ips_ip_mibkp: *mut kstat_t,
    pub ips_icmp_mibkp: *mut kstat_t,
    pub ips_ip_kstat: *mut kstat_t,
    pub ips_ip_statistics: ip_stat_t,
    pub ips_ip6_kstat: *mut kstat_t,
    pub ips_ip6_statistics: ip6_stat_t,
    pub ips_igmp_timer_lock: kmutex_t,
    pub ips_mld_timer_lock: kmutex_t,
    pub ips_ip_mi_lock: kmutex_t,
    pub ips_ip_addr_avail_lock: kmutex_t,
    pub ips_ill_g_lock: krwlock_t,
    pub ips_ill_g_usesrc_lock: krwlock_t,
    pub ips_capab_taskq_lock: kmutex_t,
    pub ips_capab_taskq_cv: kcondvar_t,
    pub ips_capab_taskq_head: *mut mblk_t,
    pub ips_capab_taskq_tail: *mut mblk_t,
    pub ips_capab_taskq_thread: *mut kthread_t,
    pub ips_capab_taskq_quit: boolean_t,
    pub ips_rts_clients: *mut connf_s,
    pub ips_ipcl_conn_fanout: *mut connf_s,
    pub ips_ipcl_bind_fanout: *mut connf_s,
    pub ips_ipcl_proto_fanout_v4: *mut connf_s,
    pub ips_ipcl_proto_fanout_v6: *mut connf_s,
    pub ips_ipcl_udp_fanout: *mut connf_s,
    pub ips_ipcl_raw_fanout: *mut connf_s,
    pub ips_ipcl_iptun_fanout: *mut connf_s,
    pub ips_ipcl_conn_fanout_size: uint_t,
    pub ips_ipcl_bind_fanout_size: uint_t,
    pub ips_ipcl_udp_fanout_size: uint_t,
    pub ips_ipcl_raw_fanout_size: uint_t,
    pub ips_ipcl_iptun_fanout_size: uint_t,
    pub ips_ipcl_globalhash_fanout: *mut connf_s,
    pub ips_conn_g_index: illumos_sys_hdrs::c_int,
    pub ips_igmp_time_to_next: illumos_sys_hdrs::c_int,
    pub ips_igmp_timer_scheduled_last: illumos_sys_hdrs::c_int,
    pub ips_igmp_deferred_next: illumos_sys_hdrs::c_int,
    pub ips_igmp_timeout_id: timeout_id_t,
    pub ips_igmp_timer_setter_active: boolean_t,
    pub ips_igmp_timer_quiesce: boolean_t,
    pub ips_mld_time_to_next: illumos_sys_hdrs::c_int,
    pub ips_mld_timer_scheduled_last: illumos_sys_hdrs::c_int,
    pub ips_mld_deferred_next: illumos_sys_hdrs::c_int,
    pub ips_mld_timeout_id: timeout_id_t,
    pub ips_mld_timer_setter_active: boolean_t,
    pub ips_mld_timer_quiesce: boolean_t,
    pub ips_igmp_slowtimeout_id: timeout_id_t,
    pub ips_igmp_slowtimeout_lock: kmutex_t,
    pub ips_igmp_slowtimeout_quiesce: boolean_t,
    pub ips_mld_slowtimeout_id: timeout_id_t,
    pub ips_mld_slowtimeout_lock: kmutex_t,
    pub ips_mld_slowtimeout_quiesce: boolean_t,
    pub ips_ip_ftable: *mut radix_node_head,
    pub ips_ip_forwarding_table_v6: [*mut irb; 129usize],
    pub ips_ire_ft_init_lock: kmutex_t,
    pub ips_ip6_ire_head_lock: krwlock_t,
    pub ips_ip6_ftable_hash_size: u32,
    pub ips_ire_stats_v4: ire_stats_t,
    pub ips_ire_stats_v6: ire_stats_t,
    pub ips_num_ire_condemned: u32,
    pub ips_num_nce_condemned: u32,
    pub ips_num_dce_condemned: u32,
    pub ips_ire_reject_v4: *mut ire_s,
    pub ips_ire_reject_v6: *mut ire_s,
    pub ips_ire_blackhole_v4: *mut ire_s,
    pub ips_ire_blackhole_v6: *mut ire_s,
    pub ips_ire_dep_lock: krwlock_t,
    pub ips_dce_default: *mut dce_s,
    pub ips_dce_hashsize: uint_t,
    pub ips_dce_hash_v4: *mut dcb_s,
    pub ips_dce_hash_v6: *mut dcb_s,
    pub ips_dce_reclaim_needed: uint_t,
    pub ips_ip6_asp_pending_ops: *mut mblk_t,
    pub ips_ip6_asp_pending_ops_tail: *mut mblk_t,
    pub ips_ip6_asp_pending_update: *mut mblk_t,
    pub ips_ip6_asp_uip: boolean_t,
    pub ips_ip6_asp_lock: kmutex_t,
    pub ips_ip6_asp_refcnt: u32,
    pub ips_ip6_asp_table: *mut ip6_asp,
    pub ips_ip6_asp_table_count: uint_t,
    pub ips_ip_g_mrouter: *mut conn_s,
    pub ips_icmp_pkt_err_last: clock_t,
    pub ips_icmp_pkt_err_sent: uint_t,
    pub ips_ip_g_head: *mut illumos_sys_hdrs::c_void,
    pub ips_arp_g_head: *mut illumos_sys_hdrs::c_void,
    pub ips_ip_multirt_log_interval: hrtime_t,
    pub ips_multirt_bad_mtu_last_time: hrtime_t,
    pub ips_ip_cgtp_filter_ops: *mut cgtp_filter_ops,
    pub ips_ipsq_g_head: *mut ipsq_s,
    pub ips_ill_index: uint_t,
    pub ips_ill_index_wrap: boolean_t,
    pub ips_loopback_packets: uint_t,
    pub ips_ndp4: *mut ndp_g_s,
    pub ips_ndp6: *mut ndp_g_s,
    pub ips_ip_g_mrouter_mutex: kmutex_t,
    pub ips_mrtstat: *mut mrtstat,
    pub ips_saved_ip_forwarding: illumos_sys_hdrs::c_int,
    pub ips_numvifs: ushort_t,
    pub ips_numvifs_mutex: kmutex_t,
    pub ips_vifs: *mut vif,
    pub ips_mfcs: *mut mfcb,
    pub ips_tbfs: *mut tbf,
    pub ips_last_encap_src: ipaddr_t,
    pub ips_last_encap_vif: *mut vif,
    pub ips_last_encap_lock: kmutex_t,
    pub ips_reg_vif_num: ushort_t,
    pub ips_pim_assert: illumos_sys_hdrs::c_int,
    pub ips_ill_g_heads: *mut ill_g_head_u,
    pub ips_loopback_ksp: *mut kstat_t,
    pub ips_idl_tx_list: *mut idl_tx_list_s,
    pub ips_conn_drain_list_cnt: uint_t,
    pub ips_ip_src_id: uint_t,
    pub ips_srcid_wrapped: boolean_t,
    pub ips_srcid_head: *mut srcid_map,
    pub ips_srcid_lock: krwlock_t,
    pub ips_ipif_g_seqid: u64,
    pub ips_phyint_g_list: *mut phyint_list_u,
    pub ips_ipv4root: hook_family_t,
    pub ips_ipv6root: hook_family_t,
    pub ips_arproot: hook_family_t,
    pub ips_ipv4_net_data: net_handle_t,
    pub ips_ipv6_net_data: net_handle_t,
    pub ips_arp_net_data: net_handle_t,
    pub ips_ip4_physical_in_event: hook_event_t,
    pub ips_ip4_physical_out_event: hook_event_t,
    pub ips_ip4_forwarding_event: hook_event_t,
    pub ips_ip4_loopback_in_event: hook_event_t,
    pub ips_ip4_loopback_out_event: hook_event_t,
    pub ips_ip6_physical_in_event: hook_event_t,
    pub ips_ip6_physical_out_event: hook_event_t,
    pub ips_ip6_forwarding_event: hook_event_t,
    pub ips_ip6_loopback_in_event: hook_event_t,
    pub ips_ip6_loopback_out_event: hook_event_t,
    pub ips_arp_physical_in_event: hook_event_t,
    pub ips_arp_physical_out_event: hook_event_t,
    pub ips_arp_nic_events: hook_event_t,
    pub ips_ipv4firewall_physical_in: hook_event_token_t,
    pub ips_ipv4firewall_physical_out: hook_event_token_t,
    pub ips_ipv4firewall_forwarding: hook_event_token_t,
    pub ips_ipv4firewall_loopback_in: hook_event_token_t,
    pub ips_ipv4firewall_loopback_out: hook_event_token_t,
    pub ips_ipv6firewall_physical_in: hook_event_token_t,
    pub ips_ipv6firewall_physical_out: hook_event_token_t,
    pub ips_ipv6firewall_forwarding: hook_event_token_t,
    pub ips_ipv6firewall_loopback_in: hook_event_token_t,
    pub ips_ipv6firewall_loopback_out: hook_event_token_t,
    pub ips_ip4_nic_events: hook_event_t,
    pub ips_ip6_nic_events: hook_event_t,
    pub ips_ipv4nicevents: hook_event_token_t,
    pub ips_ipv6nicevents: hook_event_token_t,
    pub ips_arp_physical_in: hook_event_token_t,
    pub ips_arp_physical_out: hook_event_token_t,
    pub ips_arpnicevents: hook_event_token_t,
    pub ips_ip4_observe_pr: net_handle_t,
    pub ips_ip6_observe_pr: net_handle_t,
    pub ips_ip4_observe: hook_event_t,
    pub ips_ip6_observe: hook_event_t,
    pub ips_ipv4observing: hook_event_token_t,
    pub ips_ipv6observing: hook_event_token_t,
    pub ips_ldi_ident: *mut __ldi_ident,
    pub ips_ipmp_lock: krwlock_t,
    pub ips_ipmp_grp_hash: *mut mod_hash_t,
}
pub type ip_stack_t = ip_stack;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_hdr {
    pub ip6_ctlun: ip6_hdr__bindgen_ty_1,
    pub ip6_src: in6_addr,
    pub ip6_dst: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip6_hdr__bindgen_ty_1 {
    pub ip6_un1: ip6_hdr__bindgen_ty_1_ip6_hdrctl,
    pub ip6_un2_vfc: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_hdr__bindgen_ty_1_ip6_hdrctl {
    pub ip6_un1_flow: u32,
    pub ip6_un1_plen: u16,
    pub ip6_un1_nxt: u8,
    pub ip6_un1_hlim: u8,
}
pub type ip6_t = ip6_hdr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_hbh {
    pub ip6h_nxt: u8,
    pub ip6h_len: u8,
}
pub type ip6_hbh_t = ip6_hbh;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_dest {
    pub ip6d_nxt: u8,
    pub ip6d_len: u8,
}
pub type ip6_dest_t = ip6_dest;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_rthdr {
    pub ip6r_nxt: u8,
    pub ip6r_len: u8,
    pub ip6r_type: u8,
    pub ip6r_segleft: u8,
}
pub type ip6_rthdr_t = ip6_rthdr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_rthdr0 {
    pub ip6r0_nxt: u8,
    pub ip6r0_len: u8,
    pub ip6r0_type: u8,
    pub ip6r0_segleft: u8,
    pub ip6r0_reserved: u32,
}
pub type ip6_rthdr0_t = ip6_rthdr0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_frag {
    pub ip6f_nxt: u8,
    pub ip6f_reserved: u8,
    pub ip6f_offlg: u16,
    pub ip6f_ident: u32,
}
pub type ip6_frag_t = ip6_frag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_opt {
    pub ip6o_type: u8,
    pub ip6o_len: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_opt_jumbo {
    pub ip6oj_type: u8,
    pub ip6oj_len: u8,
    pub ip6oj_jumbo_len: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_opt_nsap {
    pub ip6on_type: u8,
    pub ip6on_len: u8,
    pub ip6on_src_nsap_len: u8,
    pub ip6on_dst_nsap_len: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_opt_tunnel {
    pub ip6ot_type: u8,
    pub ip6ot_len: u8,
    pub ip6ot_encap_limit: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_opt_router {
    pub ip6or_type: u8,
    pub ip6or_len: u8,
    pub ip6or_value: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_opt_binding_update {
    pub ip6ou_type: u8,
    pub ip6ou_len: u8,
    pub ip6ou_flags: u8,
    pub ip6ou_prefixlen: u8,
    pub ip6ou_seqno: [u8; 2usize],
    pub ip6ou_lifetime: [u8; 4usize],
    pub ip6ou_coa: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_opt_binding_ack {
    pub ip6oa_type: u8,
    pub ip6oa_len: u8,
    pub ip6oa_status: u8,
    pub ip6oa_seqno: [u8; 2usize],
    pub ip6oa_lifetime: [u8; 4usize],
    pub ip6oa_refresh: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_opt_binding_request {
    pub ip6or_type: u8,
    pub ip6or_len: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_opt_home_address {
    pub ip6oh_type: u8,
    pub ip6oh_len: u8,
    pub ip6oh_addr: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_opt_labeled_security {
    pub ip6ol_type: u8,
    pub ip6ol_len: u8,
    pub ip6ol_doi: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct avl_node {
    pub avl_child: [*mut avl_node; 2usize],
    pub avl_pcb: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct avl_tree {
    pub avl_root: *mut avl_node,
    pub avl_compar: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const illumos_sys_hdrs::c_void,
            arg2: *const illumos_sys_hdrs::c_void,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub avl_offset: usize,
    pub avl_numnodes: ulong_t,
    pub avl_size: usize,
}
unsafe extern "C" {
    pub fn avl_walk(
        arg1: *mut avl_tree,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_void;
}
pub type avl_tree_t = avl_tree;
pub type avl_node_t = avl_node;
pub type avl_index_t = usize;
unsafe extern "C" {
    pub fn avl_create(
        tree: *mut avl_tree_t,
        compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const illumos_sys_hdrs::c_void,
                arg2: *const illumos_sys_hdrs::c_void,
            ) -> illumos_sys_hdrs::c_int,
        >,
        size: usize,
        offset: usize,
    );
}
unsafe extern "C" {
    pub fn avl_find(
        tree: *mut avl_tree_t,
        node: *const illumos_sys_hdrs::c_void,
        where_: *mut avl_index_t,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn avl_insert(
        tree: *mut avl_tree_t,
        node: *mut illumos_sys_hdrs::c_void,
        where_: avl_index_t,
    );
}
unsafe extern "C" {
    pub fn avl_insert_here(
        tree: *mut avl_tree_t,
        new_data: *mut illumos_sys_hdrs::c_void,
        here: *mut illumos_sys_hdrs::c_void,
        direction: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn avl_first(tree: *mut avl_tree_t) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn avl_last(tree: *mut avl_tree_t) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn avl_nearest(
        tree: *mut avl_tree_t,
        where_: avl_index_t,
        direction: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn avl_add(tree: *mut avl_tree_t, node: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn avl_remove(
        tree: *mut avl_tree_t,
        node: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn avl_update(
        arg1: *mut avl_tree_t,
        arg2: *mut illumos_sys_hdrs::c_void,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn avl_update_lt(
        arg1: *mut avl_tree_t,
        arg2: *mut illumos_sys_hdrs::c_void,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn avl_update_gt(
        arg1: *mut avl_tree_t,
        arg2: *mut illumos_sys_hdrs::c_void,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn avl_swap(tree1: *mut avl_tree_t, tree2: *mut avl_tree_t);
}
unsafe extern "C" {
    pub fn avl_numnodes(tree: *mut avl_tree_t) -> ulong_t;
}
unsafe extern "C" {
    pub fn avl_is_empty(tree: *mut avl_tree_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn avl_destroy_nodes(
        tree: *mut avl_tree_t,
        cookie: *mut *mut illumos_sys_hdrs::c_void,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn avl_destroy(tree: *mut avl_tree_t);
}
pub const idtype_P_PID: idtype = 0;
pub const idtype_P_PPID: idtype = 1;
pub const idtype_P_PGID: idtype = 2;
pub const idtype_P_SID: idtype = 3;
pub const idtype_P_CID: idtype = 4;
pub const idtype_P_UID: idtype = 5;
pub const idtype_P_GID: idtype = 6;
pub const idtype_P_ALL: idtype = 7;
pub const idtype_P_LWPID: idtype = 8;
pub const idtype_P_TASKID: idtype = 9;
pub const idtype_P_PROJID: idtype = 10;
pub const idtype_P_POOLID: idtype = 11;
pub const idtype_P_ZONEID: idtype = 12;
pub const idtype_P_CTID: idtype = 13;
pub const idtype_P_CPUID: idtype = 14;
pub const idtype_P_PSETID: idtype = 15;
pub type idtype = illumos_sys_hdrs::c_uint;
pub use self::idtype as idtype_t;
pub const idop_POP_DIFF: idop = 0;
pub const idop_POP_AND: idop = 1;
pub const idop_POP_OR: idop = 2;
pub const idop_POP_XOR: idop = 3;
pub type idop = illumos_sys_hdrs::c_uint;
pub use self::idop as idop_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct procset {
    pub p_op: idop_t,
    pub p_lidtype: idtype_t,
    pub p_lid: id_t,
    pub p_ridtype: idtype_t,
    pub p_rid: id_t,
}
pub type procset_t = procset;
unsafe extern "C" {
    pub fn dotoprocs(
        arg1: *mut procset_t,
        arg2: ::core::option::Option<
            unsafe extern "C" fn() -> illumos_sys_hdrs::c_int,
        >,
        arg3: *mut illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn dotolwp(
        arg1: *mut procset_t,
        arg2: ::core::option::Option<
            unsafe extern "C" fn() -> illumos_sys_hdrs::c_int,
        >,
        arg3: *mut illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn procinset(
        arg1: *mut proc_,
        arg2: *mut procset_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn sigsendproc(
        arg1: *mut proc_,
        arg2: *mut sigsend_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn sigsendset(
        arg1: *mut procset_t,
        arg2: *mut sigsend_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn cur_inset_only(arg1: *mut procset_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn getmyid(arg1: idtype_t) -> id_t;
}
pub type lgrpid_t = u16;
pub type processorid_t = illumos_sys_hdrs::c_int;
pub type chipid_t = illumos_sys_hdrs::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct processor_info_t {
    pub pi_state: illumos_sys_hdrs::c_int,
    pub pi_processor_type: [illumos_sys_hdrs::c_char; 16usize],
    pub pi_fputypes: [illumos_sys_hdrs::c_char; 32usize],
    pub pi_clock: illumos_sys_hdrs::c_int,
}
unsafe extern "C" {
    pub fn p_online_internal(
        arg1: processorid_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn p_online_internal_locked(
        arg1: processorid_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct squeue_s {
    _unused: [u8; 0],
}
pub type squeue_t = squeue_s;
pub const sqprivate_t_SQPRIVATE_TCP: sqprivate_t = 0;
pub const sqprivate_t_SQPRIVATE_MAX: sqprivate_t = 1;
pub type sqprivate_t = illumos_sys_hdrs::c_uint;
unsafe extern "C" {
    pub fn squeue_init();
}
unsafe extern "C" {
    pub fn squeue_create(arg1: pri_t) -> *mut squeue_t;
}
unsafe extern "C" {
    pub fn squeue_bind(arg1: *mut squeue_t, arg2: processorid_t);
}
unsafe extern "C" {
    pub fn squeue_unbind(arg1: *mut squeue_t);
}
unsafe extern "C" {
    pub fn squeue_enter(
        arg1: *mut squeue_t,
        arg2: *mut mblk_t,
        arg3: *mut mblk_t,
        arg4: u32,
        arg5: *mut ip_recv_attr_s,
        arg6: illumos_sys_hdrs::c_int,
        arg7: u8,
    );
}
unsafe extern "C" {
    pub fn squeue_getprivate(
        arg1: *mut squeue_t,
        arg2: sqprivate_t,
    ) -> *mut usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conn_s {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn squeue_synch_enter(
        arg1: *mut conn_s,
        arg2: *mut mblk_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn squeue_synch_exit(arg1: *mut conn_s, arg2: illumos_sys_hdrs::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct route {
    pub ro_rt: *mut rtentry,
    pub ro_dst: sockaddr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_metrics {
    pub rmx_locks: u32,
    pub rmx_mtu: u32,
    pub rmx_hopcount: u32,
    pub rmx_expire: u32,
    pub rmx_recvpipe: u32,
    pub rmx_sendpipe: u32,
    pub rmx_ssthresh: u32,
    pub rmx_rtt: u32,
    pub rmx_rttvar: u32,
    pub rmx_pksent: u32,
}
pub type rt_metrics_t = rt_metrics;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtentry {
    pub rt_hash: uint_t,
    pub rt_dst: sockaddr,
    pub rt_gateway: sockaddr,
    pub rt_flags: illumos_sys_hdrs::c_short,
    pub rt_refcnt: illumos_sys_hdrs::c_short,
    pub rt_use: uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtstat {
    pub rts_badredirect: illumos_sys_hdrs::c_short,
    pub rts_dynamic: illumos_sys_hdrs::c_short,
    pub rts_newgateway: illumos_sys_hdrs::c_short,
    pub rts_unreach: illumos_sys_hdrs::c_short,
    pub rts_wildcard: illumos_sys_hdrs::c_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_msghdr {
    pub rtm_msglen: ushort_t,
    pub rtm_version: uchar_t,
    pub rtm_type: uchar_t,
    pub rtm_index: ushort_t,
    pub rtm_flags: illumos_sys_hdrs::c_int,
    pub rtm_addrs: illumos_sys_hdrs::c_int,
    pub rtm_pid: pid_t,
    pub rtm_seq: illumos_sys_hdrs::c_int,
    pub rtm_errno: illumos_sys_hdrs::c_int,
    pub rtm_use: illumos_sys_hdrs::c_int,
    pub rtm_inits: uint_t,
    pub rtm_rmx: rt_metrics,
}
pub type rt_msghdr_t = rt_msghdr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtm_ext_s {
    pub rtmex_type: u32,
    pub rtmex_len: u32,
}
pub type rtm_ext_t = rtm_ext_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtsa_s {
    pub rtsa_mask: u32,
    pub rtsa_doi: u32,
    pub rtsa_slrange: brange_t,
}
pub type rtsa_t = rtsa_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tsol_rtsecattr_s {
    pub rtsa_cnt: u32,
    pub rtsa_attr: [rtsa_t; 1usize],
}
pub type tsol_rtsecattr_t = tsol_rtsecattr_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exdata {
    pub vp: *mut vnode,
    pub ux_tsize: usize,
    pub ux_dsize: usize,
    pub ux_bsize: usize,
    pub ux_lsize: usize,
    pub ux_nshlibs: illumos_sys_hdrs::c_long,
    pub ux_mach: illumos_sys_hdrs::c_short,
    pub ux_mag: illumos_sys_hdrs::c_short,
    pub ux_toffset: off_t,
    pub ux_doffset: off_t,
    pub ux_loffset: off_t,
    pub ux_txtorg: caddr_t,
    pub ux_datorg: caddr_t,
    pub ux_entloc: caddr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct auxv_t {
    pub a_type: illumos_sys_hdrs::c_int,
    pub a_un: auxv_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union auxv_t__bindgen_ty_1 {
    pub a_val: illumos_sys_hdrs::c_long,
    pub a_ptr: *mut illumos_sys_hdrs::c_void,
    pub a_fcn: ::core::option::Option<unsafe extern "C" fn()>,
}
unsafe extern "C" {
    pub static mut auxv_hwcap: uint_t;
}
unsafe extern "C" {
    pub static mut auxv_hwcap_2: uint_t;
}
unsafe extern "C" {
    pub static mut auxv_hwcap_3: uint_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct refstr {
    _unused: [u8; 0],
}
pub type refstr_t = refstr;
unsafe extern "C" {
    pub fn refstr_alloc(arg1: *const illumos_sys_hdrs::c_char)
        -> *mut refstr_t;
}
unsafe extern "C" {
    pub fn refstr_value(arg1: *mut refstr_t)
        -> *const illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn refstr_hold(arg1: *mut refstr_t);
}
unsafe extern "C" {
    pub fn refstr_rele(arg1: *mut refstr_t);
}
pub type uf_entry_gen_t = uint_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uf_entry {
    pub uf_lock: kmutex_t,
    pub uf_file: *mut file,
    pub uf_fpollinfo: *mut fpollinfo,
    pub uf_refcnt: illumos_sys_hdrs::c_int,
    pub uf_alloc: illumos_sys_hdrs::c_int,
    pub uf_flag: illumos_sys_hdrs::c_short,
    pub uf_busy: illumos_sys_hdrs::c_short,
    pub uf_wanted_cv: kcondvar_t,
    pub uf_closing_cv: kcondvar_t,
    pub uf_portfd: *mut portfd,
    pub uf_gen: uf_entry_gen_t,
    pub uf_pad: [illumos_sys_hdrs::c_char; 12usize],
}
pub type uf_entry_t = uf_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uf_rlist {
    pub ur_next: *mut uf_rlist,
    pub ur_list: *mut uf_entry_t,
    pub ur_nfiles: illumos_sys_hdrs::c_int,
}
pub type uf_rlist_t = uf_rlist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uf_info {
    pub fi_lock: kmutex_t,
    pub fi_badfd: illumos_sys_hdrs::c_int,
    pub fi_action: illumos_sys_hdrs::c_int,
    pub fi_nfiles: illumos_sys_hdrs::c_int,
    pub fi_list: *mut uf_entry_t,
    pub fi_rlist: *mut uf_rlist_t,
}
pub type uf_info_t = uf_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_sysset_t {
    pub word: [uint_t; 9usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct execsw {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user {
    pub u_execsw: *mut execsw,
    pub u_auxv: [auxv_t; 26usize],
    pub u_start: timestruc_t,
    pub u_ticks: clock_t,
    pub u_comm: [illumos_sys_hdrs::c_char; 17usize],
    pub u_psargs: [illumos_sys_hdrs::c_char; 80usize],
    pub u_argc: illumos_sys_hdrs::c_int,
    pub u_argv: usize,
    pub u_envp: usize,
    pub u_commpagep: usize,
    pub u_cdir: *mut vnode,
    pub u_rdir: *mut vnode,
    pub u_mem: u64,
    pub u_mem_max: usize,
    pub u_cmask: mode_t,
    pub u_acflag: illumos_sys_hdrs::c_char,
    pub u_systrap: illumos_sys_hdrs::c_char,
    pub u_cwd: *mut refstr_t,
    pub u_entrymask: k_sysset_t,
    pub u_exitmask: k_sysset_t,
    pub u_signodefer: k_sigset_t,
    pub u_sigonstack: k_sigset_t,
    pub u_sigresethand: k_sigset_t,
    pub u_sigrestart: k_sigset_t,
    pub u_sigmask: [k_sigset_t; 73usize],
    pub u_signal: [::core::option::Option<unsafe extern "C" fn()>; 73usize],
    pub u_saved_rlimit: [rlimit64; 7usize],
    pub u_finfo: uf_info_t,
}
pub type user_t = user;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aio_req {
    pub aio_uio: *mut uio,
    pub aio_private: *mut illumos_sys_hdrs::c_void,
}
unsafe extern "C" {
    pub fn aphysio(
        arg1: ::core::option::Option<
            unsafe extern "C" fn() -> illumos_sys_hdrs::c_int,
        >,
        arg2: ::core::option::Option<
            unsafe extern "C" fn() -> illumos_sys_hdrs::c_int,
        >,
        arg3: dev_t,
        arg4: illumos_sys_hdrs::c_int,
        arg5: ::core::option::Option<unsafe extern "C" fn()>,
        arg6: *mut aio_req,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn anocancel(arg1: *mut buf) -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct copyops {
    pub cp_copyin: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const illumos_sys_hdrs::c_void,
            arg2: *mut illumos_sys_hdrs::c_void,
            arg3: usize,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cp_xcopyin: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const illumos_sys_hdrs::c_void,
            arg2: *mut illumos_sys_hdrs::c_void,
            arg3: usize,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cp_copyout: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const illumos_sys_hdrs::c_void,
            arg2: *mut illumos_sys_hdrs::c_void,
            arg3: usize,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cp_xcopyout: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const illumos_sys_hdrs::c_void,
            arg2: *mut illumos_sys_hdrs::c_void,
            arg3: usize,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cp_copyinstr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const illumos_sys_hdrs::c_char,
            arg2: *mut illumos_sys_hdrs::c_char,
            arg3: usize,
            arg4: *mut usize,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cp_copyoutstr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const illumos_sys_hdrs::c_char,
            arg2: *mut illumos_sys_hdrs::c_char,
            arg3: usize,
            arg4: *mut usize,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cp_fuword8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const illumos_sys_hdrs::c_void,
            arg2: *mut u8,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cp_fuword16: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const illumos_sys_hdrs::c_void,
            arg2: *mut u16,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cp_fuword32: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const illumos_sys_hdrs::c_void,
            arg2: *mut u32,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cp_fuword64: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const illumos_sys_hdrs::c_void,
            arg2: *mut u64,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cp_suword8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut illumos_sys_hdrs::c_void,
            arg2: u8,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cp_suword16: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut illumos_sys_hdrs::c_void,
            arg2: u16,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cp_suword32: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut illumos_sys_hdrs::c_void,
            arg2: u32,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cp_suword64: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut illumos_sys_hdrs::c_void,
            arg2: u64,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cp_physio: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ::core::option::Option<
                unsafe extern "C" fn(arg1: *mut buf) -> illumos_sys_hdrs::c_int,
            >,
            arg2: *mut buf,
            arg3: dev_t,
            arg4: illumos_sys_hdrs::c_int,
            arg5: ::core::option::Option<unsafe extern "C" fn(arg1: *mut buf)>,
            arg6: *mut uio,
        ) -> illumos_sys_hdrs::c_int,
    >,
}
pub type copyops_t = copyops;
unsafe extern "C" {
    pub fn default_physio(
        arg1: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut buf) -> illumos_sys_hdrs::c_int,
        >,
        arg2: *mut buf,
        arg3: dev_t,
        arg4: illumos_sys_hdrs::c_int,
        arg5: ::core::option::Option<unsafe extern "C" fn(arg1: *mut buf)>,
        arg6: *mut uio,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn install_copyops(tp: kthread_id_t, cp: *mut copyops_t);
}
unsafe extern "C" {
    pub fn remove_copyops(tp: kthread_id_t);
}
unsafe extern "C" {
    pub fn copyops_installed(tp: kthread_id_t) -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct watched_area {
    pub wa_link: avl_node_t,
    pub wa_vaddr: caddr_t,
    pub wa_eaddr: caddr_t,
    pub wa_flags: ulong_t,
}
pub type watched_area_t = watched_area;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct watched_page {
    pub wp_link: avl_node_t,
    pub wp_list: *mut watched_page,
    pub wp_vaddr: caddr_t,
    pub wp_prot: uchar_t,
    pub wp_oprot: uchar_t,
    pub wp_umap: [uchar_t; 3usize],
    pub wp_kmap: [uchar_t; 3usize],
    pub wp_flags: ushort_t,
    pub wp_read: illumos_sys_hdrs::c_short,
    pub wp_write: illumos_sys_hdrs::c_short,
    pub wp_exec: illumos_sys_hdrs::c_short,
}
pub type watched_page_t = watched_page;
unsafe extern "C" {
    pub fn copyin_nowatch(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn copyout_nowatch(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fuword32_nowatch(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn suword32_nowatch(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn suword64_nowatch(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: u64,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fuword64_nowatch(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut u64,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn watch_disable_addr(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: usize,
        arg3: seg_rw,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn watch_enable_addr(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: usize,
        arg3: seg_rw,
    );
}
unsafe extern "C" {
    pub fn watch_enable(arg1: kthread_id_t);
}
unsafe extern "C" {
    pub fn watch_disable(arg1: kthread_id_t);
}
unsafe extern "C" {
    pub fn setallwatch();
}
unsafe extern "C" {
    pub fn pr_is_watchpage(
        arg1: caddr_t,
        arg2: seg_rw,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn pr_is_watchpage_as(
        arg1: caddr_t,
        arg2: seg_rw,
        arg3: *mut as_,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn pr_is_watchpoint(
        arg1: *mut caddr_t,
        arg2: *mut illumos_sys_hdrs::c_int,
        arg3: usize,
        arg4: *mut usize,
        arg5: seg_rw,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn do_watch_step(
        arg1: caddr_t,
        arg2: usize,
        arg3: seg_rw,
        arg4: illumos_sys_hdrs::c_int,
        arg5: greg_t,
    );
}
unsafe extern "C" {
    pub fn undo_watch_step(arg1: *mut k_siginfo) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn wp_compare(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *const illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn wa_compare(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *const illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut watch_copyops: copyops;
}
unsafe extern "C" {
    pub fn pr_find_watched_area(
        arg1: *mut proc_,
        arg2: *mut watched_area_t,
        arg3: *mut avl_index_t,
    ) -> *mut watched_area_t;
}
unsafe extern "C" {
    pub static mut timer_max: illumos_sys_hdrs::c_int;
}
pub type itimer_t = itimer;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct itimer {
    pub it_itime: itimerspec_t,
    pub it_hrtime: hrtime_t,
    pub it_flags: ushort_t,
    pub it_lock: ushort_t,
    pub it_arg: *mut illumos_sys_hdrs::c_void,
    pub it_proc: *mut proc_,
    pub __data: itimer__bindgen_ty_1,
    pub it_cv: kcondvar_t,
    pub it_blockers: illumos_sys_hdrs::c_int,
    pub it_pending: illumos_sys_hdrs::c_int,
    pub it_overrun: illumos_sys_hdrs::c_int,
    pub it_backend: *mut clock_backend,
    pub it_fire:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut itimer_t)>,
    pub it_mutex: kmutex_t,
    pub it_portev: *mut illumos_sys_hdrs::c_void,
    pub it_portsrc: *mut illumos_sys_hdrs::c_void,
    pub it_portfd: illumos_sys_hdrs::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union itimer__bindgen_ty_1 {
    pub __proc: itimer__bindgen_ty_1__bindgen_ty_1,
    pub __it_frontend: *mut illumos_sys_hdrs::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimer__bindgen_ty_1__bindgen_ty_1 {
    pub __it_sigq: *mut sigqueue_t,
    pub __it_lwp: *mut klwp_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clock_backend {
    pub clk_default: sigevent,
    pub clk_clock_settime: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut timespec_t) -> illumos_sys_hdrs::c_int,
    >,
    pub clk_clock_gettime: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut timespec_t) -> illumos_sys_hdrs::c_int,
    >,
    pub clk_clock_getres: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut timespec_t) -> illumos_sys_hdrs::c_int,
    >,
    pub clk_timer_create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut itimer_t,
            arg2: ::core::option::Option<
                unsafe extern "C" fn(arg1: *mut itimer_t),
            >,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub clk_timer_settime: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut itimer_t,
            arg2: illumos_sys_hdrs::c_int,
            arg3: *const itimerspec,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub clk_timer_gettime: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut itimer_t,
            arg2: *mut itimerspec,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub clk_timer_delete: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut itimer_t) -> illumos_sys_hdrs::c_int,
    >,
    pub clk_timer_lwpbind:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut itimer_t)>,
}
pub type clock_backend_t = clock_backend;
unsafe extern "C" {
    pub fn clock_add_backend(clock: clockid_t, backend: *mut clock_backend_t);
}
unsafe extern "C" {
    pub fn clock_get_backend(clock: clockid_t) -> *mut clock_backend_t;
}
unsafe extern "C" {
    pub fn timer_lwpbind();
}
unsafe extern "C" {
    pub fn timer_func(arg1: *mut sigqueue_t);
}
unsafe extern "C" {
    pub fn timer_exit();
}
unsafe extern "C" {
    pub fn timer_lwpexit();
}
unsafe extern "C" {
    pub fn hzto(arg1: *mut timeval) -> clock_t;
}
unsafe extern "C" {
    pub fn timespectohz(arg1: *mut timespec_t, arg2: timespec_t) -> clock_t;
}
unsafe extern "C" {
    pub fn timespectohz64(arg1: *mut timespec_t) -> i64;
}
unsafe extern "C" {
    pub fn itimerspecfix(arg1: *mut timespec_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn timespecadd(arg1: *mut timespec_t, arg2: *mut timespec_t);
}
unsafe extern "C" {
    pub fn timespecsub(arg1: *mut timespec_t, arg2: *mut timespec_t);
}
unsafe extern "C" {
    pub fn timespecfix(arg1: *mut timespec_t);
}
unsafe extern "C" {
    pub fn xgetitimer(
        arg1: uint_t,
        arg2: *mut itimerval,
        arg3: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn xsetitimer(
        arg1: uint_t,
        arg2: *mut itimerval,
        arg3: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn delete_itimer_realprof();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct oldsigevent {
    pub _notify: illumos_sys_hdrs::c_int,
    pub _un: oldsigevent__bindgen_ty_1,
    pub _value: sigval,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union oldsigevent__bindgen_ty_1 {
    pub _signo: illumos_sys_hdrs::c_int,
    pub _notify_function:
        ::core::option::Option<unsafe extern "C" fn(arg1: sigval)>,
}
pub type utrap_entry_t = illumos_sys_hdrs::c_int;
pub type utrap_handler_t = *mut illumos_sys_hdrs::c_void;
pub type rctl_qty_t = u_longlong_t;
pub type rctl_priv_t = illumos_sys_hdrs::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rctlblk {
    _unused: [u8; 0],
}
pub type rctlblk_t = rctlblk;
unsafe extern "C" {
    pub fn setrctl(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut rctlblk_t,
        arg3: *mut rctlblk_t,
        arg4: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn getrctl(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut rctlblk_t,
        arg3: *mut rctlblk_t,
        arg4: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
pub const rctl_entity_t_RCENTITY_PROCESS: rctl_entity_t = 0;
pub const rctl_entity_t_RCENTITY_TASK: rctl_entity_t = 1;
pub const rctl_entity_t_RCENTITY_PROJECT: rctl_entity_t = 2;
pub const rctl_entity_t_RCENTITY_ZONE: rctl_entity_t = 3;
pub type rctl_entity_t = illumos_sys_hdrs::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rctl_val {
    pub rcv_prev: *mut rctl_val,
    pub rcv_next: *mut rctl_val,
    pub rcv_privilege: rctl_priv_t,
    pub rcv_value: rctl_qty_t,
    pub rcv_flagaction: uint_t,
    pub rcv_action_signal: illumos_sys_hdrs::c_int,
    pub rcv_action_recipient: *mut proc_,
    pub rcv_action_recip_pid: id_t,
    pub rcv_firing_time: hrtime_t,
}
pub type rctl_val_t = rctl_val;
pub type rctl_hndl_t = illumos_sys_hdrs::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rctl_entity_p_struct {
    pub rcep_t: rctl_entity_t,
    pub rcep_p: rctl_entity_p_struct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rctl_entity_p_struct__bindgen_ty_1 {
    pub proc_: *mut proc_,
    pub task: *mut task,
    pub proj: *mut kproject,
    pub zone: *mut zone,
}
pub type rctl_entity_p_t = rctl_entity_p_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rctl_ops {
    pub rco_action: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rctl,
            arg2: *mut proc_,
            arg3: *mut rctl_entity_p_t,
        ),
    >,
    pub rco_get_usage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rctl, arg2: *mut proc_) -> rctl_qty_t,
    >,
    pub rco_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rctl,
            arg2: *mut proc_,
            arg3: *mut rctl_entity_p_t,
            arg4: rctl_qty_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub rco_test: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rctl,
            arg2: *mut proc_,
            arg3: *mut rctl_entity_p_t,
            arg4: *mut rctl_val_t,
            arg5: rctl_qty_t,
            arg6: uint_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
}
pub type rctl_ops_t = rctl_ops;
unsafe extern "C" {
    pub fn rcop_no_action(
        arg1: *mut rctl,
        arg2: *mut proc_,
        arg3: *mut rctl_entity_p_t,
    );
}
unsafe extern "C" {
    pub fn rcop_no_usage(arg1: *mut rctl, arg2: *mut proc_) -> rctl_qty_t;
}
unsafe extern "C" {
    pub fn rcop_no_set(
        arg1: *mut rctl,
        arg2: *mut proc_,
        arg3: *mut rctl_entity_p_t,
        arg4: rctl_qty_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rcop_no_test(
        arg1: *mut rctl,
        arg2: *mut proc_,
        arg3: *mut rctl_entity_p_t,
        arg4: *mut rctl_val,
        arg5: rctl_qty_t,
        arg6: uint_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rcop_absolute_test(
        arg1: *mut rctl,
        arg2: *mut proc_,
        arg3: *mut rctl_entity_p_t,
        arg4: *mut rctl_val,
        arg5: rctl_qty_t,
        arg6: uint_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut rctl_default_ops: rctl_ops_t;
}
unsafe extern "C" {
    pub static mut rctl_absolute_ops: rctl_ops_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rctl {
    pub rc_next: *mut rctl,
    pub rc_values: *mut rctl_val_t,
    pub rc_cursor: *mut rctl_val_t,
    pub rc_dict_entry: *mut rctl_dict_entry,
    pub rc_id: rctl_hndl_t,
    pub rc_projdb: *mut rctl_val_t,
}
pub type rctl_t = rctl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rctl_set {
    pub rcs_lock: kmutex_t,
    pub rcs_entity: rctl_entity_t,
    pub rcs_ctls: *mut *mut rctl_t,
}
pub type rctl_set_t = rctl_set;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rctl_dict_entry {
    pub rcd_next: *mut rctl_dict_entry,
    pub rcd_name: *mut illumos_sys_hdrs::c_char,
    pub rcd_default_value: *mut rctl_val_t,
    pub rcd_ops: *mut rctl_ops_t,
    pub rcd_id: rctl_hndl_t,
    pub rcd_entity: rctl_entity_t,
    pub rcd_flagaction: illumos_sys_hdrs::c_int,
    pub rcd_syslog_level: illumos_sys_hdrs::c_int,
    pub rcd_strlog_flags: illumos_sys_hdrs::c_int,
    pub rcd_max_native: rctl_qty_t,
    pub rcd_max_ilp32: rctl_qty_t,
}
pub type rctl_dict_entry_t = rctl_dict_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rctl_alloc_gp {
    pub rcag_nctls: uint_t,
    pub rcag_nvals: uint_t,
    pub rcag_ctls: *mut rctl_t,
    pub rcag_vals: *mut rctl_val_t,
}
pub type rctl_alloc_gp_t = rctl_alloc_gp;
unsafe extern "C" {
    pub static mut rctl_cache: *mut kmem_cache_t;
}
unsafe extern "C" {
    pub static mut rctl_val_cache: *mut kmem_cache_t;
}
unsafe extern "C" {
    pub static mut rctlproc_legacy: [rctl_hndl_t; 0usize];
}
unsafe extern "C" {
    pub static mut rctlproc_flags: [uint_t; 0usize];
}
unsafe extern "C" {
    pub static mut rctlproc_signals: [illumos_sys_hdrs::c_int; 0usize];
}
unsafe extern "C" {
    pub fn rctl_init();
}
unsafe extern "C" {
    pub fn rctlproc_init();
}
unsafe extern "C" {
    pub fn rctlproc_default_init(arg1: *mut proc_, arg2: *mut rctl_alloc_gp_t);
}
unsafe extern "C" {
    pub fn rctl_register(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: rctl_entity_t,
        arg3: illumos_sys_hdrs::c_int,
        arg4: rctl_qty_t,
        arg5: rctl_qty_t,
        arg6: *mut rctl_ops_t,
    ) -> rctl_hndl_t;
}
unsafe extern "C" {
    pub fn rctl_hndl_lookup(
        arg1: *const illumos_sys_hdrs::c_char,
    ) -> rctl_hndl_t;
}
unsafe extern "C" {
    pub fn rctl_dict_lookup(
        arg1: *const illumos_sys_hdrs::c_char,
    ) -> *mut rctl_dict_entry_t;
}
unsafe extern "C" {
    pub fn rctl_dict_lookup_hndl(arg1: rctl_hndl_t) -> *mut rctl_dict_entry_t;
}
unsafe extern "C" {
    pub fn rctl_add_default_limit(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: rctl_qty_t,
        arg3: rctl_priv_t,
        arg4: uint_t,
    );
}
unsafe extern "C" {
    pub fn rctl_add_legacy_limit(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
        arg3: *const illumos_sys_hdrs::c_char,
        arg4: rctl_qty_t,
        arg5: rctl_qty_t,
    );
}
unsafe extern "C" {
    pub fn rctl_model_maximum(
        arg1: *mut rctl_dict_entry_t,
        arg2: *mut proc_,
    ) -> rctl_qty_t;
}
unsafe extern "C" {
    pub fn rctl_model_value(
        arg1: *mut rctl_dict_entry_t,
        arg2: *mut proc_,
        arg3: rctl_qty_t,
    ) -> rctl_qty_t;
}
unsafe extern "C" {
    pub fn rctl_invalid_value(
        arg1: *mut rctl_dict_entry_t,
        arg2: *mut rctl_val_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_enforced_value(
        arg1: rctl_hndl_t,
        arg2: *mut rctl_set_t,
        arg3: *mut proc_,
    ) -> rctl_qty_t;
}
unsafe extern "C" {
    pub fn rctl_test(
        arg1: rctl_hndl_t,
        arg2: *mut rctl_set_t,
        arg3: *mut proc_,
        arg4: rctl_qty_t,
        arg5: uint_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_action(
        arg1: rctl_hndl_t,
        arg2: *mut rctl_set_t,
        arg3: *mut proc_,
        arg4: uint_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_test_entity(
        arg1: rctl_hndl_t,
        arg2: *mut rctl_set_t,
        arg3: *mut proc_,
        arg4: *mut rctl_entity_p_t,
        arg5: rctl_qty_t,
        arg6: uint_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_action_entity(
        arg1: rctl_hndl_t,
        arg2: *mut rctl_set_t,
        arg3: *mut proc_,
        arg4: *mut rctl_entity_p_t,
        arg5: uint_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_val_cmp(
        arg1: *mut rctl_val_t,
        arg2: *mut rctl_val_t,
        arg3: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_val_list_insert(
        arg1: *mut *mut rctl_val_t,
        arg2: *mut rctl_val_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_set_create() -> *mut rctl_set_t;
}
unsafe extern "C" {
    pub fn rctl_entity_obtain_rset(
        arg1: *mut rctl_dict_entry_t,
        arg2: *mut proc_,
    ) -> *mut rctl_set_t;
}
unsafe extern "C" {
    pub fn rctl_set_init_prealloc(arg1: rctl_entity_t) -> *mut rctl_alloc_gp_t;
}
unsafe extern "C" {
    pub fn rctl_set_init(
        arg1: rctl_entity_t,
        arg2: *mut proc_,
        arg3: *mut rctl_entity_p_t,
        arg4: *mut rctl_set_t,
        arg5: *mut rctl_alloc_gp_t,
    ) -> *mut rctl_set_t;
}
unsafe extern "C" {
    pub fn rctl_set_dup_prealloc(arg1: *mut rctl_set_t)
        -> *mut rctl_alloc_gp_t;
}
unsafe extern "C" {
    pub fn rctl_set_dup_ready(
        arg1: *mut rctl_set_t,
        arg2: *mut rctl_alloc_gp_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_set_dup(
        arg1: *mut rctl_set_t,
        arg2: *mut proc_,
        arg3: *mut proc_,
        arg4: *mut rctl_entity_p_t,
        arg5: *mut rctl_set_t,
        arg6: *mut rctl_alloc_gp_t,
        arg7: illumos_sys_hdrs::c_int,
    ) -> *mut rctl_set_t;
}
unsafe extern "C" {
    pub fn rctl_set_reset(
        arg1: *mut rctl_set_t,
        arg2: *mut proc_,
        arg3: *mut rctl_entity_p_t,
    );
}
unsafe extern "C" {
    pub fn rctl_set_tearoff(arg1: *mut rctl_set_t, arg2: *mut proc_);
}
unsafe extern "C" {
    pub fn rctl_set_find(
        arg1: *mut rctl_set_t,
        arg2: rctl_hndl_t,
        arg3: *mut *mut rctl_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_set_free(arg1: *mut rctl_set_t);
}
unsafe extern "C" {
    pub fn rctl_prealloc_destroy(arg1: *mut rctl_alloc_gp_t);
}
unsafe extern "C" {
    pub fn rctl_build_name_buf(
        arg1: *mut *mut illumos_sys_hdrs::c_char,
    ) -> usize;
}
unsafe extern "C" {
    pub fn rctl_global_get(
        name: *const illumos_sys_hdrs::c_char,
        arg1: *mut rctl_dict_entry_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_global_set(
        name: *const illumos_sys_hdrs::c_char,
        arg1: *mut rctl_dict_entry_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_local_delete(
        arg1: rctl_hndl_t,
        arg2: *mut rctl_val_t,
        p: *mut proc_,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_local_insert(
        arg1: rctl_hndl_t,
        arg2: *mut rctl_val_t,
        p: *mut proc_,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_local_insert_all(
        arg1: rctl_hndl_t,
        arg2: *mut rctl_val_t,
        arg3: *mut rctl_val_t,
        p: *mut proc_,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_local_replace_all(
        arg1: rctl_hndl_t,
        arg2: *mut rctl_val_t,
        arg3: *mut rctl_val_t,
        p: *mut proc_,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_local_get(
        arg1: rctl_hndl_t,
        arg2: *mut rctl_val_t,
        arg3: *mut rctl_val_t,
        p: *mut proc_,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_local_replace(
        arg1: rctl_hndl_t,
        arg2: *mut rctl_val_t,
        arg3: *mut rctl_val_t,
        p: *mut proc_,
    ) -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cred {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn rctl_rlimit_set_prealloc(arg1: uint_t) -> *mut rctl_alloc_gp_t;
}
unsafe extern "C" {
    pub fn rctl_rlimit_set(
        arg1: rctl_hndl_t,
        arg2: *mut proc_,
        arg3: *mut rlimit64,
        arg4: *mut rctl_alloc_gp_t,
        arg5: illumos_sys_hdrs::c_int,
        arg6: illumos_sys_hdrs::c_int,
        arg7: *const cred,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_rlimit_get(
        arg1: rctl_hndl_t,
        arg2: *mut proc_,
        arg3: *mut rlimit64,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_incr_locked_mem(
        arg1: *mut proc_,
        arg2: *mut kproject,
        arg3: rctl_qty_t,
        arg4: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_decr_locked_mem(
        arg1: *mut proc_,
        arg2: *mut kproject,
        arg3: rctl_qty_t,
        arg4: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn rctl_incr_swap(
        arg1: *mut proc_,
        arg2: *mut zone,
        arg3: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_decr_swap(arg1: *mut zone, arg2: usize);
}
unsafe extern "C" {
    pub fn rctl_incr_lofi(
        arg1: *mut proc_,
        arg2: *mut zone,
        arg3: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rctl_decr_lofi(arg1: *mut zone, arg2: usize);
}
unsafe extern "C" {
    pub fn rctl_kstat_create_zone(
        arg1: *mut zone,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: uchar_t,
        arg4: uint_t,
        arg5: uchar_t,
    ) -> *mut kstat;
}
unsafe extern "C" {
    pub fn rctl_kstat_create_project(
        arg1: *mut kproject,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: uchar_t,
        arg4: uint_t,
        arg5: uchar_t,
    ) -> *mut kstat;
}
unsafe extern "C" {
    pub fn rctl_kstat_create_task(
        arg1: *mut task,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: uchar_t,
        arg4: uint_t,
        arg5: uchar_t,
    ) -> *mut kstat;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct door_pool {
    pub dp_threads: *mut _kthread,
    pub dp_cv: kcondvar_t,
}
pub type door_pool_t = door_pool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signalfd_siginfo {
    pub ssi_signo: u32,
    pub ssi_errno: i32,
    pub ssi_code: i32,
    pub ssi_pid: u32,
    pub ssi_uid: u32,
    pub ssi_fd: i32,
    pub ssi_tid: u32,
    pub ssi_band: u32,
    pub ssi_overrun: u32,
    pub ssi_trapno: u32,
    pub ssi_status: i32,
    pub ssi_int: i32,
    pub ssi_ptr: u64,
    pub ssi_utime: u64,
    pub ssi_stime: u64,
    pub ssi_addr: u64,
    pub ssi_pad: [u8; 48usize],
}
pub type signalfd_siginfo_t = signalfd_siginfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigfd_proc_state {
    pub sigfd_pollwake_cb: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut illumos_sys_hdrs::c_void,
            arg2: illumos_sys_hdrs::c_int,
        ),
    >,
    pub sigfd_list: list_t,
}
pub type sigfd_proc_state_t = sigfd_proc_state;
unsafe extern "C" {
    pub static mut sigfd_exit_helper:
        ::core::option::Option<unsafe extern "C" fn()>;
}
pub type secflagset_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psecflags {
    pub psf_effective: secflagset_t,
    pub psf_inherit: secflagset_t,
    pub psf_lower: secflagset_t,
    pub psf_upper: secflagset_t,
}
pub type psecflags_t = psecflags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct secflagdelta {
    pub psd_add: secflagset_t,
    pub psd_rem: secflagset_t,
    pub psd_assign: secflagset_t,
    pub psd_ass_active: boolean_t,
}
pub type secflagdelta_t = secflagdelta;
pub const psecflagwhich_t_PSF_EFFECTIVE: psecflagwhich_t = 0;
pub const psecflagwhich_t_PSF_INHERIT: psecflagwhich_t = 1;
pub const psecflagwhich_t_PSF_LOWER: psecflagwhich_t = 2;
pub const psecflagwhich_t_PSF_UPPER: psecflagwhich_t = 3;
pub type psecflagwhich_t = illumos_sys_hdrs::c_uint;
pub const secflag_t_PROC_SEC_ASLR: secflag_t = 0;
pub const secflag_t_PROC_SEC_FORBIDNULLMAP: secflag_t = 1;
pub const secflag_t_PROC_SEC_NOEXECSTACK: secflag_t = 2;
pub type secflag_t = illumos_sys_hdrs::c_uint;
unsafe extern "C" {
    pub fn secflag_to_bit(arg1: secflag_t) -> secflagset_t;
}
unsafe extern "C" {
    pub fn secflag_isset(arg1: secflagset_t, arg2: secflag_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn secflag_clear(arg1: *mut secflagset_t, arg2: secflag_t);
}
unsafe extern "C" {
    pub fn secflag_set(arg1: *mut secflagset_t, arg2: secflag_t);
}
unsafe extern "C" {
    pub fn secflags_isempty(arg1: secflagset_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn secflags_zero(arg1: *mut secflagset_t);
}
unsafe extern "C" {
    pub fn secflags_fullset(arg1: *mut secflagset_t);
}
unsafe extern "C" {
    pub fn secflags_copy(arg1: *mut secflagset_t, arg2: *const secflagset_t);
}
unsafe extern "C" {
    pub fn secflags_issubset(
        arg1: secflagset_t,
        arg2: secflagset_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn secflags_issuperset(
        arg1: secflagset_t,
        arg2: secflagset_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn secflags_intersection(
        arg1: secflagset_t,
        arg2: secflagset_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn secflags_union(arg1: *mut secflagset_t, arg2: *const secflagset_t);
}
unsafe extern "C" {
    pub fn secflags_difference(
        arg1: *mut secflagset_t,
        arg2: *const secflagset_t,
    );
}
unsafe extern "C" {
    pub fn psecflags_validate_delta(
        arg1: *const psecflags_t,
        arg2: *const secflagdelta_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn psecflags_validate(arg1: *const psecflags_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn psecflags_default(sf: *mut psecflags_t);
}
unsafe extern "C" {
    pub fn secflag_to_str(arg1: secflag_t) -> *const illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn secflag_by_name(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut secflag_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn secflags_to_str(
        arg1: secflagset_t,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: usize,
    );
}
unsafe extern "C" {
    pub fn secflag_enabled(arg1: *mut proc_, arg2: secflag_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn secflags_promote(arg1: *mut proc_);
}
unsafe extern "C" {
    pub fn secflags_apply_delta(
        arg1: *mut secflagset_t,
        arg2: *const secflagdelta_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct prof {
    pub pr_base: *mut illumos_sys_hdrs::c_void,
    pub pr_off: usize,
    pub pr_size: usize,
    pub pr_scale: u32,
    pub pr_samples: illumos_sys_hdrs::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lwpent {
    pub le_thread: *mut kthread_t,
    pub le_lwpid: id_t,
    pub le_waiters: u16,
    pub le_dwaiters: u16,
    pub le_start: clock_t,
    pub le_trace: *mut vnode,
}
pub type lwpent_t = lwpent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pctxop {
    pub save_op: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
    >,
    pub restore_op: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
    >,
    pub fork_op: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut illumos_sys_hdrs::c_void,
            arg2: *mut illumos_sys_hdrs::c_void,
        ),
    >,
    pub exit_op: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
    >,
    pub free_op: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut illumos_sys_hdrs::c_void,
            arg2: illumos_sys_hdrs::c_int,
        ),
    >,
    pub arg: *mut illumos_sys_hdrs::c_void,
    pub next: *mut pctxop,
}
pub type pctxop_t = pctxop;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lwpdir {
    pub ld_next: *mut lwpdir,
    pub ld_entry: *mut lwpent,
}
pub type lwpdir_t = lwpdir;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tidhash {
    pub th_lock: kmutex_t,
    pub th_list: *mut lwpdir_t,
}
pub type tidhash_t = tidhash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ret_tidhash {
    pub rth_next: *mut ret_tidhash,
    pub rth_tidhash: *mut tidhash_t,
    pub rth_tidhash_sz: uint_t,
}
pub type ret_tidhash_t = ret_tidhash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct brand {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct corectl_path {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct corectl_content {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct proc_ {
    pub p_exec: *mut vnode,
    pub p_as: *mut as_,
    pub p_lockp: *mut plock,
    pub p_crlock: kmutex_t,
    pub p_cred: *mut cred,
    pub p_swapcnt: illumos_sys_hdrs::c_int,
    pub p_stat: illumos_sys_hdrs::c_char,
    pub p_wcode: illumos_sys_hdrs::c_char,
    pub p_pidflag: ushort_t,
    pub p_wdata: illumos_sys_hdrs::c_int,
    pub p_ppid: pid_t,
    pub p_link: *mut proc_,
    pub p_parent: *mut proc_,
    pub p_child: *mut proc_,
    pub p_sibling: *mut proc_,
    pub p_psibling: *mut proc_,
    pub p_sibling_ns: *mut proc_,
    pub p_child_ns: *mut proc_,
    pub p_next: *mut proc_,
    pub p_prev: *mut proc_,
    pub p_nextofkin: *mut proc_,
    pub p_orphan: *mut proc_,
    pub p_nextorph: *mut proc_,
    pub p_pglink: *mut proc_,
    pub p_ppglink: *mut proc_,
    pub p_sessp: *mut sess,
    pub p_pidp: *mut pid,
    pub p_pgidp: *mut pid,
    pub p_cv: kcondvar_t,
    pub p_flag_cv: kcondvar_t,
    pub p_lwpexit: kcondvar_t,
    pub p_holdlwps: kcondvar_t,
    pub p_proc_flag: uint_t,
    pub p_flag: uint_t,
    pub p_utime: clock_t,
    pub p_stime: clock_t,
    pub p_cutime: clock_t,
    pub p_cstime: clock_t,
    pub p_segacct: *mut avl_tree_t,
    pub p_semacct: *mut avl_tree_t,
    pub p_bssbase: caddr_t,
    pub p_brkbase: caddr_t,
    pub p_brksize: usize,
    pub p_brkpageszc: uint_t,
    pub p_sig: k_sigset_t,
    pub p_extsig: k_sigset_t,
    pub p_ignore: k_sigset_t,
    pub p_siginfo: k_sigset_t,
    pub p_sigfd: *mut illumos_sys_hdrs::c_void,
    pub p_sigqueue: *mut sigqueue,
    pub p_sigqhdr: *mut sigqhdr,
    pub p_signhdr: *mut sigqhdr,
    pub p_stopsig: uchar_t,
    pub p_fixalignment: illumos_sys_hdrs::c_char,
    pub p_lwpid: id_t,
    pub p_lwpcnt: illumos_sys_hdrs::c_int,
    pub p_lwprcnt: illumos_sys_hdrs::c_int,
    pub p_lwpdaemon: illumos_sys_hdrs::c_int,
    pub p_lwpwait: illumos_sys_hdrs::c_int,
    pub p_lwpdwait: illumos_sys_hdrs::c_int,
    pub p_zombcnt: illumos_sys_hdrs::c_int,
    pub p_tlist: *mut kthread_t,
    pub p_lwpdir: *mut lwpdir_t,
    pub p_lwpfree: *mut lwpdir_t,
    pub p_tidhash: *mut tidhash_t,
    pub p_lwpdir_sz: uint_t,
    pub p_tidhash_sz: uint_t,
    pub p_ret_tidhash: *mut ret_tidhash_t,
    pub p_lgrpset: u64,
    pub p_t1_lgrpid: lgrp_id_t,
    pub p_tr_lgrpid: lgrp_id_t,
    pub p_lgrpres2: usize,
    pub p_sigmask: k_sigset_t,
    pub p_fltmask: k_fltset_t,
    pub p_trace: *mut vnode,
    pub p_plist: *mut vnode,
    pub p_agenttp: *mut kthread_t,
    pub p_warea: avl_tree_t,
    pub p_wpage: avl_tree_t,
    pub p_wprot: *mut watched_page_t,
    pub p_mapcnt: illumos_sys_hdrs::c_int,
    pub p_maplock: kmutex_t,
    pub p_rlink: *mut proc_,
    pub p_srwchan_cv: kcondvar_t,
    pub p_stksize: usize,
    pub p_stkpageszc: uint_t,
    pub p_stkg_start: usize,
    pub p_stkg_end: usize,
    pub p_mstart: hrtime_t,
    pub p_mterm: hrtime_t,
    pub p_mlreal: hrtime_t,
    pub p_acct: [hrtime_t; 10usize],
    pub p_cacct: [hrtime_t; 10usize],
    pub p_ru: lrusage,
    pub p_cru: lrusage,
    pub p_rprof_timer: itimerval,
    pub p_rprof_cyclic: usize,
    pub p_defunct: uint_t,
    pub p_pflock: kmutex_t,
    pub p_prof: prof,
    pub p_server_threads: door_pool_t,
    pub p_door_list: *mut door_node,
    pub p_unref_list: *mut door_node,
    pub p_unref_cv: kcondvar_t,
    pub p_unref_thread: illumos_sys_hdrs::c_char,
    pub p_audit_data: *mut p_audit_data,
    pub p_pctx: *mut pctxop_t,
    pub p_ldtlock: kmutex_t,
    pub p_ldt: *mut user_desc_t,
    pub p_unused1: u64,
    pub p_unused2: u64,
    pub p_ldtlimit: ushort_t,
    pub p_swrss: usize,
    pub p_aio: *mut aio,
    pub p_itimer: *mut *mut itimer,
    pub p_itimer_sz: uint_t,
    pub p_alarmid: timeout_id_t,
    pub p_usrstack: caddr_t,
    pub p_stkprot: uint_t,
    pub p_datprot: uint_t,
    pub p_model: model_t,
    pub p_lcp: *mut lwpchan_data,
    pub p_lcp_lock: kmutex_t,
    pub p_utraps: *mut utrap_handler_t,
    pub p_corefile: *mut corectl_path,
    pub p_task: *mut task,
    pub p_taskprev: *mut proc_,
    pub p_tasknext: *mut proc_,
    pub p_sc_lock: kmutex_t,
    pub p_pagep: *mut sc_page_ctl,
    pub p_rctls: *mut rctl_set,
    pub p_stk_ctl: rlim64_t,
    pub p_fsz_ctl: rlim64_t,
    pub p_vmem_ctl: rlim64_t,
    pub p_fno_ctl: rlim64_t,
    pub p_ancpid: pid_t,
    pub p_realitimer: itimerval,
    pub p_itimerid: timeout_id_t,
    pub p_content: *mut corectl_content,
    pub p_ct_held: avl_tree_t,
    pub p_ct_equeue: *mut *mut ct_equeue,
    pub p_ct_process: *mut cont_process,
    pub p_ct_member: list_node_t,
    pub p_killsqp: *mut sigqueue_t,
    pub p_dtrace_probes: illumos_sys_hdrs::c_int,
    pub p_dtrace_count: u64,
    pub p_dtrace_helpers: *mut illumos_sys_hdrs::c_void,
    pub p_pool: *mut pool,
    pub p_poolcv: kcondvar_t,
    pub p_poolcnt: uint_t,
    pub p_poolflag: uint_t,
    pub p_upanicflag: uint_t,
    pub p_upanic: *mut illumos_sys_hdrs::c_void,
    pub p_portcnt: usize,
    pub p_zone: *mut zone,
    pub p_execdir: *mut vnode,
    pub p_brand: *mut brand,
    pub p_brand_data: *mut illumos_sys_hdrs::c_void,
    pub p_secflags: psecflags_t,
    pub p_splock: kmutex_t,
    pub p_locked_mem: rctl_qty_t,
    pub p_crypto_mem: rctl_qty_t,
    pub p_ttime: clock_t,
    pub p_user: user,
}
pub type proc_t = proc_;
unsafe extern "C" {
    pub static mut practive: *mut proc_t;
}
unsafe extern "C" {
    pub static mut proc_sched: *mut proc_t;
}
unsafe extern "C" {
    pub static mut proc_init: *mut proc_t;
}
unsafe extern "C" {
    pub static mut proc_pageout: *mut proc_t;
}
unsafe extern "C" {
    pub static mut proc_fsflush: *mut proc_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct upcount {
    pub up_next: *mut upcount,
    pub up_uid: uid_t,
    pub up_zoneid: zoneid_t,
    pub up_count: uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pid {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub pid_id: pid_t,
    pub pid_pglink: *mut proc_,
    pub pid_pgtail: *mut proc_,
    pub pid_link: *mut pid,
    pub pid_ref: uint_t,
}
impl pid {
    #[inline]
    pub fn pid_prinactive(&self) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_pid_prinactive(&mut self, val: illumos_sys_hdrs::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pid_prinactive_raw(
        this: *const Self,
    ) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_pid_prinactive_raw(
        this: *mut Self,
        val: illumos_sys_hdrs::c_uint,
    ) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pid_pgorphaned(&self) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_pid_pgorphaned(&mut self, val: illumos_sys_hdrs::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pid_pgorphaned_raw(
        this: *const Self,
    ) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    1usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_pid_pgorphaned_raw(
        this: *mut Self,
        val: illumos_sys_hdrs::c_uint,
    ) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pid_padding(&self) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u32)
        }
    }
    #[inline]
    pub fn set_pid_padding(&mut self, val: illumos_sys_hdrs::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pid_padding_raw(
        this: *const Self,
    ) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    2usize,
                    6u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_pid_padding_raw(
        this: *mut Self,
        val: illumos_sys_hdrs::c_uint,
    ) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pid_prslot(&self) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32)
        }
    }
    #[inline]
    pub fn set_pid_prslot(&mut self, val: illumos_sys_hdrs::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pid_prslot_raw(
        this: *const Self,
    ) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    8usize,
                    24u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_pid_prslot_raw(
        this: *mut Self,
        val: illumos_sys_hdrs::c_uint,
    ) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pid_prinactive: illumos_sys_hdrs::c_uint,
        pid_pgorphaned: illumos_sys_hdrs::c_uint,
        pid_padding: illumos_sys_hdrs::c_uint,
        pid_prslot: illumos_sys_hdrs::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pid_prinactive: u32 =
                unsafe { ::core::mem::transmute(pid_prinactive) };
            pid_prinactive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let pid_pgorphaned: u32 =
                unsafe { ::core::mem::transmute(pid_pgorphaned) };
            pid_pgorphaned as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let pid_padding: u32 =
                unsafe { ::core::mem::transmute(pid_padding) };
            pid_padding as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let pid_prslot: u32 = unsafe { ::core::mem::transmute(pid_prslot) };
            pid_prslot as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plock {
    pub pl_lock: kmutex_t,
}
unsafe extern "C" {
    pub static mut p0: proc_t;
}
unsafe extern "C" {
    pub static mut p0lock: plock;
}
unsafe extern "C" {
    pub static mut pid0: pid;
}
pub const lwp_stat_id_t_LWP_STAT_INBLK: lwp_stat_id_t = 0;
pub const lwp_stat_id_t_LWP_STAT_OUBLK: lwp_stat_id_t = 1;
pub const lwp_stat_id_t_LWP_STAT_MSGRCV: lwp_stat_id_t = 2;
pub const lwp_stat_id_t_LWP_STAT_MSGSND: lwp_stat_id_t = 3;
pub type lwp_stat_id_t = illumos_sys_hdrs::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prkillinfo {
    pub prk_error: i32,
    pub prk_pad: i32,
    pub prk_info: siginfo_t,
}
pub type prkillinfo_t = prkillinfo;
unsafe extern "C" {
    pub fn profil_tick(arg1: usize);
}
unsafe extern "C" {
    pub fn newproc(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
        arg2: caddr_t,
        arg3: id_t,
        arg4: illumos_sys_hdrs::c_int,
        arg5: *mut *mut contract,
        arg6: pid_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn vfwait(arg1: pid_t);
}
unsafe extern "C" {
    pub fn proc_detach(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn freeproc(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn setrun(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn setrun_locked(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn exit(
        arg1: illumos_sys_hdrs::c_int,
        arg2: illumos_sys_hdrs::c_int,
    ) -> !;
}
unsafe extern "C" {
    pub fn proc_exit(
        arg1: illumos_sys_hdrs::c_int,
        arg2: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn proc_is_exiting(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn relvm();
}
unsafe extern "C" {
    pub fn add_ns(arg1: *mut proc_t, arg2: *mut proc_t);
}
unsafe extern "C" {
    pub fn delete_ns(arg1: *mut proc_t, arg2: *mut proc_t);
}
unsafe extern "C" {
    pub fn upcount_inc(arg1: uid_t, arg2: zoneid_t);
}
unsafe extern "C" {
    pub fn upcount_dec(arg1: uid_t, arg2: zoneid_t);
}
unsafe extern "C" {
    pub fn upcount_get(arg1: uid_t, arg2: zoneid_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn setup_thrptr(arg1: *mut proc_t, arg2: usize) -> selector_t;
}
unsafe extern "C" {
    pub fn deferred_singlestep_trap(arg1: caddr_t);
}
unsafe extern "C" {
    pub fn sigcld(arg1: *mut proc_t, arg2: *mut sigqueue_t);
}
unsafe extern "C" {
    pub fn sigcld_delete(arg1: *mut k_siginfo_t);
}
unsafe extern "C" {
    pub fn sigcld_repost();
}
unsafe extern "C" {
    pub fn fsig(
        arg1: *mut k_sigset_t,
        arg2: *mut kthread_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn psig();
}
unsafe extern "C" {
    pub fn stop(arg1: illumos_sys_hdrs::c_int, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn stop_on_fault(
        arg1: uint_t,
        arg2: *mut k_siginfo_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn issig(arg1: illumos_sys_hdrs::c_int) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn jobstopped(arg1: *mut proc_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn psignal(arg1: *mut proc_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn tsignal(arg1: *mut kthread_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn sigtoproc(
        arg1: *mut proc_t,
        arg2: *mut kthread_t,
        arg3: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn trapsig(arg1: *mut k_siginfo_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn realsigprof(
        arg1: illumos_sys_hdrs::c_int,
        arg2: illumos_sys_hdrs::c_int,
        arg3: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn eat_signal(
        arg1: *mut kthread_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn signal_is_blocked(
        arg1: *mut kthread_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn sigcheck(
        arg1: *mut proc_t,
        arg2: *mut kthread_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn sigdefault(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn pid_setmin();
}
unsafe extern "C" {
    pub fn pid_allocate(
        arg1: *mut proc_t,
        arg2: pid_t,
        arg3: illumos_sys_hdrs::c_int,
    ) -> pid_t;
}
unsafe extern "C" {
    pub fn pid_rele(arg1: *mut pid) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn pid_exit(arg1: *mut proc_t, arg2: *mut task);
}
unsafe extern "C" {
    pub fn proc_entry_free(arg1: *mut pid);
}
unsafe extern "C" {
    pub fn prfind(arg1: pid_t) -> *mut proc_t;
}
unsafe extern "C" {
    pub fn prfind_zone(arg1: pid_t, arg2: zoneid_t) -> *mut proc_t;
}
unsafe extern "C" {
    pub fn pgfind(arg1: pid_t) -> *mut proc_t;
}
unsafe extern "C" {
    pub fn pgfind_zone(arg1: pid_t, arg2: zoneid_t) -> *mut proc_t;
}
unsafe extern "C" {
    pub fn sprlock(arg1: pid_t) -> *mut proc_t;
}
unsafe extern "C" {
    pub fn sprlock_zone(arg1: pid_t, arg2: zoneid_t) -> *mut proc_t;
}
unsafe extern "C" {
    pub fn sprtrylock_proc(arg1: *mut proc_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn sprwaitlock_proc(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn sprlock_proc(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn sprunlock(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn pid_init();
}
unsafe extern "C" {
    pub fn pid_entry(arg1: illumos_sys_hdrs::c_int) -> *mut proc_t;
}
unsafe extern "C" {
    pub fn pid_slot(arg1: *mut proc_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn signal(arg1: pid_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn prsignal(arg1: *mut pid, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn uread(
        arg1: *mut proc_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
        arg4: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn uwrite(
        arg1: *mut proc_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
        arg4: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn pgsignal(arg1: *mut pid, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn pgjoin(arg1: *mut proc_t, arg2: *mut pid);
}
unsafe extern "C" {
    pub fn pgcreate(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn pgexit(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn pgdetach(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn pgmembers(arg1: pid_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn init_mstate(arg1: *mut kthread_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn new_mstate(
        arg1: *mut kthread_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn restore_mstate(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn term_mstate(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn estimate_msacct(arg1: *mut kthread_t, arg2: hrtime_t);
}
unsafe extern "C" {
    pub fn disable_msacct(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn mstate_aggr_state(
        arg1: *mut proc_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> hrtime_t;
}
unsafe extern "C" {
    pub fn mstate_thread_onproc_time(arg1: *mut kthread_t) -> hrtime_t;
}
unsafe extern "C" {
    pub fn mstate_systhread_times(
        arg1: *mut kthread_t,
        arg2: *mut hrtime_t,
        arg3: *mut hrtime_t,
    );
}
unsafe extern "C" {
    pub fn syscall_mstate(
        arg1: illumos_sys_hdrs::c_int,
        arg2: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn cpu_update_pct(arg1: *mut kthread_t, arg2: hrtime_t) -> uint_t;
}
unsafe extern "C" {
    pub fn set_proc_pre_sys(p: *mut proc_t);
}
unsafe extern "C" {
    pub fn set_proc_post_sys(p: *mut proc_t);
}
unsafe extern "C" {
    pub fn set_proc_sys(p: *mut proc_t);
}
unsafe extern "C" {
    pub fn set_proc_ast(p: *mut proc_t);
}
unsafe extern "C" {
    pub fn set_all_proc_sys();
}
unsafe extern "C" {
    pub fn set_all_zone_usr_proc_sys(arg1: zoneid_t);
}
unsafe extern "C" {
    pub fn thread_create(
        stk: caddr_t,
        stksize: usize,
        proc_: ::core::option::Option<unsafe extern "C" fn()>,
        arg: *mut illumos_sys_hdrs::c_void,
        len: usize,
        pp: *mut proc_t,
        state: illumos_sys_hdrs::c_int,
        pri: pri_t,
    ) -> *mut kthread_t;
}
unsafe extern "C" {
    pub fn thread_exit() -> !;
}
unsafe extern "C" {
    pub fn thread_free(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn thread_rele(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn thread_join(arg1: kt_did_t);
}
unsafe extern "C" {
    pub fn reaper() -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctxop_template {
    pub ct_rev: u32,
    pub ct_pad: u32,
    pub ct_save: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
    >,
    pub ct_restore: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
    >,
    pub ct_fork: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut illumos_sys_hdrs::c_void,
            arg2: *mut illumos_sys_hdrs::c_void,
        ),
    >,
    pub ct_lwp_create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut illumos_sys_hdrs::c_void,
            arg2: *mut illumos_sys_hdrs::c_void,
        ),
    >,
    pub ct_exit: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
    >,
    pub ct_free: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut illumos_sys_hdrs::c_void,
            arg2: illumos_sys_hdrs::c_int,
        ),
    >,
}
unsafe extern "C" {
    pub fn ctxop_allocate(
        arg1: *const ctxop_template,
        arg2: *mut illumos_sys_hdrs::c_void,
    ) -> *mut ctxop;
}
unsafe extern "C" {
    pub fn ctxop_free(arg1: *mut ctxop);
}
unsafe extern "C" {
    pub fn ctxop_attach(arg1: *mut kthread_t, arg2: *mut ctxop);
}
unsafe extern "C" {
    pub fn ctxop_detach(arg1: *mut kthread_t, arg2: *mut ctxop);
}
unsafe extern "C" {
    pub fn ctxop_install(
        arg1: *mut kthread_t,
        arg2: *const ctxop_template,
        arg3: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn ctxop_remove(
        arg1: *mut kthread_t,
        arg2: *const ctxop_template,
        arg3: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn savectx(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn restorectx(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn forkctx(arg1: *mut kthread_t, arg2: *mut kthread_t);
}
unsafe extern "C" {
    pub fn lwp_createctx(arg1: *mut kthread_t, arg2: *mut kthread_t);
}
unsafe extern "C" {
    pub fn exitctx(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn freectx(arg1: *mut kthread_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn installpctx(
        arg1: *mut proc_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: ::core::option::Option<unsafe extern "C" fn()>,
        arg4: ::core::option::Option<unsafe extern "C" fn()>,
        arg5: ::core::option::Option<unsafe extern "C" fn()>,
        arg6: ::core::option::Option<unsafe extern "C" fn()>,
        arg7: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
unsafe extern "C" {
    pub fn removepctx(
        arg1: *mut proc_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: ::core::option::Option<unsafe extern "C" fn()>,
        arg4: ::core::option::Option<unsafe extern "C" fn()>,
        arg5: ::core::option::Option<unsafe extern "C" fn()>,
        arg6: ::core::option::Option<unsafe extern "C" fn()>,
        arg7: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn savepctx(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn restorepctx(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn forkpctx(arg1: *mut proc_t, arg2: *mut proc_t);
}
unsafe extern "C" {
    pub fn exitpctx(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn freepctx(arg1: *mut proc_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn thread_unpin() -> *mut kthread_t;
}
unsafe extern "C" {
    pub fn thread_init();
}
unsafe extern "C" {
    pub fn thread_load(
        arg1: *mut kthread_t,
        arg2: ::core::option::Option<unsafe extern "C" fn()>,
        arg3: caddr_t,
        arg4: usize,
    );
}
unsafe extern "C" {
    pub fn tsd_create(
        arg1: *mut uint_t,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
        >,
    );
}
unsafe extern "C" {
    pub fn tsd_destroy(arg1: *mut uint_t);
}
unsafe extern "C" {
    pub fn tsd_getcreate(
        arg1: *mut uint_t,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
        >,
        arg3: ::core::option::Option<
            unsafe extern "C" fn() -> *mut illumos_sys_hdrs::c_void,
        >,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn tsd_get(arg1: uint_t) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn tsd_set(
        arg1: uint_t,
        arg2: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn tsd_exit();
}
unsafe extern "C" {
    pub fn tsd_agent_get(
        arg1: *mut kthread_t,
        arg2: uint_t,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn tsd_agent_set(
        arg1: *mut kthread_t,
        arg2: uint_t,
        arg3: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn lwp_kernel_create(
        arg1: *mut proc_t,
        arg2: ::core::option::Option<unsafe extern "C" fn()>,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: illumos_sys_hdrs::c_int,
        arg5: pri_t,
    ) -> *mut kthread_t;
}
unsafe extern "C" {
    pub fn lwp_create(
        proc_: ::core::option::Option<unsafe extern "C" fn()>,
        arg: caddr_t,
        len: usize,
        p: *mut proc_t,
        state: illumos_sys_hdrs::c_int,
        pri: illumos_sys_hdrs::c_int,
        smask: *const k_sigset_t,
        cid: illumos_sys_hdrs::c_int,
        lwpid: id_t,
    ) -> *mut klwp_t;
}
unsafe extern "C" {
    pub fn idtot(arg1: *mut proc_t, arg2: id_t) -> *mut kthread_t;
}
unsafe extern "C" {
    pub fn lwp_hash_in(
        arg1: *mut proc_t,
        arg2: *mut lwpent_t,
        arg3: *mut tidhash_t,
        arg4: uint_t,
        arg5: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn lwp_hash_out(arg1: *mut proc_t, arg2: id_t);
}
unsafe extern "C" {
    pub fn lwp_hash_lookup(arg1: *mut proc_t, arg2: id_t) -> *mut lwpdir_t;
}
unsafe extern "C" {
    pub fn lwp_hash_lookup_and_lock(
        arg1: *mut proc_t,
        arg2: id_t,
        arg3: *mut *mut kmutex_t,
    ) -> *mut lwpdir_t;
}
unsafe extern "C" {
    pub fn lwp_create_done(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn lwp_exit();
}
unsafe extern "C" {
    pub fn lwp_pcb_exit();
}
unsafe extern "C" {
    pub fn lwp_cleanup();
}
unsafe extern "C" {
    pub fn lwp_suspend(arg1: *mut kthread_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn lwp_continue(arg1: *mut kthread_t);
}
unsafe extern "C" {
    pub fn holdlwp();
}
unsafe extern "C" {
    pub fn stoplwp();
}
unsafe extern "C" {
    pub fn holdlwps(arg1: illumos_sys_hdrs::c_int) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn holdwatch() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn pokelwps(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn continuelwps(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn exitlwps(arg1: illumos_sys_hdrs::c_int) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn lwp_ctmpl_copy(arg1: *mut klwp_t, arg2: *mut klwp_t);
}
unsafe extern "C" {
    pub fn lwp_ctmpl_clear(arg1: *mut klwp_t);
}
unsafe extern "C" {
    pub fn forklwp(
        arg1: *mut klwp_t,
        arg2: *mut proc_t,
        arg3: id_t,
    ) -> *mut klwp_t;
}
unsafe extern "C" {
    pub fn lwp_load(arg1: *mut klwp_t, arg2: *mut greg_t, arg3: usize);
}
unsafe extern "C" {
    pub fn lwp_setrval(
        arg1: *mut klwp_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn lwp_forkregs(arg1: *mut klwp_t, arg2: *mut klwp_t);
}
unsafe extern "C" {
    pub fn lwp_freeregs(arg1: *mut klwp_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn lwp_stk_init(arg1: *mut klwp_t, arg2: caddr_t) -> caddr_t;
}
unsafe extern "C" {
    pub fn lwp_stk_cache_init();
}
unsafe extern "C" {
    pub fn lwp_stk_fini(arg1: *mut klwp_t);
}
unsafe extern "C" {
    pub fn lwp_fp_init(arg1: *mut klwp_t);
}
unsafe extern "C" {
    pub fn lwp_installctx(arg1: *mut klwp_t);
}
unsafe extern "C" {
    pub fn lwp_rtt_initial();
}
unsafe extern "C" {
    pub fn lwp_setprivate(
        arg1: *mut klwp_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn lwp_stat_update(arg1: lwp_stat_id_t, arg2: illumos_sys_hdrs::c_long);
}
unsafe extern "C" {
    pub fn lwp_attach_brand_hdlrs(arg1: *mut klwp_t);
}
unsafe extern "C" {
    pub fn lwp_detach_brand_hdlrs(arg1: *mut klwp_t);
}
unsafe extern "C" {
    pub fn sigqfree(arg1: *mut proc_t);
}
unsafe extern "C" {
    pub fn siginfofree(arg1: *mut sigqueue_t);
}
unsafe extern "C" {
    pub fn sigdeq(
        arg1: *mut proc_t,
        arg2: *mut kthread_t,
        arg3: illumos_sys_hdrs::c_int,
        arg4: *mut *mut sigqueue_t,
    );
}
unsafe extern "C" {
    pub fn sigdelq(
        arg1: *mut proc_t,
        arg2: *mut kthread_t,
        arg3: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn sigaddq(
        arg1: *mut proc_t,
        arg2: *mut kthread_t,
        arg3: *mut k_siginfo_t,
        arg4: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn sigaddqa(
        arg1: *mut proc_t,
        arg2: *mut kthread_t,
        arg3: *mut sigqueue_t,
    );
}
unsafe extern "C" {
    pub fn sigqsend(
        arg1: illumos_sys_hdrs::c_int,
        arg2: *mut proc_t,
        arg3: *mut kthread_t,
        arg4: *mut sigqueue_t,
    );
}
unsafe extern "C" {
    pub fn sigdupq(arg1: *mut proc_t, arg2: *mut proc_t);
}
unsafe extern "C" {
    pub fn sigwillqueue(
        arg1: illumos_sys_hdrs::c_int,
        arg2: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn sigqhdralloc(arg1: usize, arg2: uint_t) -> *mut sigqhdr_t;
}
unsafe extern "C" {
    pub fn sigqalloc(arg1: *mut sigqhdr_t) -> *mut sigqueue_t;
}
unsafe extern "C" {
    pub fn sigqhdrfree(arg1: *mut sigqhdr_t);
}
unsafe extern "C" {
    pub fn sigappend(
        arg1: *mut k_sigset_t,
        arg2: *mut sigqueue_t,
        arg3: *mut k_sigset_t,
        arg4: *mut sigqueue_t,
    ) -> *mut sigqueue_t;
}
unsafe extern "C" {
    pub fn sigprepend(
        arg1: *mut k_sigset_t,
        arg2: *mut sigqueue_t,
        arg3: *mut k_sigset_t,
        arg4: *mut sigqueue_t,
    ) -> *mut sigqueue_t;
}
unsafe extern "C" {
    pub fn winfo(
        arg1: *mut proc_t,
        arg2: *mut k_siginfo_t,
        arg3: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn wstat(
        arg1: illumos_sys_hdrs::c_int,
        arg2: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn sendsig(
        arg1: illumos_sys_hdrs::c_int,
        arg2: *mut k_siginfo_t,
        arg3: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __ddi_dma_handle {
    _unused: [u8; 0],
}
pub type ddi_dma_handle_t = *mut __ddi_dma_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __ddi_dma_win {
    _unused: [u8; 0],
}
pub type ddi_dma_win_t = *mut __ddi_dma_win;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __ddi_dma_seg {
    _unused: [u8; 0],
}
pub type ddi_dma_seg_t = *mut __ddi_dma_seg;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ddi_dma_cookie_t {
    pub _dmu: ddi_dma_cookie_t__bindgen_ty_1,
    pub dmac_size: usize,
    pub dmac_type: uint_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ddi_dma_cookie_t__bindgen_ty_1 {
    pub _dmac_ll: u64,
    pub _dmac_la: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __ddi_iblock_cookie {
    _unused: [u8; 0],
}
pub type ddi_iblock_cookie_t = *mut __ddi_iblock_cookie;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ddi_idevice_cookie_t {
    pub idu: ddi_idevice_cookie_t__bindgen_ty_1,
    pub idev_softint: uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddi_idevice_cookie_t__bindgen_ty_1 {
    pub _idev_vector: ushort_t,
    pub _idev_priority: ushort_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __ddi_regspec {
    _unused: [u8; 0],
}
pub type ddi_regspec_t = *mut __ddi_regspec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __ddi_intrspec {
    _unused: [u8; 0],
}
pub type ddi_intrspec_t = *mut __ddi_intrspec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __ddi_softintr {
    _unused: [u8; 0],
}
pub type ddi_softintr_t = *mut __ddi_softintr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dev_info {
    _unused: [u8; 0],
}
pub type dev_info_t = *mut __dev_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __ddi_devmap_data {
    _unused: [u8; 0],
}
pub type ddi_devmap_data_t = *mut __ddi_devmap_data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __ddi_devid {
    _unused: [u8; 0],
}
pub type ddi_devid_t = *mut __ddi_devid;
pub const ddi_devmap_cmd_t_DDI_DEVMAP_VALIDATE: ddi_devmap_cmd_t = 0;
pub type ddi_devmap_cmd_t = illumos_sys_hdrs::c_uint;
pub const ddi_node_state_t_DS_INVAL: ddi_node_state_t = -1;
pub const ddi_node_state_t_DS_PROTO: ddi_node_state_t = 0;
pub const ddi_node_state_t_DS_LINKED: ddi_node_state_t = 1;
pub const ddi_node_state_t_DS_BOUND: ddi_node_state_t = 2;
pub const ddi_node_state_t_DS_INITIALIZED: ddi_node_state_t = 3;
pub const ddi_node_state_t_DS_PROBED: ddi_node_state_t = 4;
pub const ddi_node_state_t_DS_ATTACHED: ddi_node_state_t = 5;
pub const ddi_node_state_t_DS_READY: ddi_node_state_t = 6;
pub type ddi_node_state_t = illumos_sys_hdrs::c_int;
pub const ddi_plevel_t_EPL_KERNEL: ddi_plevel_t = 0;
pub const ddi_plevel_t_EPL_INTERRUPT: ddi_plevel_t = 1;
pub const ddi_plevel_t_EPL_HIGHLEVEL: ddi_plevel_t = 2;
pub type ddi_plevel_t = illumos_sys_hdrs::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddi_event_cookie {
    _unused: [u8; 0],
}
pub type ddi_eventcookie_t = *mut ddi_event_cookie;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddi_event_callbacks {
    _unused: [u8; 0],
}
pub type ddi_callback_id_t = *mut ddi_event_callbacks;
pub type ddi_event_cb_f = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut dev_info_t,
        arg2: ddi_eventcookie_t,
        arg: *mut illumos_sys_hdrs::c_void,
        impldata: *mut illumos_sys_hdrs::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddi_device_acc_attr {
    pub devacc_attr_version: ushort_t,
    pub devacc_attr_endian_flags: uchar_t,
    pub devacc_attr_dataorder: uchar_t,
    pub devacc_attr_access: uchar_t,
}
pub type ddi_device_acc_attr_t = ddi_device_acc_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __ddi_acc_handle {
    _unused: [u8; 0],
}
pub type ddi_acc_handle_t = *mut __ddi_acc_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddi_acc_hdl {
    pub ah_vers: illumos_sys_hdrs::c_int,
    pub ah_bus_private: *mut illumos_sys_hdrs::c_void,
    pub ah_platform_private: *mut illumos_sys_hdrs::c_void,
    pub ah_dip: *mut dev_info_t,
    pub ah_rnumber: uint_t,
    pub ah_addr: caddr_t,
    pub ah_offset: off_t,
    pub ah_len: off_t,
    pub ah_hat_flags: uint_t,
    pub ah_pfn: pfn_t,
    pub ah_pnum: uint_t,
    pub ah_xfermodes: ulong_t,
    pub ah_acc: ddi_device_acc_attr_t,
}
pub type ddi_acc_hdl_t = ddi_acc_hdl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct peekpoke_ctlops_t {
    pub size: usize,
    pub dev_addr: usize,
    pub host_addr: usize,
    pub handle: ddi_acc_handle_t,
    pub repcount: usize,
    pub flags: uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __ddi_periodic {
    _unused: [u8; 0],
}
pub type ddi_periodic_t = *mut __ddi_periodic;
pub type pc_t = usize;
pub type __gnuc_va_list = __builtin_va_list;
pub type __va_list = __builtin_va_list;
pub type va_list = __va_list;
unsafe extern "C" {
    pub static mut ualock: kmutex_t;
}
unsafe extern "C" {
    pub fn mdboot(
        arg1: illumos_sys_hdrs::c_int,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: boolean_t,
    );
}
unsafe extern "C" {
    pub fn mdpreboot(
        arg1: illumos_sys_hdrs::c_int,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut illumos_sys_hdrs::c_char,
    );
}
unsafe extern "C" {
    pub fn kadmin(
        arg1: illumos_sys_hdrs::c_int,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn killall(arg1: zoneid_t);
}
unsafe extern "C" {
    pub fn uadmin(
        arg1: illumos_sys_hdrs::c_int,
        arg2: illumos_sys_hdrs::c_int,
        arg3: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut rootdir: *mut vnode;
}
unsafe extern "C" {
    pub static mut devicesdir: *mut vnode;
}
unsafe extern "C" {
    pub static mut interrupts_unleashed: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut runin: illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub static mut runout: illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub static mut wake_sched: illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub static mut wake_sched_sec: illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub static mut maxmem: pgcnt_t;
}
unsafe extern "C" {
    pub static mut physmem: pgcnt_t;
}
unsafe extern "C" {
    pub static mut physmax: pfn_t;
}
unsafe extern "C" {
    pub static mut physinstalled: pgcnt_t;
}
unsafe extern "C" {
    pub static mut s_text: caddr_t;
}
unsafe extern "C" {
    pub static mut e_text: caddr_t;
}
unsafe extern "C" {
    pub static mut s_data: caddr_t;
}
unsafe extern "C" {
    pub static mut e_data: caddr_t;
}
unsafe extern "C" {
    pub static mut availrmem: pgcnt_t;
}
unsafe extern "C" {
    pub static mut availrmem_initial: pgcnt_t;
}
unsafe extern "C" {
    pub static mut segspt_minfree: pgcnt_t;
}
unsafe extern "C" {
    pub static mut freemem: pgcnt_t;
}
unsafe extern "C" {
    pub static mut rootdev: dev_t;
}
unsafe extern "C" {
    pub static mut rootvp: *mut vnode;
}
unsafe extern "C" {
    pub static mut root_is_ramdisk: boolean_t;
}
unsafe extern "C" {
    pub static mut ramdisk_size: u32;
}
unsafe extern "C" {
    pub static mut panicstr: *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub static mut panicargs: va_list;
}
unsafe extern "C" {
    pub static mut quiesce_active: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut rstchown: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut klustsize: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut abort_enable: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut audit_active: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut avenrun: [illumos_sys_hdrs::c_int; 0usize];
}
unsafe extern "C" {
    pub static mut isa_list: *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub static mut noexec_user_stack: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut noexec_user_stack_log: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut nfs_global_client_only: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn report_stack_exec(arg1: *mut proc_t, arg2: caddr_t);
}
unsafe extern "C" {
    pub fn startup();
}
unsafe extern "C" {
    pub fn clkstart();
}
unsafe extern "C" {
    pub fn post_startup();
}
unsafe extern "C" {
    pub fn kern_setup1();
}
unsafe extern "C" {
    pub fn ka_init();
}
unsafe extern "C" {
    pub fn nodename_set();
}
pub const tod_fault_type_TOD_REVERSED: tod_fault_type = 0;
pub const tod_fault_type_TOD_STALLED: tod_fault_type = 1;
pub const tod_fault_type_TOD_JUMPED: tod_fault_type = 2;
pub const tod_fault_type_TOD_RATECHANGED: tod_fault_type = 3;
pub const tod_fault_type_TOD_RDONLY: tod_fault_type = 4;
pub const tod_fault_type_TOD_NOFAULT: tod_fault_type = 5;
pub type tod_fault_type = illumos_sys_hdrs::c_uint;
unsafe extern "C" {
    pub fn tod_validate(arg1: time_t) -> time_t;
}
unsafe extern "C" {
    pub fn tod_status_set(arg1: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn tod_status_clear(arg1: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn plat_tod_fault(arg1: tod_fault_type);
}
unsafe extern "C" {
    pub fn grow(arg1: caddr_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn grow_internal(
        arg1: caddr_t,
        arg2: uint_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn brk_internal(arg1: caddr_t, arg2: uint_t)
        -> illumos_sys_hdrs::c_int;
}
pub type callout_id_t = u64;
unsafe extern "C" {
    pub fn timeout(
        arg1: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
        >,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: clock_t,
    ) -> timeout_id_t;
}
unsafe extern "C" {
    pub fn realtime_timeout(
        arg1: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
        >,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: clock_t,
    ) -> timeout_id_t;
}
unsafe extern "C" {
    pub fn untimeout(arg1: timeout_id_t) -> clock_t;
}
unsafe extern "C" {
    pub fn timeout_generic(
        arg1: illumos_sys_hdrs::c_int,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
        >,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: hrtime_t,
        arg5: hrtime_t,
        arg6: illumos_sys_hdrs::c_int,
    ) -> callout_id_t;
}
unsafe extern "C" {
    pub fn timeout_default(
        arg1: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
        >,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: clock_t,
    ) -> callout_id_t;
}
unsafe extern "C" {
    pub fn realtime_timeout_default(
        arg1: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
        >,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: clock_t,
    ) -> callout_id_t;
}
unsafe extern "C" {
    pub fn untimeout_generic(
        arg1: callout_id_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> hrtime_t;
}
unsafe extern "C" {
    pub fn untimeout_default(
        arg1: callout_id_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> clock_t;
}
unsafe extern "C" {
    pub fn delay(arg1: clock_t);
}
unsafe extern "C" {
    pub fn delay_sig(arg1: clock_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn delay_random(arg1: clock_t);
}
unsafe extern "C" {
    pub fn nodev() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn nulldev() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn getudev() -> major_t;
}
unsafe extern "C" {
    pub fn cmpldev(arg1: *mut dev32_t, arg2: dev_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn expldev(arg1: dev32_t) -> dev_t;
}
unsafe extern "C" {
    pub fn bcmp(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *const illumos_sys_hdrs::c_void,
        arg3: illumos_sys_hdrs::c_ulong,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn stoi(
        arg1: *mut *mut illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn numtos(arg1: ulong_t, arg2: *mut illumos_sys_hdrs::c_char);
}
unsafe extern "C" {
    pub fn kmem_asprintf(
        fmt: *const illumos_sys_hdrs::c_char,
        ...
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn strident_valid(
        arg1: *const illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn strident_canon(arg1: *mut illumos_sys_hdrs::c_char, arg2: usize);
}
unsafe extern "C" {
    pub fn getsubopt(
        optionsp: *mut *mut illumos_sys_hdrs::c_char,
        tokens: *const *mut illumos_sys_hdrs::c_char,
        valuep: *mut *mut illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn append_subopt(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: usize,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: *const illumos_sys_hdrs::c_char,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn ffs(arg1: uintmax_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn copyin(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn copyin_noerr(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    );
}
unsafe extern "C" {
    pub fn xcopyin(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn xcopyin_nta(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
        arg4: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn copyout(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn copyout_noerr(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    );
}
unsafe extern "C" {
    pub fn xcopyout(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn xcopyout_nta(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
        arg4: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn copyinstr(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: usize,
        arg4: *mut usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn copyinstr_noerr(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: usize,
        arg4: *mut usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn copyoutstr(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: usize,
        arg4: *mut usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn copyoutstr_noerr(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: usize,
        arg4: *mut usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn copystr(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: usize,
        arg4: *mut usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ucopy(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    );
}
unsafe extern "C" {
    pub fn ucopystr(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: usize,
        arg4: *mut usize,
    );
}
unsafe extern "C" {
    pub fn pgcopy(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    );
}
unsafe extern "C" {
    pub fn ovbcopy(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    );
}
unsafe extern "C" {
    pub fn uzero(arg1: *mut illumos_sys_hdrs::c_void, arg2: usize);
}
unsafe extern "C" {
    pub fn kcopy(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kcopy_nta(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
        arg4: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn kzero(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fuword8(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut u8,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fuword16(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut u16,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fuword32(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fulword(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut ulong_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fuword8_noerr(arg1: *const illumos_sys_hdrs::c_void, arg2: *mut u8);
}
unsafe extern "C" {
    pub fn fuword16_noerr(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut u16,
    );
}
unsafe extern "C" {
    pub fn fuword32_noerr(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut u32,
    );
}
unsafe extern "C" {
    pub fn fulword_noerr(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut ulong_t,
    );
}
unsafe extern "C" {
    pub fn fuword64(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut u64,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn fuword64_noerr(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut u64,
    );
}
unsafe extern "C" {
    pub fn subyte(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: u8,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn suword8(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: u8,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn suword16(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: u16,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn suword32(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn sulword(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: ulong_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn subyte_noerr(arg1: *mut illumos_sys_hdrs::c_void, arg2: u8);
}
unsafe extern "C" {
    pub fn suword8_noerr(arg1: *mut illumos_sys_hdrs::c_void, arg2: u8);
}
unsafe extern "C" {
    pub fn suword16_noerr(arg1: *mut illumos_sys_hdrs::c_void, arg2: u16);
}
unsafe extern "C" {
    pub fn suword32_noerr(arg1: *mut illumos_sys_hdrs::c_void, arg2: u32);
}
unsafe extern "C" {
    pub fn sulword_noerr(arg1: *mut illumos_sys_hdrs::c_void, arg2: ulong_t);
}
unsafe extern "C" {
    pub fn suword64(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: u64,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn suword64_noerr(arg1: *mut illumos_sys_hdrs::c_void, arg2: u64);
}
unsafe extern "C" {
    pub fn setjmp(arg1: *mut label_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn longjmp(arg1: *mut label_t) -> !;
}
unsafe extern "C" {
    pub fn prefetch_read_once(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn prefetch_write_once(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn prefetch_read_many(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn prefetch_write_many(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn caller() -> caddr_t;
}
unsafe extern "C" {
    pub fn callee() -> caddr_t;
}
unsafe extern "C" {
    pub fn getpcstack(
        arg1: *mut pc_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn on_fault(arg1: *mut label_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn no_fault();
}
unsafe extern "C" {
    pub fn halt(arg1: *mut illumos_sys_hdrs::c_char);
}
unsafe extern "C" {
    pub fn scanc(
        arg1: usize,
        arg2: *mut uchar_t,
        arg3: *mut uchar_t,
        arg4: uchar_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn movtuc(
        arg1: usize,
        arg2: *mut uchar_t,
        arg3: *mut uchar_t,
        arg4: *mut uchar_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn splr(arg1: illumos_sys_hdrs::c_int) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn splhigh() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn splhi() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn splzs() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn spl0() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn spl6() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn spl7() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn spl8() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn splx(arg1: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn set_base_spl();
}
unsafe extern "C" {
    pub fn __ipltospl(arg1: illumos_sys_hdrs::c_int)
        -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn spl_xcall() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn softcall_init();
}
unsafe extern "C" {
    pub fn softcall(
        arg1: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void),
        >,
        arg2: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn softint();
}
unsafe extern "C" {
    pub fn sync_icache(arg1: caddr_t, arg2: uint_t);
}
unsafe extern "C" {
    pub fn sync_data_memory(arg1: caddr_t, arg2: usize);
}
unsafe extern "C" {
    pub fn hot_patch_kernel_text(arg1: caddr_t, arg2: u32, arg3: uint_t);
}
unsafe extern "C" {
    pub fn _insque(arg1: caddr_t, arg2: caddr_t);
}
unsafe extern "C" {
    pub fn _remque(arg1: caddr_t);
}
unsafe extern "C" {
    pub fn uniqtime(arg1: *mut timeval);
}
unsafe extern "C" {
    pub fn uniqtime32(arg1: *mut timeval32);
}
unsafe extern "C" {
    pub fn page_num_pagesizes() -> uint_t;
}
unsafe extern "C" {
    pub fn page_get_pagesize(n: uint_t) -> usize;
}
unsafe extern "C" {
    pub static mut maxusers: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut pidmax: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn param_preset();
}
unsafe extern "C" {
    pub fn param_calc(arg1: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn param_init();
}
unsafe extern "C" {
    pub fn param_check();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysent {
    pub sy_narg: illumos_sys_hdrs::c_char,
    pub sy_flags: illumos_sys_hdrs::c_ushort,
    pub sy_call: ::core::option::Option<
        unsafe extern "C" fn() -> illumos_sys_hdrs::c_int,
    >,
    pub sy_lock: *mut krwlock_t,
    pub sy_callc: ::core::option::Option<unsafe extern "C" fn() -> i64>,
}
unsafe extern "C" {
    pub static mut sysent: [sysent; 0usize];
}
unsafe extern "C" {
    pub static mut nosys_ent: sysent;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rval {
    pub r_v: rval__bindgen_ty_1,
    pub r_off: off_t,
    pub r_offset: offset_t,
    pub r_time: time_t,
    pub r_vals: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rval__bindgen_ty_1 {
    pub r_v1: illumos_sys_hdrs::c_int,
    pub r_v2: illumos_sys_hdrs::c_int,
}
pub type rval_t = rval;
unsafe extern "C" {
    pub fn reset_syscall_args();
}
unsafe extern "C" {
    pub fn save_syscall_args() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn get_syscall_args(
        lwp: *mut klwp_t,
        argp: *mut illumos_sys_hdrs::c_long,
        nargsp: *mut illumos_sys_hdrs::c_int,
    ) -> uint_t;
}
unsafe extern "C" {
    pub fn set_errno(error: uint_t) -> uint_t;
}
unsafe extern "C" {
    pub fn syscall_ap() -> i64;
}
unsafe extern "C" {
    pub fn loadable_syscall(
        arg1: illumos_sys_hdrs::c_long,
        arg2: illumos_sys_hdrs::c_long,
        arg3: illumos_sys_hdrs::c_long,
        arg4: illumos_sys_hdrs::c_long,
        arg5: illumos_sys_hdrs::c_long,
        arg6: illumos_sys_hdrs::c_long,
        arg7: illumos_sys_hdrs::c_long,
        arg8: illumos_sys_hdrs::c_long,
    ) -> i64;
}
unsafe extern "C" {
    pub fn nosys() -> i64;
}
unsafe extern "C" {
    pub fn nosys32() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn swtch();
}
unsafe extern "C" {
    pub static mut kcpc_key: uint_t;
}
unsafe extern "C" {
    pub static mut initname: [illumos_sys_hdrs::c_char; 32usize];
}
unsafe extern "C" {
    pub static mut initargs: [illumos_sys_hdrs::c_char; 256usize];
}
unsafe extern "C" {
    pub fn exec_init(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn start_init_common() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn strlcat(
        arg1: *mut illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
        arg3: illumos_sys_hdrs::c_ulong,
    ) -> illumos_sys_hdrs::c_ulong;
}
unsafe extern "C" {
    pub fn strcat(
        arg1: *mut illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        arg1: *mut illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
        arg3: illumos_sys_hdrs::c_ulong,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn strcpy(
        arg1: *mut illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        arg1: *mut illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
        arg3: illumos_sys_hdrs::c_ulong,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn strlcpy(
        arg1: *mut illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
        arg3: illumos_sys_hdrs::c_ulong,
    ) -> illumos_sys_hdrs::c_ulong;
}
unsafe extern "C" {
    pub fn strspn(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_ulong;
}
unsafe extern "C" {
    pub fn strcspn(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_ulong;
}
unsafe extern "C" {
    pub fn strdup(
        arg1: *const illumos_sys_hdrs::c_char,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn strfree(arg1: *mut illumos_sys_hdrs::c_char);
}
unsafe extern "C" {
    pub fn strchr(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn strnrchr(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: illumos_sys_hdrs::c_int,
        arg3: usize,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
        arg3: illumos_sys_hdrs::c_ulong,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
        arg3: illumos_sys_hdrs::c_ulong,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn strpbrk(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *const illumos_sys_hdrs::c_char,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn bcopy(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: usize,
    );
}
unsafe extern "C" {
    pub fn bzero(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: illumos_sys_hdrs::c_ulong,
    );
}
unsafe extern "C" {
    pub fn memset(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: illumos_sys_hdrs::c_int,
        arg3: illumos_sys_hdrs::c_ulong,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn memcpy(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: *const illumos_sys_hdrs::c_void,
        arg3: illumos_sys_hdrs::c_ulong,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: *const illumos_sys_hdrs::c_void,
        arg3: illumos_sys_hdrs::c_ulong,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: *const illumos_sys_hdrs::c_void,
        arg3: illumos_sys_hdrs::c_ulong,
    ) -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct radix_node {
    pub rn_mklist: *mut radix_mask,
    pub rn_parent: *mut radix_node,
    pub rn_bit: illumos_sys_hdrs::c_short,
    pub rn_bmask: illumos_sys_hdrs::c_char,
    pub rn_flags: uchar_t,
    pub rn_u: radix_node__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union radix_node__bindgen_ty_1 {
    pub rn_leaf: radix_node__bindgen_ty_1__bindgen_ty_1,
    pub rn_node: radix_node__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct radix_node__bindgen_ty_1__bindgen_ty_1 {
    pub rn_Key: caddr_t,
    pub rn_Mask: caddr_t,
    pub rn_Dupedkey: *mut radix_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct radix_node__bindgen_ty_1__bindgen_ty_2 {
    pub rn_Off: illumos_sys_hdrs::c_int,
    pub rn_L: *mut radix_node,
    pub rn_R: *mut radix_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct radix_mask {
    pub rm_bit: illumos_sys_hdrs::c_short,
    pub rm_unused: illumos_sys_hdrs::c_char,
    pub rm_flags: uchar_t,
    pub rm_mklist: *mut radix_mask,
    pub rm_rmu: radix_mask__bindgen_ty_1,
    pub rm_refs: illumos_sys_hdrs::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union radix_mask__bindgen_ty_1 {
    pub rmu_mask: caddr_t,
    pub rmu_leaf: *mut radix_node,
}
pub type walktree_f_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut radix_node,
        arg2: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int,
>;
pub type match_leaf_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut radix_node,
        arg2: *mut illumos_sys_hdrs::c_void,
    ) -> boolean_t,
>;
pub type lockf_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut radix_node)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct radix_node_head {
    pub rnh_treetop: *mut radix_node,
    pub rnh_addrsize: illumos_sys_hdrs::c_int,
    pub rnh_pktsize: illumos_sys_hdrs::c_int,
    pub rnh_addaddr: ::core::option::Option<
        unsafe extern "C" fn(
            v: *mut illumos_sys_hdrs::c_void,
            mask: *mut illumos_sys_hdrs::c_void,
            head: *mut radix_node_head,
            nodes: *mut radix_node,
        ) -> *mut radix_node,
    >,
    pub rnh_addpkt: ::core::option::Option<
        unsafe extern "C" fn(
            v: *mut illumos_sys_hdrs::c_void,
            mask: *mut illumos_sys_hdrs::c_void,
            head: *mut radix_node_head,
            nodes: *mut radix_node,
        ) -> *mut radix_node,
    >,
    pub rnh_deladdr: ::core::option::Option<
        unsafe extern "C" fn(
            v: *mut illumos_sys_hdrs::c_void,
            mask: *mut illumos_sys_hdrs::c_void,
            head: *mut radix_node_head,
        ) -> *mut radix_node,
    >,
    pub rnh_delpkt: ::core::option::Option<
        unsafe extern "C" fn(
            v: *mut illumos_sys_hdrs::c_void,
            mask: *mut illumos_sys_hdrs::c_void,
            head: *mut radix_node_head,
        ) -> *mut radix_node,
    >,
    pub rnh_matchaddr: ::core::option::Option<
        unsafe extern "C" fn(
            v: *mut illumos_sys_hdrs::c_void,
            head: *mut radix_node_head,
        ) -> *mut radix_node,
    >,
    pub rnh_matchaddr_args: ::core::option::Option<
        unsafe extern "C" fn(
            v: *mut illumos_sys_hdrs::c_void,
            head: *mut radix_node_head,
            f: match_leaf_t,
            w: *mut illumos_sys_hdrs::c_void,
        ) -> *mut radix_node,
    >,
    pub rnh_lookup: ::core::option::Option<
        unsafe extern "C" fn(
            v: *mut illumos_sys_hdrs::c_void,
            mask: *mut illumos_sys_hdrs::c_void,
            head: *mut radix_node_head,
        ) -> *mut radix_node,
    >,
    pub rnh_matchpkt: ::core::option::Option<
        unsafe extern "C" fn(
            v: *mut illumos_sys_hdrs::c_void,
            head: *mut radix_node_head,
        ) -> *mut radix_node,
    >,
    pub rnh_walktree: ::core::option::Option<
        unsafe extern "C" fn(
            head: *mut radix_node_head,
            f: walktree_f_t,
            w: *mut illumos_sys_hdrs::c_void,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub rnh_walktree_mt: ::core::option::Option<
        unsafe extern "C" fn(
            head: *mut radix_node_head,
            f: walktree_f_t,
            w: *mut illumos_sys_hdrs::c_void,
            lockf: lockf_t,
            unlockf: lockf_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub rnh_walktree_from: ::core::option::Option<
        unsafe extern "C" fn(
            head: *mut radix_node_head,
            a: *mut illumos_sys_hdrs::c_void,
            m: *mut illumos_sys_hdrs::c_void,
            f: walktree_f_t,
            w: *mut illumos_sys_hdrs::c_void,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub rnh_close: ::core::option::Option<
        unsafe extern "C" fn(rn: *mut radix_node, head: *mut radix_node_head),
    >,
    pub rnh_nodes: [radix_node; 3usize],
    pub rnh_lock: krwlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt_sockaddr {
    pub rt_sin_len: u8,
    pub rt_sin_family: u8,
    pub rt_sin_port: u16,
    pub rt_sin_addr: in_addr,
    pub rt_sin_zero: [illumos_sys_hdrs::c_char; 8usize],
}
pub type rn_t = radix_node;
pub type rmsk_t = radix_mask;
pub type rnh_t = radix_node_head;
pub type rt_sa_t = rt_sockaddr;
unsafe extern "C" {
    pub fn rn_init();
}
unsafe extern "C" {
    pub fn rn_fini();
}
unsafe extern "C" {
    pub fn rn_inithead(
        arg1: *mut *mut illumos_sys_hdrs::c_void,
        arg2: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rn_freenode(
        arg1: *mut radix_node,
        arg2: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn rn_freehead(arg1: *mut radix_node_head);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipllcmd_s {
    pub ipllc_cmd: uint_t,
    pub ipllc_name_offset: uint_t,
    pub ipllc_name_length: uint_t,
}
pub type ipllc_t = ipllcmd_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipid_s {
    pub ipid_ipllc: ipllc_t,
    pub ipid_ire_type: uint_t,
    pub ipid_addr_offset: uint_t,
    pub ipid_addr_length: uint_t,
    pub ipid_mask_offset: uint_t,
    pub ipid_mask_length: uint_t,
}
pub type ipid_t = ipid_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipoptp_s {
    pub ipoptp_next: *mut u8,
    pub ipoptp_end: *mut u8,
    pub ipoptp_cur: *mut u8,
    pub ipoptp_len: u8,
    pub ipoptp_flags: u32,
}
pub type ipoptp_t = ipoptp_s;
unsafe extern "C" {
    pub static mut ip_squeue_flag: illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipf_s {
    pub ipf_hash_next: *mut ipf_s,
    pub ipf_ptphn: *mut *mut ipf_s,
    pub ipf_ident: u32,
    pub ipf_protocol: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ipf_timestamp: time_t,
    pub ipf_mp: *mut mblk_t,
    pub ipf_tail_mp: *mut mblk_t,
    pub ipf_hole_cnt: illumos_sys_hdrs::c_int,
    pub ipf_end: illumos_sys_hdrs::c_int,
    pub ipf_gen: uint_t,
    pub ipf_count: usize,
    pub ipf_nf_hdr_len: uint_t,
    pub ipf_v6src: in6_addr_t,
    pub ipf_v6dst: in6_addr_t,
    pub ipf_prev_nexthdr_offset: uint_t,
    pub ipf_ecn: u8,
    pub ipf_num_dups: u8,
    pub ipf_checksum_flags: u16,
    pub ipf_checksum: u32,
}
impl ipf_s {
    #[inline]
    pub fn ipf_last_frag_seen(&self) -> uchar_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8)
        }
    }
    #[inline]
    pub fn set_ipf_last_frag_seen(&mut self, val: uchar_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipf_last_frag_seen_raw(this: *const Self) -> uchar_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    1u8,
                ) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ipf_last_frag_seen_raw(this: *mut Self, val: uchar_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ipf_last_frag_seen: uchar_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ipf_last_frag_seen: u8 =
                unsafe { ::core::mem::transmute(ipf_last_frag_seen) };
            ipf_last_frag_seen as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ipf_t = ipf_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct icmph_s {
    pub icmph_type: u8,
    pub icmph_code: u8,
    pub icmph_checksum: u16,
    pub icmph_u: icmph_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union icmph_s__bindgen_ty_1 {
    pub u_echo: icmph_s__bindgen_ty_1__bindgen_ty_1,
    pub u_du: icmph_s__bindgen_ty_1__bindgen_ty_2,
    pub u_pp: icmph_s__bindgen_ty_1__bindgen_ty_3,
    pub u_rd: icmph_s__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icmph_s__bindgen_ty_1__bindgen_ty_1 {
    pub u_echo_ident: u16,
    pub u_echo_seqnum: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icmph_s__bindgen_ty_1__bindgen_ty_2 {
    pub u_du_zero: u16,
    pub u_du_mtu: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icmph_s__bindgen_ty_1__bindgen_ty_3 {
    pub u_pp_ptr: u8,
    pub u_pp_rsvd: [u8; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icmph_s__bindgen_ty_1__bindgen_ty_4 {
    pub u_rd_gateway: ipaddr_t,
}
pub type icmph_t = icmph_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipha_s {
    pub ipha_version_and_hdr_length: u8,
    pub ipha_type_of_service: u8,
    pub ipha_length: u16,
    pub ipha_ident: u16,
    pub ipha_fragment_offset_and_flags: u16,
    pub ipha_ttl: u8,
    pub ipha_protocol: u8,
    pub ipha_hdr_checksum: u16,
    pub ipha_src: ipaddr_t,
    pub ipha_dst: ipaddr_t,
}
pub type ipha_t = ipha_s;
pub type ip_v6intfid_func_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ill_s, arg2: *mut in6_addr_t),
>;
pub type ip_v6mapinfo_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ill_s,
        arg2: *mut uchar_t,
        arg3: *mut uchar_t,
    ),
>;
pub type ip_v4mapinfo_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ill_s,
        arg2: *mut uchar_t,
        arg3: *mut uchar_t,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_m_s {
    pub ip_m_mac_type: t_uscalar_t,
    pub ip_m_type: illumos_sys_hdrs::c_int,
    pub ip_m_ipv4sap: t_uscalar_t,
    pub ip_m_ipv6sap: t_uscalar_t,
    pub ip_m_v4mapping: ip_v4mapinfo_func_t,
    pub ip_m_v6mapping: ip_v6mapinfo_func_t,
    pub ip_m_v6intfid: ip_v6intfid_func_t,
    pub ip_m_v6destintfid: ip_v6intfid_func_t,
}
pub type ip_m_t = ip_m_s;
unsafe extern "C" {
    pub fn ip_mcast_mapping(
        arg1: *mut ill_s,
        arg2: *mut uchar_t,
        arg3: *mut uchar_t,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct slist_s {
    pub sl_numsrc: illumos_sys_hdrs::c_int,
    pub sl_addr: [in6_addr_t; 64usize],
}
pub type slist_t = slist_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtx_state_s {
    pub rtx_timer: uint_t,
    pub rtx_cnt: illumos_sys_hdrs::c_int,
    pub rtx_fmode_cnt: illumos_sys_hdrs::c_int,
    pub rtx_allow: *mut slist_t,
    pub rtx_block: *mut slist_t,
}
pub type rtx_state_t = rtx_state_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mrec_s {
    pub mrec_next: *mut mrec_s,
    pub mrec_type: u8,
    pub mrec_auxlen: u8,
    pub mrec_group: in6_addr_t,
    pub mrec_srcs: slist_t,
}
pub type mrec_t = mrec_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ilg_s {
    pub ilg_next: *mut ilg_s,
    pub ilg_ptpn: *mut *mut ilg_s,
    pub ilg_connp: *mut conn_s,
    pub ilg_v6group: in6_addr_t,
    pub ilg_ifaddr: ipaddr_t,
    pub ilg_ifindex: uint_t,
    pub ilg_ill: *mut ill_s,
    pub ilg_ilm: *mut ilm_s,
    pub ilg_refcnt: uint_t,
    pub ilg_fmode: mcast_record_t,
    pub ilg_filter: *mut slist_t,
    pub ilg_condemned: boolean_t,
}
pub type ilg_t = ilg_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ilm_s {
    pub ilm_v6addr: in6_addr_t,
    pub ilm_refcnt: illumos_sys_hdrs::c_int,
    pub ilm_timer: uint_t,
    pub ilm_next: *mut ilm_s,
    pub ilm_state: uint_t,
    pub ilm_ill: *mut ill_s,
    pub ilm_zoneid: zoneid_t,
    pub ilm_no_ilg_cnt: illumos_sys_hdrs::c_int,
    pub ilm_fmode: mcast_record_t,
    pub ilm_filter: *mut slist_t,
    pub ilm_pendsrcs: *mut slist_t,
    pub ilm_rtx: rtx_state_t,
    pub ilm_ifaddr: ipaddr_t,
    pub ilm_ipst: *mut ip_stack_t,
}
pub type ilm_t = ilm_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipsa_ref_s {
    pub ipsr_sa: *mut ipsa_s,
    pub ipsr_bucket: *mut isaf_s,
    pub ipsr_gen: u64,
}
pub type ipsa_ref_t = ipsa_ref_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipsec_latch_s {
    pub ipl_lock: kmutex_t,
    pub ipl_refcnt: u32,
    pub ipl_local_cid: *mut ipsid_s,
    pub ipl_remote_cid: *mut ipsid_s,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl ipsec_latch_s {
    #[inline]
    pub fn ipl_ids_latched(&self) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ipl_ids_latched(&mut self, val: illumos_sys_hdrs::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipl_ids_latched_raw(
        this: *const Self,
    ) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ipl_ids_latched_raw(
        this: *mut Self,
        val: illumos_sys_hdrs::c_uint,
    ) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ipl_pad_to_bit_31(&self) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32)
        }
    }
    #[inline]
    pub fn set_ipl_pad_to_bit_31(&mut self, val: illumos_sys_hdrs::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipl_pad_to_bit_31_raw(
        this: *const Self,
    ) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    1usize,
                    31u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ipl_pad_to_bit_31_raw(
        this: *mut Self,
        val: illumos_sys_hdrs::c_uint,
    ) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ipl_ids_latched: illumos_sys_hdrs::c_uint,
        ipl_pad_to_bit_31: illumos_sys_hdrs::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ipl_ids_latched: u32 =
                unsafe { ::core::mem::transmute(ipl_ids_latched) };
            ipl_ids_latched as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ipl_pad_to_bit_31: u32 =
                unsafe { ::core::mem::transmute(ipl_pad_to_bit_31) };
            ipl_pad_to_bit_31 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ipsec_latch_t = ipsec_latch_s;
pub type conn_t = conn_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipsec_selector {
    pub ips_local_addr_v6: in6_addr_t,
    pub ips_remote_addr_v6: in6_addr_t,
    pub ips_local_port: u16,
    pub ips_remote_port: u16,
    pub ips_icmp_type: u8,
    pub ips_icmp_code: u8,
    pub ips_protocol: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl ipsec_selector {
    #[inline]
    pub fn ips_isv4(&self) -> u8 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8)
        }
    }
    #[inline]
    pub fn set_ips_isv4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ips_isv4_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    1u8,
                ) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ips_isv4_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ips_is_icmp_inv_acq(&self) -> u8 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8)
        }
    }
    #[inline]
    pub fn set_ips_is_icmp_inv_acq(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ips_is_icmp_inv_acq_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    1usize,
                    1u8,
                ) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ips_is_icmp_inv_acq_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ips_isv4: u8,
        ips_is_icmp_inv_acq: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ips_isv4: u8 = unsafe { ::core::mem::transmute(ips_isv4) };
            ips_isv4 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ips_is_icmp_inv_acq: u8 =
                unsafe { ::core::mem::transmute(ips_is_icmp_inv_acq) };
            ips_is_icmp_inv_acq as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ipsec_selector_t = ipsec_selector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iulp_s {
    pub iulp_set: boolean_t,
    pub iulp_ssthresh: u32,
    pub iulp_rtt: clock_t,
    pub iulp_rtt_sd: clock_t,
    pub iulp_spipe: u32,
    pub iulp_rpipe: u32,
    pub iulp_rtomax: u32,
    pub iulp_sack: u32,
    pub iulp_mtu: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl iulp_s {
    #[inline]
    pub fn iulp_tstamp_ok(&self) -> u32 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_iulp_tstamp_ok(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn iulp_tstamp_ok_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_iulp_tstamp_ok_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn iulp_wscale_ok(&self) -> u32 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_iulp_wscale_ok(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn iulp_wscale_ok_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    1usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_iulp_wscale_ok_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn iulp_ecn_ok(&self) -> u32 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_iulp_ecn_ok(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn iulp_ecn_ok_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    2usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_iulp_ecn_ok_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn iulp_pmtud_ok(&self) -> u32 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_iulp_pmtud_ok(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn iulp_pmtud_ok_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    3usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_iulp_pmtud_ok_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn iulp_localnet(&self) -> u32 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_iulp_localnet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn iulp_localnet_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    4usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_iulp_localnet_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn iulp_loopback(&self) -> u32 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_iulp_loopback(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn iulp_loopback_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    5usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_iulp_loopback_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn iulp_local(&self) -> u32 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_iulp_local(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn iulp_local_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    6usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_iulp_local_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn iulp_not_used(&self) -> u32 {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32)
        }
    }
    #[inline]
    pub fn set_iulp_not_used(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn iulp_not_used_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    7usize,
                    25u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_iulp_not_used_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                25u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        iulp_tstamp_ok: u32,
        iulp_wscale_ok: u32,
        iulp_ecn_ok: u32,
        iulp_pmtud_ok: u32,
        iulp_localnet: u32,
        iulp_loopback: u32,
        iulp_local: u32,
        iulp_not_used: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let iulp_tstamp_ok: u32 =
                unsafe { ::core::mem::transmute(iulp_tstamp_ok) };
            iulp_tstamp_ok as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let iulp_wscale_ok: u32 =
                unsafe { ::core::mem::transmute(iulp_wscale_ok) };
            iulp_wscale_ok as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let iulp_ecn_ok: u32 =
                unsafe { ::core::mem::transmute(iulp_ecn_ok) };
            iulp_ecn_ok as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let iulp_pmtud_ok: u32 =
                unsafe { ::core::mem::transmute(iulp_pmtud_ok) };
            iulp_pmtud_ok as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let iulp_localnet: u32 =
                unsafe { ::core::mem::transmute(iulp_localnet) };
            iulp_localnet as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let iulp_loopback: u32 =
                unsafe { ::core::mem::transmute(iulp_loopback) };
            iulp_loopback as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let iulp_local: u32 = unsafe { ::core::mem::transmute(iulp_local) };
            iulp_local as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let iulp_not_used: u32 =
                unsafe { ::core::mem::transmute(iulp_not_used) };
            iulp_not_used as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type iulp_t = iulp_s;
pub type ip_mac_tx_cookie_t = usize;
pub type idl_t = idl_s;
pub type idl_tx_list_t = idl_tx_list_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idl_tx_list_s {
    pub txl_cookie: ip_mac_tx_cookie_t,
    pub txl_lock: kmutex_t,
    pub txl_drain_list: *mut idl_t,
    pub txl_drain_index: illumos_sys_hdrs::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idl_s {
    pub idl_conn: *mut conn_t,
    pub idl_lock: kmutex_t,
    pub idl_itl: *mut idl_tx_list_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifrt_s {
    pub ifrt_type: ushort_t,
    pub ifrt_v6addr: in6_addr_t,
    pub ifrt_v6gateway_addr: in6_addr_t,
    pub ifrt_v6setsrc_addr: in6_addr_t,
    pub ifrt_v6mask: in6_addr_t,
    pub ifrt_flags: u32,
    pub ifrt_metrics: iulp_t,
    pub ifrt_zoneid: zoneid_t,
}
pub type ifrt_t = ifrt_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tr_buf_s {
    pub tr_depth: illumos_sys_hdrs::c_int,
    pub tr_time: clock_t,
    pub tr_stack: [pc_t; 14usize],
}
pub type tr_buf_t = tr_buf_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct th_trace_s {
    pub th_refcnt: illumos_sys_hdrs::c_int,
    pub th_trace_lastref: uint_t,
    pub th_id: *mut kthread_t,
    pub th_trbuf: [tr_buf_t; 38usize],
}
pub type th_trace_t = th_trace_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct th_hash_s {
    pub thh_link: list_node_t,
    pub thh_hash: *mut mod_hash_t,
    pub thh_ipst: *mut ip_stack_t,
}
pub type th_hash_t = th_hash_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipif_s {
    pub ipif_next: *mut ipif_s,
    pub ipif_ill: *mut ill_s,
    pub ipif_id: illumos_sys_hdrs::c_int,
    pub ipif_v6lcl_addr: in6_addr_t,
    pub ipif_v6subnet: in6_addr_t,
    pub ipif_v6net_mask: in6_addr_t,
    pub ipif_v6brd_addr: in6_addr_t,
    pub ipif_v6pp_dst_addr: in6_addr_t,
    pub ipif_flags: u64,
    pub ipif_ire_type: uint_t,
    pub ipif_ib_pkt_count: uint_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub ipif_allhosts_ilm: *mut ilm_t,
    pub ipif_solmulti_ilm: *mut ilm_t,
    pub ipif_seqid: uint_t,
    pub ipif_state_flags: uint_t,
    pub ipif_refcnt: uint_t,
    pub ipif_zoneid: zoneid_t,
    pub ipif_recovery_id: timeout_id_t,
    pub ipif_trace_disable: boolean_t,
    pub ipif_bound_ill: *mut ill_s,
    pub ipif_bound_next: *mut ipif_s,
    pub ipif_bound: boolean_t,
    pub ipif_ire_local: *mut ire_s,
    pub ipif_ire_if: *mut ire_s,
}
impl ipif_s {
    #[inline]
    pub fn ipif_was_up(&self) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ipif_was_up(&mut self, val: illumos_sys_hdrs::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipif_was_up_raw(
        this: *const Self,
    ) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ipif_was_up_raw(
        this: *mut Self,
        val: illumos_sys_hdrs::c_uint,
    ) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ipif_addr_ready(&self) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ipif_addr_ready(&mut self, val: illumos_sys_hdrs::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipif_addr_ready_raw(
        this: *const Self,
    ) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    1usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ipif_addr_ready_raw(
        this: *mut Self,
        val: illumos_sys_hdrs::c_uint,
    ) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ipif_was_dup(&self) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ipif_was_dup(&mut self, val: illumos_sys_hdrs::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipif_was_dup_raw(
        this: *const Self,
    ) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    2usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ipif_was_dup_raw(
        this: *mut Self,
        val: illumos_sys_hdrs::c_uint,
    ) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ipif_added_nce(&self) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ipif_added_nce(&mut self, val: illumos_sys_hdrs::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipif_added_nce_raw(
        this: *const Self,
    ) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    3usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ipif_added_nce_raw(
        this: *mut Self,
        val: illumos_sys_hdrs::c_uint,
    ) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ipif_pad_to_31(&self) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32)
        }
    }
    #[inline]
    pub fn set_ipif_pad_to_31(&mut self, val: illumos_sys_hdrs::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipif_pad_to_31_raw(
        this: *const Self,
    ) -> illumos_sys_hdrs::c_uint {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    4usize,
                    28u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ipif_pad_to_31_raw(
        this: *mut Self,
        val: illumos_sys_hdrs::c_uint,
    ) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ipif_was_up: illumos_sys_hdrs::c_uint,
        ipif_addr_ready: illumos_sys_hdrs::c_uint,
        ipif_was_dup: illumos_sys_hdrs::c_uint,
        ipif_added_nce: illumos_sys_hdrs::c_uint,
        ipif_pad_to_31: illumos_sys_hdrs::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ipif_was_up: u32 =
                unsafe { ::core::mem::transmute(ipif_was_up) };
            ipif_was_up as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ipif_addr_ready: u32 =
                unsafe { ::core::mem::transmute(ipif_addr_ready) };
            ipif_addr_ready as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ipif_was_dup: u32 =
                unsafe { ::core::mem::transmute(ipif_was_dup) };
            ipif_was_dup as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ipif_added_nce: u32 =
                unsafe { ::core::mem::transmute(ipif_added_nce) };
            ipif_added_nce as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ipif_pad_to_31: u32 =
                unsafe { ::core::mem::transmute(ipif_pad_to_31) };
            ipif_pad_to_31 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ipif_t = ipif_s;
pub const ip_laddr_t_IPVL_UNICAST_UP: ip_laddr_t = 0;
pub const ip_laddr_t_IPVL_UNICAST_DOWN: ip_laddr_t = 1;
pub const ip_laddr_t_IPVL_MCAST: ip_laddr_t = 2;
pub const ip_laddr_t_IPVL_BCAST: ip_laddr_t = 3;
pub const ip_laddr_t_IPVL_BAD: ip_laddr_t = 4;
pub type ip_laddr_t = illumos_sys_hdrs::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipxop_s {
    pub ipx_lock: kmutex_t,
    pub ipx_writer: *mut kthread_t,
    pub ipx_mphead: *mut mblk_t,
    pub ipx_mptail: *mut mblk_t,
    pub ipx_ipsq: *mut ipsq_s,
    pub ipx_ipsq_queued: boolean_t,
    pub ipx_waitfor: illumos_sys_hdrs::c_int,
    pub ipx_reentry_cnt: illumos_sys_hdrs::c_int,
    pub ipx_current_done: boolean_t,
    pub ipx_current_ioctl: illumos_sys_hdrs::c_int,
    pub ipx_current_ipif: *mut ipif_t,
    pub ipx_pending_ipif: *mut ipif_t,
    pub ipx_pending_mp: *mut mblk_t,
    pub ipx_forced: boolean_t,
}
pub type ipxop_t = ipxop_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipsq_s {
    pub ipsq_lock: kmutex_t,
    pub ipsq_switch_mp: *mut mblk_t,
    pub ipsq_xopq_mphead: *mut mblk_t,
    pub ipsq_xopq_mptail: *mut mblk_t,
    pub ipsq_phyint: *mut phyint,
    pub ipsq_next: *mut ipsq_s,
    pub ipsq_xop: *mut ipxop_s,
    pub ipsq_swxop: *mut ipxop_s,
    pub ipsq_ownxop: ipxop_s,
    pub ipsq_ipst: *mut ip_stack_t,
}
pub type ipsq_t = ipsq_s;
pub const IPIF_DOWN: _bindgen_ty_1 = 1;
pub const ILL_DOWN: _bindgen_ty_1 = 2;
pub const IPIF_FREE: _bindgen_ty_1 = 3;
pub const ILL_FREE: _bindgen_ty_1 = 4;
pub type _bindgen_ty_1 = illumos_sys_hdrs::c_uint;
pub const IPMP_KSTAT_OBYTES: _bindgen_ty_2 = 0;
pub const IPMP_KSTAT_OBYTES64: _bindgen_ty_2 = 1;
pub const IPMP_KSTAT_RBYTES: _bindgen_ty_2 = 2;
pub const IPMP_KSTAT_RBYTES64: _bindgen_ty_2 = 3;
pub const IPMP_KSTAT_OPACKETS: _bindgen_ty_2 = 4;
pub const IPMP_KSTAT_OPACKETS64: _bindgen_ty_2 = 5;
pub const IPMP_KSTAT_OERRORS: _bindgen_ty_2 = 6;
pub const IPMP_KSTAT_IPACKETS: _bindgen_ty_2 = 7;
pub const IPMP_KSTAT_IPACKETS64: _bindgen_ty_2 = 8;
pub const IPMP_KSTAT_IERRORS: _bindgen_ty_2 = 9;
pub const IPMP_KSTAT_MULTIRCV: _bindgen_ty_2 = 10;
pub const IPMP_KSTAT_MULTIXMT: _bindgen_ty_2 = 11;
pub const IPMP_KSTAT_BRDCSTRCV: _bindgen_ty_2 = 12;
pub const IPMP_KSTAT_BRDCSTXMT: _bindgen_ty_2 = 13;
pub const IPMP_KSTAT_LINK_UP: _bindgen_ty_2 = 14;
pub const IPMP_KSTAT_MAX: _bindgen_ty_2 = 15;
pub type _bindgen_ty_2 = illumos_sys_hdrs::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phyint {
    pub phyint_illv4: *mut ill_s,
    pub phyint_illv6: *mut ill_s,
    pub phyint_ifindex: uint_t,
    pub phyint_flags: u64,
    pub phyint_avl_by_index: avl_node_t,
    pub phyint_avl_by_name: avl_node_t,
    pub phyint_lock: kmutex_t,
    pub phyint_ipsq: *mut ipsq_s,
    pub phyint_grp: *mut ipmp_grp_s,
    pub phyint_name: [illumos_sys_hdrs::c_char; 32usize],
    pub phyint_kstats0: [u64; 15usize],
}
pub type phyint_t = phyint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _phyint_list_s_ {
    pub phyint_list_avl_by_index: avl_tree_t,
    pub phyint_list_avl_by_name: avl_tree_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union phyint_list_u {
    pub phyint_list_s: _phyint_list_s_,
    pub phyint_list_filler: [illumos_sys_hdrs::c_char; 128usize],
}
pub type phyint_list_t = phyint_list_u;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipfb_s {
    pub ipfb_ipf: *mut ipf_s,
    pub ipfb_count: usize,
    pub ipfb_lock: kmutex_t,
    pub ipfb_frag_pkts: uint_t,
}
pub type ipfb_t = ipfb_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irb {
    pub irb_ire: *mut ire_s,
    pub irb_lock: krwlock_t,
    pub irb_refcnt: uint_t,
    pub irb_marks: uchar_t,
    pub irb_ire_cnt: uint_t,
    pub irb_nire: illumos_sys_hdrs::c_int,
    pub irb_ipst: *mut ip_stack_t,
}
pub type irb_t = irb;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiphysaddr_s {
    pub mpa_next: *mut multiphysaddr_s,
    pub mpa_addr: [illumos_sys_hdrs::c_char; 40usize],
    pub mpa_refcnt: illumos_sys_hdrs::c_int,
}
pub type multiphysaddr_t = multiphysaddr_s;
pub type dce_t = dce_s;
pub type ire_t = ire_s;
pub type ncec_t = ncec_s;
pub type nce_t = nce_s;
pub type ip_recv_attr_t = ip_recv_attr_s;
pub type ip_xmit_attr_t = ip_xmit_attr_s;
pub type tsol_ire_gw_secattr_t = tsol_ire_gw_secattr_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtc_t {
    pub rtc_ire: *mut ire_t,
    pub rtc_ipaddr: ipaddr_t,
    pub rtc_ip6addr: in6_addr_t,
}
pub type iaflags_t = u64;
pub type pfillinput_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut mblk_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
        arg5: *mut rtc_t,
    ),
>;
pub type pfirerecv_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
    ),
>;
pub type pfiresend_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_xmit_attr_t,
        arg5: *mut u32,
    ) -> illumos_sys_hdrs::c_int,
>;
pub type pfirepostfrag_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut mblk_t,
        arg2: *mut nce_t,
        arg3: iaflags_t,
        arg4: uint_t,
        arg5: u32,
        arg6: zoneid_t,
        arg7: zoneid_t,
        arg8: *mut usize,
    ) -> illumos_sys_hdrs::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ill_if_s_ {
    pub illif_next: *mut ill_if_u,
    pub illif_prev: *mut ill_if_u,
    pub illif_avl_by_ppa: avl_tree_t,
    pub illif_ppa_arena: *mut vmem_t,
    pub illif_mcast_v1: u16,
    pub illif_mcast_v2: u16,
    pub illif_name_len: illumos_sys_hdrs::c_int,
    pub illif_name: [illumos_sys_hdrs::c_char; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ill_if_u {
    pub ill_if_s: _ill_if_s_,
    pub illif_filler: [illumos_sys_hdrs::c_char; 128usize],
}
pub type ill_if_t = ill_if_u;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ill_walk_context_s {
    pub ctx_current_list: illumos_sys_hdrs::c_int,
    pub ctx_last_list: illumos_sys_hdrs::c_int,
}
pub type ill_walk_context_t = ill_walk_context_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ill_g_head_s_ {
    pub ill_g_list_head: *mut ill_if_t,
    pub ill_g_list_tail: *mut ill_if_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ill_g_head_u {
    pub ill_g_head_s: _ill_g_head_s_,
    pub ill_g_head_filler: [illumos_sys_hdrs::c_char; 64usize],
}
pub type ill_g_head_t = ill_g_head_u;
pub type ill_hcksum_capab_t = ill_hcksum_capab_s;
pub type ill_zerocopy_capab_t = ill_zerocopy_capab_s;
pub type ill_dld_capab_t = ill_dld_capab_s;
pub type ill_rx_ring_t = ill_rx_ring;
pub type ill_lso_capab_t = ill_lso_capab_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipmp_illgrp_s {
    pub ig_if: list_t,
    pub ig_actif: list_t,
    pub ig_nactif: uint_t,
    pub ig_next_ill: *mut ill_s,
    pub ig_ipmp_ill: *mut ill_s,
    pub ig_cast_ill: *mut ill_s,
    pub ig_arpent: list_t,
    pub ig_mtu: uint_t,
    pub ig_mc_mtu: uint_t,
}
pub type ipmp_illgrp_t = ipmp_illgrp_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipmp_grp_s {
    pub gr_name: [illumos_sys_hdrs::c_char; 32usize],
    pub gr_ifname: [illumos_sys_hdrs::c_char; 32usize],
    pub gr_mactype: t_uscalar_t,
    pub gr_phyint: *mut phyint_t,
    pub gr_nif: uint_t,
    pub gr_nactif: uint_t,
    pub gr_v4: *mut ipmp_illgrp_t,
    pub gr_v6: *mut ipmp_illgrp_t,
    pub gr_nv4: uint_t,
    pub gr_nv6: uint_t,
    pub gr_pendv4: uint_t,
    pub gr_pendv6: uint_t,
    pub gr_linkdownmp: *mut mblk_t,
    pub gr_ksp: *mut kstat_t,
    pub gr_kstats0: [u64; 15usize],
}
pub type ipmp_grp_t = ipmp_grp_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipmp_arpent_s {
    pub ia_ipaddr: ipaddr_t,
    pub ia_proxyarp: boolean_t,
    pub ia_notified: boolean_t,
    pub ia_node: list_node_t,
    pub ia_flags: u16,
    pub ia_lladdr_len: usize,
    pub ia_lladdr: *mut uchar_t,
}
pub type ipmp_arpent_t = ipmp_arpent_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arl_s {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ill_hcksum_capab_s {
    pub ill_hcksum_version: uint_t,
    pub ill_hcksum_txflags: uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ill_zerocopy_capab_s {
    pub ill_zerocopy_version: uint_t,
    pub ill_zerocopy_flags: uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ill_lso_capab_s {
    pub ill_lso_flags: uint_t,
    pub ill_lso_max_tcpv4: uint_t,
    pub ill_lso_max_tcpv6: uint_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ill_s {
    pub ill_inputfn: pfillinput_t,
    pub ill_ifptr: *mut ill_if_t,
    pub ill_rq: *mut queue_t,
    pub ill_wq: *mut queue_t,
    pub ill_error: illumos_sys_hdrs::c_int,
    pub ill_ipif: *mut ipif_t,
    pub ill_ipif_up_count: uint_t,
    pub ill_max_frag: uint_t,
    pub ill_current_frag: uint_t,
    pub ill_mtu: uint_t,
    pub ill_mc_mtu: uint_t,
    pub ill_metric: uint_t,
    pub ill_name: *mut illumos_sys_hdrs::c_char,
    pub ill_ipif_dup_count: uint_t,
    pub ill_name_length: uint_t,
    pub ill_net_type: uint_t,
    pub ill_ppa: uint_t,
    pub ill_sap: t_uscalar_t,
    pub ill_sap_length: t_scalar_t,
    pub ill_phys_addr_length: uint_t,
    pub ill_bcast_addr_length: uint_t,
    pub ill_mactype: t_uscalar_t,
    pub ill_frag_ptr: *mut u8,
    pub ill_frag_timer_id: timeout_id_t,
    pub ill_frag_hash_tbl: *mut ipfb_t,
    pub ill_mcast_lock: krwlock_t,
    pub ill_mcast_serializer: kmutex_t,
    pub ill_ilm: *mut ilm_t,
    pub ill_global_timer: uint_t,
    pub ill_mcast_type: illumos_sys_hdrs::c_int,
    pub ill_mcast_v1_time: u16,
    pub ill_mcast_v2_time: u16,
    pub ill_mcast_v1_tset: u8,
    pub ill_mcast_v2_tset: u8,
    pub ill_mcast_rv: u8,
    pub ill_mcast_qi: illumos_sys_hdrs::c_int,
    pub ill_bcast_mp: *mut mblk_t,
    pub ill_unbind_mp: *mut mblk_t,
    pub ill_promiscoff_mp: *mut mblk_t,
    pub ill_dlpi_deferred: *mut mblk_t,
    pub ill_dest_addr_mp: *mut mblk_t,
    pub ill_replumb_mp: *mut mblk_t,
    pub ill_phys_addr_mp: *mut mblk_t,
    pub ill_mcast_deferred: *mut mblk_t,
    pub ill_credp: *mut cred_t,
    pub ill_phys_addr: *mut u8,
    pub ill_dest_addr: *mut u8,
    pub ill_state_flags: uint_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub ill_muxid: illumos_sys_hdrs::c_int,
    pub ill_ipf_gen: uint_t,
    pub ill_frag_count: uint_t,
    pub ill_frag_free_num_pkts: uint_t,
    pub ill_last_frag_clean_time: clock_t,
    pub ill_type: illumos_sys_hdrs::c_int,
    pub ill_dlpi_multicast_state: uint_t,
    pub ill_dlpi_fastpath_state: uint_t,
    pub ill_dlpi_capab_state: uint_t,
    pub ill_capab_pending_cnt: uint_t,
    pub ill_capabilities: u64,
    pub ill_hcksum_capab: *mut ill_hcksum_capab_t,
    pub ill_zerocopy_capab: *mut ill_zerocopy_capab_t,
    pub ill_dld_capab: *mut ill_dld_capab_t,
    pub ill_lso_capab: *mut ill_lso_capab_t,
    pub ill_capab_reset_mp: *mut mblk_t,
    pub ill_max_hops: u8,
    pub ill_user_mtu: uint_t,
    pub ill_reachable_time: u32,
    pub ill_reachable_retrans_time: u32,
    pub ill_max_buf: uint_t,
    pub ill_token: in6_addr_t,
    pub ill_dest_token: in6_addr_t,
    pub ill_token_length: uint_t,
    pub ill_xmit_count: u32,
    pub ill_ip_mib: *mut mib2_ipIfStatsEntry_t,
    pub ill_icmp6_mib: *mut mib2_ipv6IfIcmpEntry_t,
    pub ill_phyint: *mut phyint_t,
    pub ill_flags: u64,
    pub ill_lock: kmutex_t,
    pub ill_nd_lla_mp: *mut mblk_t,
    pub ill_nd_lla: *mut u8,
    pub ill_nd_lla_len: uint_t,
    pub ill_phys_addr_pend: t_uscalar_t,
    pub ill_ifname_pending_err: uint_t,
    pub ill_avl_byppa: avl_node_t,
    pub ill_mcast_nces: uint_t,
    pub ill_nce: list_t,
    pub ill_refcnt: uint_t,
    pub ill_ire_cnt: uint_t,
    pub ill_cv: kcondvar_t,
    pub ill_ncec_cnt: uint_t,
    pub ill_nce_cnt: uint_t,
    pub ill_waiters: uint_t,
    pub ill_lmod_rq: *mut queue_t,
    pub ill_lmod_cnt: uint_t,
    pub ill_media: *mut ip_m_t,
    pub ill_dlpi_pending: t_uscalar_t,
    pub ill_usesrc_ifindex: uint_t,
    pub ill_usesrc_grp_next: *mut ill_s,
    pub ill_trace_disable: boolean_t,
    pub ill_zoneid: zoneid_t,
    pub ill_ipst: *mut ip_stack_t,
    pub ill_dhcpinit: u32,
    pub ill_flownotify_mh: *mut illumos_sys_hdrs::c_void,
    pub ill_ilm_cnt: uint_t,
    pub ill_ipallmulti_cnt: uint_t,
    pub ill_ipallmulti_ilm: *mut ilm_t,
    pub ill_saved_ire_mp: *mut mblk_t,
    pub ill_saved_ire_lock: kmutex_t,
    pub ill_saved_ire_cnt: uint_t,
    pub ill_common: *mut arl_ill_common_s,
    pub ill_ire_multicast: *mut ire_t,
    pub ill_defend_start: clock_t,
    pub ill_defend_count: uint_t,
    pub ill_grp: *mut ipmp_illgrp_t,
    pub ill_actnode: list_node_t,
    pub ill_grpnode: list_node_t,
    pub ill_src_ipif: *mut ipif_t,
    pub ill_move_ipif: *mut ipif_t,
    pub ill_nom_cast: boolean_t,
    pub ill_bound_cnt: uint_t,
    pub ill_bound_ipif: *mut ipif_t,
    pub ill_refresh_tid: timeout_id_t,
    pub ill_mrouter_cnt: u32,
    pub ill_allowed_ips_cnt: u32,
    pub ill_allowed_ips: *mut in6_addr_t,
    pub ill_mphysaddr_list: *mut multiphysaddr_t,
}
impl ill_s {
    #[inline]
    pub fn ill_needs_attach(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_needs_attach(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_needs_attach_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_needs_attach_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_reserved(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_reserved(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_reserved_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    1usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_reserved_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_isv6(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_isv6(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_isv6_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    2usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_isv6_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_dlpi_style_set(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_dlpi_style_set(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_dlpi_style_set_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    3usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_dlpi_style_set_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_ifname_pending(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_ifname_pending(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_ifname_pending_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    4usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_ifname_pending_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_logical_down(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_logical_down(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_logical_down_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    5usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_logical_down_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_dl_up(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_dl_up(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_dl_up_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    6usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_dl_up_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_up_ipifs(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_up_ipifs(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_up_ipifs_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    7usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_up_ipifs_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_note_link(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_note_link(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_note_link_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    8usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_note_link_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_capab_reneg(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_capab_reneg(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_capab_reneg_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    9usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_capab_reneg_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_dld_capab_inprog(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_dld_capab_inprog(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_dld_capab_inprog_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    10usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_dld_capab_inprog_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_need_recover_multicast(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_need_recover_multicast(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_need_recover_multicast_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    11usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_need_recover_multicast_raw(
        this: *mut Self,
        val: uint_t,
    ) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_replumbing(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_replumbing(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_replumbing_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    12usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_replumbing_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_arl_dlpi_pending(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_arl_dlpi_pending(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_arl_dlpi_pending_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    13usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_arl_dlpi_pending_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_grp_pending(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_grp_pending(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_grp_pending_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    14usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_grp_pending_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_pad_to_bit_31(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(15usize, 17u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_pad_to_bit_31(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_pad_to_bit_31_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    15usize,
                    17u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_pad_to_bit_31_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                17u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_fragtimer_executing(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_fragtimer_executing(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_fragtimer_executing_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    32usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_fragtimer_executing_raw(
        this: *mut Self,
        val: uint_t,
    ) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_fragtimer_needrestart(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_fragtimer_needrestart(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_fragtimer_needrestart_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    33usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_fragtimer_needrestart_raw(
        this: *mut Self,
        val: uint_t,
    ) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_manual_token(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_manual_token(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_manual_token_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    34usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_manual_token_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_manual_linklocal(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_manual_linklocal(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_manual_linklocal_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    35usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_manual_linklocal_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_manual_dst_linklocal(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_manual_dst_linklocal(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_manual_dst_linklocal_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    36usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_manual_dst_linklocal_raw(
        this: *mut Self,
        val: uint_t,
    ) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_mcast_ncec_cleanup(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_mcast_ncec_cleanup(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_mcast_ncec_cleanup_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    37usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_mcast_ncec_cleanup_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ill_pad_bit_31(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(38usize, 26u8) as u32)
        }
    }
    #[inline]
    pub fn set_ill_pad_bit_31(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ill_pad_bit_31_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    38usize,
                    26u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ill_pad_bit_31_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                26u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ill_needs_attach: uint_t,
        ill_reserved: uint_t,
        ill_isv6: uint_t,
        ill_dlpi_style_set: uint_t,
        ill_ifname_pending: uint_t,
        ill_logical_down: uint_t,
        ill_dl_up: uint_t,
        ill_up_ipifs: uint_t,
        ill_note_link: uint_t,
        ill_capab_reneg: uint_t,
        ill_dld_capab_inprog: uint_t,
        ill_need_recover_multicast: uint_t,
        ill_replumbing: uint_t,
        ill_arl_dlpi_pending: uint_t,
        ill_grp_pending: uint_t,
        ill_pad_to_bit_31: uint_t,
        ill_fragtimer_executing: uint_t,
        ill_fragtimer_needrestart: uint_t,
        ill_manual_token: uint_t,
        ill_manual_linklocal: uint_t,
        ill_manual_dst_linklocal: uint_t,
        ill_mcast_ncec_cleanup: uint_t,
        ill_pad_bit_31: uint_t,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ill_needs_attach: u32 =
                unsafe { ::core::mem::transmute(ill_needs_attach) };
            ill_needs_attach as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ill_reserved: u32 =
                unsafe { ::core::mem::transmute(ill_reserved) };
            ill_reserved as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ill_isv6: u32 = unsafe { ::core::mem::transmute(ill_isv6) };
            ill_isv6 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ill_dlpi_style_set: u32 =
                unsafe { ::core::mem::transmute(ill_dlpi_style_set) };
            ill_dlpi_style_set as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ill_ifname_pending: u32 =
                unsafe { ::core::mem::transmute(ill_ifname_pending) };
            ill_ifname_pending as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ill_logical_down: u32 =
                unsafe { ::core::mem::transmute(ill_logical_down) };
            ill_logical_down as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ill_dl_up: u32 = unsafe { ::core::mem::transmute(ill_dl_up) };
            ill_dl_up as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ill_up_ipifs: u32 =
                unsafe { ::core::mem::transmute(ill_up_ipifs) };
            ill_up_ipifs as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ill_note_link: u32 =
                unsafe { ::core::mem::transmute(ill_note_link) };
            ill_note_link as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ill_capab_reneg: u32 =
                unsafe { ::core::mem::transmute(ill_capab_reneg) };
            ill_capab_reneg as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ill_dld_capab_inprog: u32 =
                unsafe { ::core::mem::transmute(ill_dld_capab_inprog) };
            ill_dld_capab_inprog as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ill_need_recover_multicast: u32 =
                unsafe { ::core::mem::transmute(ill_need_recover_multicast) };
            ill_need_recover_multicast as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ill_replumbing: u32 =
                unsafe { ::core::mem::transmute(ill_replumbing) };
            ill_replumbing as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let ill_arl_dlpi_pending: u32 =
                unsafe { ::core::mem::transmute(ill_arl_dlpi_pending) };
            ill_arl_dlpi_pending as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ill_grp_pending: u32 =
                unsafe { ::core::mem::transmute(ill_grp_pending) };
            ill_grp_pending as u64
        });
        __bindgen_bitfield_unit.set(15usize, 17u8, {
            let ill_pad_to_bit_31: u32 =
                unsafe { ::core::mem::transmute(ill_pad_to_bit_31) };
            ill_pad_to_bit_31 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let ill_fragtimer_executing: u32 =
                unsafe { ::core::mem::transmute(ill_fragtimer_executing) };
            ill_fragtimer_executing as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let ill_fragtimer_needrestart: u32 =
                unsafe { ::core::mem::transmute(ill_fragtimer_needrestart) };
            ill_fragtimer_needrestart as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let ill_manual_token: u32 =
                unsafe { ::core::mem::transmute(ill_manual_token) };
            ill_manual_token as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let ill_manual_linklocal: u32 =
                unsafe { ::core::mem::transmute(ill_manual_linklocal) };
            ill_manual_linklocal as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let ill_manual_dst_linklocal: u32 =
                unsafe { ::core::mem::transmute(ill_manual_dst_linklocal) };
            ill_manual_dst_linklocal as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let ill_mcast_ncec_cleanup: u32 =
                unsafe { ::core::mem::transmute(ill_mcast_ncec_cleanup) };
            ill_mcast_ncec_cleanup as u64
        });
        __bindgen_bitfield_unit.set(38usize, 26u8, {
            let ill_pad_bit_31: u32 =
                unsafe { ::core::mem::transmute(ill_pad_bit_31) };
            ill_pad_bit_31 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ill_t = ill_s;
pub type ifunc_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ipif_t,
        arg2: *mut sockaddr_in,
        arg3: *mut queue_t,
        arg4: *mut mblk_t,
        arg5: *mut ip_ioctl_cmd_s,
        arg6: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_ioctl_cmd_s {
    pub ipi_cmd: illumos_sys_hdrs::c_int,
    pub ipi_copyin_size: usize,
    pub ipi_flags: uint_t,
    pub ipi_cmd_type: uint_t,
    pub ipi_func: ifunc_t,
    pub ipi_func_restart: ifunc_t,
}
pub type ip_ioctl_cmd_t = ip_ioctl_cmd_s;
pub const IF_CMD: _bindgen_ty_3 = 1;
pub const LIF_CMD: _bindgen_ty_3 = 2;
pub const ARP_CMD: _bindgen_ty_3 = 3;
pub const XARP_CMD: _bindgen_ty_3 = 4;
pub const MSFILT_CMD: _bindgen_ty_3 = 5;
pub const MISC_CMD: _bindgen_ty_3 = 6;
pub type _bindgen_ty_3 = illumos_sys_hdrs::c_uint;
unsafe extern "C" {
    pub static mut ip_ndx_ioctl_table: [ip_ioctl_cmd_t; 0usize];
}
unsafe extern "C" {
    pub static mut ip_misc_ioctl_table: [ip_ioctl_cmd_t; 0usize];
}
unsafe extern "C" {
    pub static mut ip_ndx_ioctl_count: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut ip_misc_ioctl_count: illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipmx_s {
    pub ipmx_name: [illumos_sys_hdrs::c_char; 32usize],
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl ipmx_s {
    #[inline]
    pub fn ipmx_arpdev_stream(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_ipmx_arpdev_stream(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipmx_arpdev_stream_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    1u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ipmx_arpdev_stream_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ipmx_notused(&self) -> uint_t {
        unsafe {
            ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32)
        }
    }
    #[inline]
    pub fn set_ipmx_notused(&mut self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ipmx_notused_raw(this: *const Self) -> uint_t {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::core::ptr::addr_of!((*this)._bitfield_1),
                    1usize,
                    31u8,
                ) as u32,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ipmx_notused_raw(this: *mut Self, val: uint_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ipmx_arpdev_stream: uint_t,
        ipmx_notused: uint_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ipmx_arpdev_stream: u32 =
                unsafe { ::core::mem::transmute(ipmx_arpdev_stream) };
            ipmx_arpdev_stream as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ipmx_notused: u32 =
                unsafe { ::core::mem::transmute(ipmx_notused) };
            ipmx_notused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ipmx_t = ipmx_s;
pub const IDCS_UNKNOWN: _bindgen_ty_4 = 0;
pub const IDCS_PROBE_SENT: _bindgen_ty_4 = 1;
pub const IDCS_OK: _bindgen_ty_4 = 2;
pub const IDCS_RESET_SENT: _bindgen_ty_4 = 3;
pub const IDCS_RENEG: _bindgen_ty_4 = 4;
pub const IDCS_FAILED: _bindgen_ty_4 = 5;
pub type _bindgen_ty_4 = illumos_sys_hdrs::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipndp_s {
    pub ip_ndp_getf: ndgetf_t,
    pub ip_ndp_setf: ndsetf_t,
    pub ip_ndp_data: caddr_t,
    pub ip_ndp_name: *mut illumos_sys_hdrs::c_char,
}
pub type ipndp_t = ipndp_s;
pub const ixa_notify_type_t_IXAN_LSO: ixa_notify_type_t = 0;
pub const ixa_notify_type_t_IXAN_PMTU: ixa_notify_type_t = 1;
pub const ixa_notify_type_t_IXAN_ZCOPY: ixa_notify_type_t = 2;
pub type ixa_notify_type_t = illumos_sys_hdrs::c_uint;
pub type ixa_notify_arg_t = uint_t;
pub type ixa_notify_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut illumos_sys_hdrs::c_void,
        ixa: *mut ip_xmit_attr_t,
        arg2: ixa_notify_type_t,
        arg3: ixa_notify_arg_t,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_xmit_attr_s {
    pub ixa_flags: iaflags_t,
    pub ixa_free_flags: u32,
    pub ixa_refcnt: u32,
    pub ixa_xmit_hint: u32,
    pub ixa_pktlen: uint_t,
    pub ixa_zoneid: zoneid_t,
    pub ixa_ire: *mut ire_t,
    pub ixa_ire_generation: uint_t,
    pub ixa_nce: *mut nce_t,
    pub ixa_dce: *mut dce_t,
    pub ixa_dce_generation: uint_t,
    pub ixa_src_generation: uint_t,
    pub ixa_src_preferences: u32,
    pub ixa_pmtu: u32,
    pub ixa_fragsize: u32,
    pub ixa_use_min_mtu: i8,
    pub ixa_postfragfn: pfirepostfrag_t,
    pub ixa_nexthop_v6: in6_addr_t,
    pub ixa_no_loop_zoneid: zoneid_t,
    pub ixa_scopeid: uint_t,
    pub ixa_broadcast_ttl: uint_t,
    pub ixa_multicast_ttl: uint_t,
    pub ixa_multicast_ifindex: uint_t,
    pub ixa_multicast_ifaddr: ipaddr_t,
    pub ixa_raw_cksum_offset: illumos_sys_hdrs::c_int,
    pub ixa_ident: u32,
    pub ixa_conn_id: u64,
    pub ixa_lso_capab: ill_lso_capab_t,
    pub ixa_ipsec_policy_gen: u64,
    pub ixa_ipsec_latch: *mut ipsec_latch_t,
    pub ixa_ipsec_ah_sa: *mut ipsa_s,
    pub ixa_ipsec_esp_sa: *mut ipsa_s,
    pub ixa_ipsec_policy: *mut ipsec_policy_s,
    pub ixa_ipsec_action: *mut ipsec_action_s,
    pub ixa_ipsec_ref: [ipsa_ref_t; 2usize],
    pub ixa_ipsec_src_port: u16,
    pub ixa_ipsec_dst_port: u16,
    pub ixa_ipsec_icmp_type: u8,
    pub ixa_ipsec_icmp_code: u8,
    pub ixa_ipsec_inaf: sa_family_t,
    pub ixa_ipsec_insrc: [u32; 4usize],
    pub ixa_ipsec_indst: [u32; 4usize],
    pub ixa_ipsec_insrcpfx: u8,
    pub ixa_ipsec_indstpfx: u8,
    pub ixa_ipsec_proto: u8,
    pub ixa_ifindex: uint_t,
    pub ixa_ip_hdr_length: u16,
    pub ixa_protocol: u8,
    pub ixa_tsl: *mut ts_label_t,
    pub ixa_ipst: *mut ip_stack_t,
    pub ixa_extra_ident: u32,
    pub ixa_cred: *mut cred_t,
    pub ixa_cpid: pid_t,
    pub ixa_sqp: *mut squeue_t,
    pub ixa_cookie: usize,
    pub ixa_notify: ixa_notify_t,
    pub ixa_notify_cookie: *mut illumos_sys_hdrs::c_void,
    pub ixa_tcpcleanup: uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_recv_attr_s {
    pub ira_flags: iaflags_t,
    pub ira_free_flags: u32,
    pub ira_sqp: *mut squeue_t,
    pub ira_ring: *mut ill_rx_ring_t,
    pub ira_target_sqp: *mut squeue_t,
    pub ira_target_sqp_mp: *mut mblk_t,
    pub ira_xmit_hint: u32,
    pub ira_zoneid: zoneid_t,
    pub ira_pktlen: uint_t,
    pub ira_ip_hdr_length: u16,
    pub ira_protocol: u8,
    pub ira_ttl: u8,
    pub ira_rifindex: uint_t,
    pub ira_ruifindex: uint_t,
    pub ira_tsl: *mut ts_label_t,
    pub ira_rill: *mut ill_t,
    pub ira_ill: *mut ill_t,
    pub ira_cred: *mut cred_t,
    pub ira_cpid: pid_t,
    pub ira_verified_src: ipaddr_t,
    pub ira_ipsec_action: *mut ipsec_action_s,
    pub ira_ipsec_ah_sa: *mut ipsa_s,
    pub ira_ipsec_esp_sa: *mut ipsa_s,
    pub ira_mroute_tunnel: ipaddr_t,
    pub ira_no_loop_zoneid: zoneid_t,
    pub ira_esp_udp_ports: u32,
    pub ira_l2src: [u8; 244usize],
    pub ira_mhip: *mut mac_header_info_s,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dce_s {
    pub dce_generation: uint_t,
    pub dce_flags: uint_t,
    pub dce_ipversion: uint_t,
    pub dce_pmtu: u32,
    pub dce_ident: u32,
    pub dce_uinfo: iulp_t,
    pub dce_next: *mut dce_s,
    pub dce_ptpn: *mut *mut dce_s,
    pub dce_bucket: *mut dcb_s,
    pub dce_u: dce_s__bindgen_ty_1,
    pub dce_ifindex: uint_t,
    pub dce_lock: kmutex_t,
    pub dce_refcnt: uint_t,
    pub dce_last_change_time: u64,
    pub dce_ipst: *mut ip_stack_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dce_s__bindgen_ty_1 {
    pub dceu_v6addr: in6_addr_t,
    pub dceu_v4addr: ipaddr_t,
}
unsafe extern "C" {
    pub static mut ip6opt_ls: uchar_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tsol_gcdb_s {
    pub gcdb_refcnt: uint_t,
    pub gcdb_attr: rtsa_s,
}
pub type tsol_gcdb_t = tsol_gcdb_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tsol_gc_s {
    pub gc_refcnt: uint_t,
    pub gc_grp: *mut tsol_gcgrp_s,
    pub gc_prev: *mut tsol_gc_s,
    pub gc_next: *mut tsol_gc_s,
    pub gc_db: *mut tsol_gcdb_t,
}
pub type tsol_gc_t = tsol_gc_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tsol_gcgrp_addr_s {
    pub ga_af: illumos_sys_hdrs::c_int,
    pub ga_addr: in6_addr_t,
}
pub type tsol_gcgrp_addr_t = tsol_gcgrp_addr_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tsol_gcgrp_s {
    pub gcgrp_refcnt: uint_t,
    pub gcgrp_rwlock: krwlock_t,
    pub gcgrp_count: uint_t,
    pub gcgrp_head: *mut tsol_gc_t,
    pub gcgrp_tail: *mut tsol_gc_t,
    pub gcgrp_addr: tsol_gcgrp_addr_t,
}
pub type tsol_gcgrp_t = tsol_gcgrp_s;
unsafe extern "C" {
    pub static mut gcgrp_lock: kmutex_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tsol_tnrhc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tsol_ire_gw_secattr_s {
    pub igsa_lock: kmutex_t,
    pub igsa_rhc: *mut tsol_tnrhc,
    pub igsa_gc: *mut tsol_gc_t,
}
unsafe extern "C" {
    pub fn irb_refrele_ftable(arg1: *mut irb_t);
}
unsafe extern "C" {
    pub static mut rt_entry_cache: *mut kmem_cache;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ire4 {
    pub ire4_mask: ipaddr_t,
    pub ire4_addr: ipaddr_t,
    pub ire4_gateway_addr: ipaddr_t,
    pub ire4_setsrc_addr: ipaddr_t,
}
pub type ire4_t = ire4;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ire6 {
    pub ire6_mask: in6_addr_t,
    pub ire6_addr: in6_addr_t,
    pub ire6_gateway_addr: in6_addr_t,
    pub ire6_setsrc_addr: in6_addr_t,
}
pub type ire6_t = ire6;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ire_addr {
    pub ire6_u: ire6_t,
    pub ire4_u: ire4_t,
}
pub type ire_addr_u_t = ire_addr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ire_s {
    pub ire_next: *mut ire_s,
    pub ire_ptpn: *mut *mut ire_s,
    pub ire_refcnt: u32,
    pub ire_ill: *mut ill_t,
    pub ire_identical_ref: u32,
    pub ire_ipversion: uchar_t,
    pub ire_type: ushort_t,
    pub ire_generation: uint_t,
    pub ire_ib_pkt_count: uint_t,
    pub ire_ob_pkt_count: uint_t,
    pub ire_create_time: time_t,
    pub ire_flags: u32,
    pub ire_testhidden: boolean_t,
    pub ire_recvfn: pfirerecv_t,
    pub ire_sendfn: pfiresend_t,
    pub ire_postfragfn: pfirepostfrag_t,
    pub ire_masklen: uint_t,
    pub ire_u: ire_addr_u_t,
    pub ire_bucket: *mut irb_t,
    pub ire_lock: kmutex_t,
    pub ire_last_used_time: clock_t,
    pub ire_gw_secattr: *mut tsol_ire_gw_secattr_t,
    pub ire_zoneid: zoneid_t,
    pub ire_nce_cache: *mut nce_t,
    pub ire_nce_capable: boolean_t,
    pub ire_dep_parent: *mut ire_t,
    pub ire_dep_children: *mut ire_t,
    pub ire_dep_sib_next: *mut ire_t,
    pub ire_dep_sib_ptpn: *mut *mut ire_t,
    pub ire_dep_parent_generation: uint_t,
    pub ire_badcnt: uint_t,
    pub ire_last_badcnt: u64,
    pub ire_defense_count: uint_t,
    pub ire_defense_time: uint_t,
    pub ire_trace_disable: boolean_t,
    pub ire_ipst: *mut ip_stack_t,
    pub ire_metrics: iulp_t,
    pub ire_unbound: boolean_t,
}
pub type sin_t = sockaddr_in;
pub type sin6_t = sockaddr_in6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nv_s {
    pub nv_value: u64,
    pub nv_name: *mut illumos_sys_hdrs::c_char,
}
pub type nv_t = nv_s;
unsafe extern "C" {
    pub static mut ip_max_frag_dups: uint_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_pkt_s {
    pub ipp_fields: uint_t,
    pub ipp_addr: in6_addr_t,
    pub ipp_unicast_hops: uint_t,
    pub ipp_hoplimit: uint_t,
    pub ipp_hopoptslen: uint_t,
    pub ipp_rthdrdstoptslen: uint_t,
    pub ipp_rthdrlen: uint_t,
    pub ipp_dstoptslen: uint_t,
    pub ipp_fraghdrlen: uint_t,
    pub ipp_hopopts: *mut ip6_hbh_t,
    pub ipp_rthdrdstopts: *mut ip6_dest_t,
    pub ipp_rthdr: *mut ip6_rthdr_t,
    pub ipp_dstopts: *mut ip6_dest_t,
    pub ipp_fraghdr: *mut ip6_frag_t,
    pub ipp_tclass: u8,
    pub ipp_type_of_service: u8,
    pub ipp_ipv4_options_len: uint_t,
    pub ipp_ipv4_options: *mut u8,
    pub ipp_label_len_v4: uint_t,
    pub ipp_label_v4: *mut u8,
    pub ipp_label_len_v6: uint_t,
    pub ipp_label_v6: *mut u8,
}
pub type ip_pkt_t = ip_pkt_s;
unsafe extern "C" {
    pub fn ip_pkt_free(arg1: *mut ip_pkt_t);
}
unsafe extern "C" {
    pub fn ip_pkt_source_route_v4(arg1: *const ip_pkt_t) -> ipaddr_t;
}
unsafe extern "C" {
    pub fn ip_pkt_source_route_v6(arg1: *const ip_pkt_t) -> *mut in6_addr_t;
}
unsafe extern "C" {
    pub fn ip_pkt_copy(
        arg1: *mut ip_pkt_t,
        arg2: *mut ip_pkt_t,
        arg3: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_pkt_source_route_reverse_v4(arg1: *mut ip_pkt_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conn_opt_arg_s {
    pub coa_connp: *mut conn_t,
    pub coa_ixa: *mut ip_xmit_attr_t,
    pub coa_ipp: *mut ip_pkt_t,
    pub coa_ancillary: boolean_t,
    pub coa_changed: uint_t,
}
pub type conn_opt_arg_t = conn_opt_arg_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_info_s {
    pub ci_ipif: *mut ipif_t,
    pub ci_sin: *mut sin_t,
    pub ci_sin6: *mut sin6_t,
    pub ci_lifr: *mut lifreq,
}
pub type cmd_info_t = cmd_info_s;
unsafe extern "C" {
    pub static mut ire_cache: *mut kmem_cache;
}
unsafe extern "C" {
    pub static mut ip_g_all_ones: ipaddr_t;
}
unsafe extern "C" {
    pub static mut ip_loopback_mtu: uint_t;
}
unsafe extern "C" {
    pub static mut ip_loopback_mtuplus: uint_t;
}
unsafe extern "C" {
    pub static mut ip_loopback_mtu_v6plus: uint_t;
}
unsafe extern "C" {
    pub static mut ip_minor_arena_sa: *mut vmem_t;
}
unsafe extern "C" {
    pub static mut ip_minor_arena_la: *mut vmem_t;
}
unsafe extern "C" {
    pub static mut dohwcksum: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut ipif_loopback_name: [illumos_sys_hdrs::c_char; 0usize];
}
unsafe extern "C" {
    pub static mut ire_nv_tbl: *mut nv_t;
}
unsafe extern "C" {
    pub static mut ip_mod_info: module_info;
}
unsafe extern "C" {
    pub static mut ip_debug: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut ip_thread_data: uint_t;
}
unsafe extern "C" {
    pub static mut ip_thread_rwlock: krwlock_t;
}
unsafe extern "C" {
    pub static mut ip_thread_list: list_t;
}
pub type ihandle_t = illumos_sys_hdrs::c_int;
pub type phandle_t = illumos_sys_hdrs::c_int;
pub type pnode_t = phandle_t;
unsafe extern "C" {
    pub fn prom_map(
        virthint: caddr_t,
        space: uint_t,
        phys: uint_t,
        size: uint_t,
    ) -> caddr_t;
}
unsafe extern "C" {
    pub fn prom_alloc(
        virthint: caddr_t,
        size: uint_t,
        align: illumos_sys_hdrs::c_int,
    ) -> caddr_t;
}
unsafe extern "C" {
    pub fn prom_free(virt: caddr_t, size: uint_t);
}
unsafe extern "C" {
    pub fn prom_childnode(nodeid: pnode_t) -> pnode_t;
}
unsafe extern "C" {
    pub fn prom_nextnode(nodeid: pnode_t) -> pnode_t;
}
unsafe extern "C" {
    pub fn prom_optionsnode() -> pnode_t;
}
unsafe extern "C" {
    pub fn prom_alias_node() -> pnode_t;
}
unsafe extern "C" {
    pub fn prom_rootnode() -> pnode_t;
}
unsafe extern "C" {
    pub fn prom_getproplen(
        nodeid: pnode_t,
        name: caddr_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_getprop(
        nodeid: pnode_t,
        name: caddr_t,
        value: caddr_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_nextprop(
        nodeid: pnode_t,
        previous: caddr_t,
        next: caddr_t,
    ) -> caddr_t;
}
unsafe extern "C" {
    pub fn prom_decode_composite_string(
        buf: *mut illumos_sys_hdrs::c_void,
        buflen: usize,
        prev: *mut illumos_sys_hdrs::c_char,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn prom_finddevice(path: *mut illumos_sys_hdrs::c_char) -> pnode_t;
}
unsafe extern "C" {
    pub fn prom_bounded_getprop(
        nodeid: pnode_t,
        name: caddr_t,
        buffer: caddr_t,
        buflen: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_devname_from_pathname(
        path: *mut illumos_sys_hdrs::c_char,
        buffer: *mut illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_path_gettoken(
        from: *mut illumos_sys_hdrs::c_char,
        to: *mut illumos_sys_hdrs::c_char,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn prom_stdin_is_keyboard() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_stdout_is_framebuffer() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_framebuffer_getpos(
        row: *mut illumos_sys_hdrs::c_int,
        col: *mut illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn prom_framebuffer_getcolors(
        fg: *mut illumos_sys_hdrs::c_int,
        bg: *mut illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn prom_stdinpath() -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn prom_stdoutpath() -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn prom_strip_options(
        from: *mut illumos_sys_hdrs::c_char,
        to: *mut illumos_sys_hdrs::c_char,
    );
}
unsafe extern "C" {
    pub fn prom_pathname(arg1: *mut illumos_sys_hdrs::c_char);
}
unsafe extern "C" {
    pub fn prom_enter_mon();
}
unsafe extern "C" {
    pub fn prom_exit_to_mon() -> !;
}
unsafe extern "C" {
    pub fn prom_reboot(bootstr: *mut illumos_sys_hdrs::c_char) -> !;
}
unsafe extern "C" {
    pub fn prom_panic(string: *mut illumos_sys_hdrs::c_char) -> !;
}
unsafe extern "C" {
    pub fn prom_is_openprom() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_is_p1275() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_version_name(
        buf: *mut illumos_sys_hdrs::c_char,
        buflen: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_version_boot_syscalls() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_gettime() -> uint_t;
}
unsafe extern "C" {
    pub fn prom_bootpath() -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn prom_bootargs() -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn prom_init(
        progname: *mut illumos_sys_hdrs::c_char,
        prom_cookie: *mut illumos_sys_hdrs::c_void,
    );
}
pub type prom_generation_cookie_t = uint_t;
unsafe extern "C" {
    pub fn prom_getchar() -> uchar_t;
}
unsafe extern "C" {
    pub fn prom_putchar(c: illumos_sys_hdrs::c_char);
}
unsafe extern "C" {
    pub fn prom_mayget() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_mayput(c: illumos_sys_hdrs::c_char) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_open(
        name: *mut illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_close(fd: illumos_sys_hdrs::c_int) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_read(
        fd: illumos_sys_hdrs::c_int,
        buf: caddr_t,
        len: uint_t,
        startblk: uint_t,
        type_: illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_write(
        fd: illumos_sys_hdrs::c_int,
        buf: caddr_t,
        len: uint_t,
        startblk: uint_t,
        devtype: illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_seek(
        fd: illumos_sys_hdrs::c_int,
        offset: illumos_sys_hdrs::c_ulonglong,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_writestr(buf: *const illumos_sys_hdrs::c_char, bufsize: usize);
}
unsafe extern "C" {
    pub fn prom_printf(fmt: *const illumos_sys_hdrs::c_char, ...);
}
unsafe extern "C" {
    pub fn prom_vprintf(
        fmt: *const illumos_sys_hdrs::c_char,
        adx: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn prom_sprintf(
        s: *mut illumos_sys_hdrs::c_char,
        fmt: *const illumos_sys_hdrs::c_char,
        ...
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn prom_vsprintf(
        s: *mut illumos_sys_hdrs::c_char,
        fmt: *const illumos_sys_hdrs::c_char,
        adx: *mut __va_list_tag,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn prom_findnode_byname(
        id: pnode_t,
        name: *mut illumos_sys_hdrs::c_char,
    ) -> pnode_t;
}
unsafe extern "C" {
    pub fn prom_get_extend_name() -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn prom_devreset(
        arg1: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut OpenCount: illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihandle {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub static mut open_devices: [*mut ihandle; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct promif_owrap {
    pub preout: ::core::option::Option<unsafe extern "C" fn()>,
    pub postout: ::core::option::Option<unsafe extern "C" fn()>,
}
pub type promif_owrap_t = promif_owrap;
unsafe extern "C" {
    pub fn prom_suspend_prepost();
}
unsafe extern "C" {
    pub fn prom_resume_prepost();
}
unsafe extern "C" {
    pub fn prom_set_security_key(
        keyname: *mut illumos_sys_hdrs::c_char,
        buf: caddr_t,
        buflen: illumos_sys_hdrs::c_int,
        reslen: *mut illumos_sys_hdrs::c_int,
        status: *mut illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn prom_get_security_key(
        keyname: *mut illumos_sys_hdrs::c_char,
        buf: caddr_t,
        buflen: illumos_sys_hdrs::c_int,
        keylen: *mut illumos_sys_hdrs::c_int,
        status: *mut illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mac_header_info_s {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn ill_frag_timer(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn ill_first(
        arg1: illumos_sys_hdrs::c_int,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut ill_walk_context_t,
        arg4: *mut ip_stack_t,
    ) -> *mut ill_t;
}
unsafe extern "C" {
    pub fn ill_next(
        arg1: *mut ill_walk_context_t,
        arg2: *mut ill_t,
    ) -> *mut ill_t;
}
unsafe extern "C" {
    pub fn ill_frag_timer_start(arg1: *mut ill_t);
}
unsafe extern "C" {
    pub fn ill_nic_event_dispatch(
        arg1: *mut ill_t,
        arg2: lif_if_t,
        arg3: nic_event_t,
        arg4: nic_event_data_t,
        arg5: usize,
    );
}
unsafe extern "C" {
    pub fn ip_carve_mp(arg1: *mut *mut mblk_t, arg2: isize) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_dlpi_alloc(arg1: usize, arg2: t_uscalar_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_dlnotify_alloc(arg1: uint_t, arg2: uint_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_dlnotify_alloc2(
        arg1: uint_t,
        arg2: uint_t,
        arg3: uint_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_dot_addr(
        arg1: ipaddr_t,
        arg2: *mut illumos_sys_hdrs::c_char,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn mac_colon_addr(
        arg1: *const u8,
        arg2: usize,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: usize,
    ) -> *const illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn ip_lwput(
        arg1: *mut queue_t,
        arg2: *mut mblk_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn icmp_err_rate_limit(arg1: *mut ip_stack_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn icmp_frag_needed(
        arg1: *mut mblk_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn icmp_inbound_v4(
        arg1: *mut mblk_t,
        arg2: *mut ip_recv_attr_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn icmp_time_exceeded(
        arg1: *mut mblk_t,
        arg2: u8,
        arg3: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn icmp_unreachable(
        arg1: *mut mblk_t,
        arg2: u8,
        arg3: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ip_ipsec_policy_inherit(
        arg1: *mut conn_t,
        arg2: *mut conn_t,
        arg3: *mut ip_recv_attr_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ip_pullup(
        arg1: *mut mblk_t,
        arg2: isize,
        arg3: *mut ip_recv_attr_t,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn ip_setl2src(
        arg1: *mut mblk_t,
        arg2: *mut ip_recv_attr_t,
        arg3: *mut ill_t,
    );
}
unsafe extern "C" {
    pub fn ip_check_and_align_header(
        arg1: *mut mblk_t,
        arg2: uint_t,
        arg3: *mut ip_recv_attr_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_check_length(
        arg1: *mut mblk_t,
        arg2: *mut uchar_t,
        arg3: isize,
        arg4: uint_t,
        arg5: uint_t,
        arg6: *mut ip_recv_attr_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_check_optlen(
        arg1: *mut mblk_t,
        arg2: *mut ipha_t,
        arg3: uint_t,
        arg4: uint_t,
        arg5: *mut ip_recv_attr_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_fix_dbref(
        arg1: *mut mblk_t,
        arg2: *mut ip_recv_attr_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_cksum(
        arg1: *mut mblk_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: u32,
    ) -> uint_t;
}
unsafe extern "C" {
    pub fn ip_close(
        arg1: *mut queue_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_csum_hdr(arg1: *mut ipha_t) -> u16;
}
unsafe extern "C" {
    pub fn ip_forward_xmit_v4(
        arg1: *mut nce_t,
        arg2: *mut ill_t,
        arg3: *mut mblk_t,
        arg4: *mut ipha_t,
        arg5: *mut ip_recv_attr_t,
        arg6: u32,
        arg7: u32,
    );
}
unsafe extern "C" {
    pub fn ip_forward_options(
        arg1: *mut mblk_t,
        arg2: *mut ipha_t,
        arg3: *mut ill_t,
        arg4: *mut ip_recv_attr_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ip_fragment_v4(
        arg1: *mut mblk_t,
        arg2: *mut nce_t,
        arg3: iaflags_t,
        arg4: uint_t,
        arg5: u32,
        arg6: u32,
        arg7: zoneid_t,
        arg8: zoneid_t,
        postfragfn: pfirepostfrag_t,
        cookie: *mut usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_proto_not_sup(arg1: *mut mblk_t, arg2: *mut ip_recv_attr_t);
}
unsafe extern "C" {
    pub fn ip_ire_g_fini();
}
unsafe extern "C" {
    pub fn ip_ire_g_init();
}
unsafe extern "C" {
    pub fn ip_ire_fini(arg1: *mut ip_stack_t);
}
unsafe extern "C" {
    pub fn ip_ire_init(arg1: *mut ip_stack_t);
}
unsafe extern "C" {
    pub fn ip_mdata_to_mhi(
        arg1: *mut ill_t,
        arg2: *mut mblk_t,
        arg3: *mut mac_header_info_s,
    );
}
unsafe extern "C" {
    pub fn ip_openv4(
        q: *mut queue_t,
        devp: *mut dev_t,
        flag: illumos_sys_hdrs::c_int,
        sflag: illumos_sys_hdrs::c_int,
        credp: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_openv6(
        q: *mut queue_t,
        devp: *mut dev_t,
        flag: illumos_sys_hdrs::c_int,
        sflag: illumos_sys_hdrs::c_int,
        credp: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_reassemble(
        arg1: *mut mblk_t,
        arg2: *mut ipf_t,
        arg3: uint_t,
        arg4: boolean_t,
        arg5: *mut ill_t,
        arg6: usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_rput(
        arg1: *mut queue_t,
        arg2: *mut mblk_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_input(
        arg1: *mut ill_t,
        arg2: *mut ill_rx_ring_t,
        arg3: *mut mblk_t,
        arg4: *mut mac_header_info_s,
    );
}
unsafe extern "C" {
    pub fn ip_input_v6(
        arg1: *mut ill_t,
        arg2: *mut ill_rx_ring_t,
        arg3: *mut mblk_t,
        arg4: *mut mac_header_info_s,
    );
}
unsafe extern "C" {
    pub fn ip_input_common_v4(
        arg1: *mut ill_t,
        arg2: *mut ill_rx_ring_t,
        arg3: *mut mblk_t,
        arg4: *mut mac_header_info_s,
        arg5: *mut squeue_t,
        arg6: *mut *mut mblk_t,
        arg7: *mut uint_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_input_common_v6(
        arg1: *mut ill_t,
        arg2: *mut ill_rx_ring_t,
        arg3: *mut mblk_t,
        arg4: *mut mac_header_info_s,
        arg5: *mut squeue_t,
        arg6: *mut *mut mblk_t,
        arg7: *mut uint_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ill_input_full_v4(
        arg1: *mut mblk_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
        arg5: *mut rtc_t,
    );
}
unsafe extern "C" {
    pub fn ill_input_short_v4(
        arg1: *mut mblk_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
        arg5: *mut rtc_t,
    );
}
unsafe extern "C" {
    pub fn ill_input_full_v6(
        arg1: *mut mblk_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
        arg5: *mut rtc_t,
    );
}
unsafe extern "C" {
    pub fn ill_input_short_v6(
        arg1: *mut mblk_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
        arg5: *mut rtc_t,
    );
}
unsafe extern "C" {
    pub fn ip_input_options(
        arg1: *mut ipha_t,
        arg2: ipaddr_t,
        arg3: *mut mblk_t,
        arg4: *mut ip_recv_attr_t,
        arg5: *mut illumos_sys_hdrs::c_int,
    ) -> ipaddr_t;
}
unsafe extern "C" {
    pub fn ip_input_local_options(
        arg1: *mut mblk_t,
        arg2: *mut ipha_t,
        arg3: *mut ip_recv_attr_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ip_input_fragment(
        arg1: *mut mblk_t,
        arg2: *mut ipha_t,
        arg3: *mut ip_recv_attr_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_input_fragment_v6(
        arg1: *mut mblk_t,
        arg2: *mut ip6_t,
        arg3: *mut ip6_frag_t,
        arg4: uint_t,
        arg5: *mut ip_recv_attr_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_input_post_ipsec(arg1: *mut mblk_t, arg2: *mut ip_recv_attr_t);
}
unsafe extern "C" {
    pub fn ip_fanout_v4(
        arg1: *mut mblk_t,
        arg2: *mut ipha_t,
        arg3: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ip_fanout_v6(
        arg1: *mut mblk_t,
        arg2: *mut ip6_t,
        arg3: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ip_fanout_proto_conn(
        arg1: *mut conn_t,
        arg2: *mut mblk_t,
        arg3: *mut ipha_t,
        arg4: *mut ip6_t,
        arg5: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ip_fanout_proto_v4(
        arg1: *mut mblk_t,
        arg2: *mut ipha_t,
        arg3: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ip_fanout_send_icmp_v4(
        arg1: *mut mblk_t,
        arg2: uint_t,
        arg3: uint_t,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ip_fanout_udp_conn(
        arg1: *mut conn_t,
        arg2: *mut mblk_t,
        arg3: *mut ipha_t,
        arg4: *mut ip6_t,
        arg5: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ip_fanout_udp_multi_v4(
        arg1: *mut mblk_t,
        arg2: *mut ipha_t,
        arg3: u16,
        arg4: u16,
        arg5: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn zero_spi_check(
        arg1: *mut mblk_t,
        arg2: *mut ip_recv_attr_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_build_hdrs_v4(
        arg1: *mut uchar_t,
        arg2: uint_t,
        arg3: *const ip_pkt_t,
        arg4: u8,
    );
}
unsafe extern "C" {
    pub fn ip_find_hdr_v4(
        arg1: *mut ipha_t,
        arg2: *mut ip_pkt_t,
        arg3: boolean_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_total_hdrs_len_v4(
        arg1: *const ip_pkt_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_accept_tcp(
        arg1: *mut ill_t,
        arg2: *mut ill_rx_ring_t,
        arg3: *mut squeue_t,
        arg4: *mut mblk_t,
        arg5: *mut *mut mblk_t,
        cnt: *mut uint_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_rput_dlpi(arg1: *mut ill_t, arg2: *mut mblk_t);
}
unsafe extern "C" {
    pub fn ip_rput_notdata(arg1: *mut ill_t, arg2: *mut mblk_t);
}
unsafe extern "C" {
    pub fn ip_mib2_add_ip_stats(
        arg1: *mut mib2_ipIfStatsEntry_t,
        arg2: *mut mib2_ipIfStatsEntry_t,
    );
}
unsafe extern "C" {
    pub fn ip_mib2_add_icmp6_stats(
        arg1: *mut mib2_ipv6IfIcmpEntry_t,
        arg2: *mut mib2_ipv6IfIcmpEntry_t,
    );
}
unsafe extern "C" {
    pub fn ip_rput_other(
        arg1: *mut ipsq_t,
        arg2: *mut queue_t,
        arg3: *mut mblk_t,
        arg4: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn ip_check_multihome(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: *mut ire_t,
        arg3: *mut ill_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ip_send_potential_redirect_v4(
        arg1: *mut mblk_t,
        arg2: *mut ipha_t,
        arg3: *mut ire_t,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ip_set_destination_v4(
        arg1: *mut ipaddr_t,
        arg2: ipaddr_t,
        arg3: ipaddr_t,
        arg4: *mut ip_xmit_attr_t,
        arg5: *mut iulp_t,
        arg6: u32,
        arg7: uint_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_set_destination_v6(
        arg1: *mut in6_addr_t,
        arg2: *const in6_addr_t,
        arg3: *const in6_addr_t,
        arg4: *mut ip_xmit_attr_t,
        arg5: *mut iulp_t,
        arg6: u32,
        arg7: uint_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_output_simple(
        arg1: *mut mblk_t,
        arg2: *mut ip_xmit_attr_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_output_simple_v4(
        arg1: *mut mblk_t,
        arg2: *mut ip_xmit_attr_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_output_simple_v6(
        arg1: *mut mblk_t,
        arg2: *mut ip_xmit_attr_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_output_options(
        arg1: *mut mblk_t,
        arg2: *mut ipha_t,
        arg3: *mut ip_xmit_attr_t,
        arg4: *mut ill_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_output_local_options(arg1: *mut ipha_t, arg2: *mut ip_stack_t);
}
unsafe extern "C" {
    pub fn conn_get_ixa(
        arg1: *mut conn_t,
        arg2: boolean_t,
    ) -> *mut ip_xmit_attr_t;
}
unsafe extern "C" {
    pub fn conn_get_ixa_tryhard(
        arg1: *mut conn_t,
        arg2: boolean_t,
    ) -> *mut ip_xmit_attr_t;
}
unsafe extern "C" {
    pub fn conn_replace_ixa(
        arg1: *mut conn_t,
        arg2: *mut ip_xmit_attr_t,
    ) -> *mut ip_xmit_attr_t;
}
unsafe extern "C" {
    pub fn conn_get_ixa_exclusive(arg1: *mut conn_t) -> *mut ip_xmit_attr_t;
}
unsafe extern "C" {
    pub fn ip_xmit_attr_duplicate(
        arg1: *mut ip_xmit_attr_t,
    ) -> *mut ip_xmit_attr_t;
}
unsafe extern "C" {
    pub fn ip_xmit_attr_replace_tsl(
        arg1: *mut ip_xmit_attr_t,
        arg2: *mut ts_label_t,
    );
}
unsafe extern "C" {
    pub fn ip_xmit_attr_restore_tsl(
        arg1: *mut ip_xmit_attr_t,
        arg2: *mut cred_t,
    );
}
unsafe extern "C" {
    pub fn ip_recv_attr_replace_label(
        arg1: *mut ip_recv_attr_t,
        arg2: *mut ts_label_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ixa_inactive(arg1: *mut ip_xmit_attr_t);
}
unsafe extern "C" {
    pub fn ixa_refrele(arg1: *mut ip_xmit_attr_t);
}
unsafe extern "C" {
    pub fn ixa_check_drain_insert(
        arg1: *mut conn_t,
        arg2: *mut ip_xmit_attr_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ixa_cleanup(arg1: *mut ip_xmit_attr_t);
}
unsafe extern "C" {
    pub fn ira_cleanup(arg1: *mut ip_recv_attr_t, arg2: boolean_t);
}
unsafe extern "C" {
    pub fn ixa_safe_copy(arg1: *mut ip_xmit_attr_t, arg2: *mut ip_xmit_attr_t);
}
unsafe extern "C" {
    pub fn conn_ip_output(
        arg1: *mut mblk_t,
        arg2: *mut ip_xmit_attr_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_output_verify_local(arg1: *mut ip_xmit_attr_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn ip_output_process_local(
        arg1: *mut mblk_t,
        arg2: *mut ip_xmit_attr_t,
        arg3: boolean_t,
        arg4: boolean_t,
        arg5: *mut conn_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn conn_opt_get(
        arg1: *mut conn_opt_arg_t,
        arg2: t_scalar_t,
        arg3: t_scalar_t,
        arg4: *mut uchar_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn conn_opt_set(
        arg1: *mut conn_opt_arg_t,
        arg2: t_scalar_t,
        arg3: t_scalar_t,
        arg4: uint_t,
        arg5: *mut uchar_t,
        arg6: boolean_t,
        arg7: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn conn_same_as_last_v4(
        arg1: *mut conn_t,
        arg2: *mut sin_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn conn_same_as_last_v6(
        arg1: *mut conn_t,
        arg2: *mut sin6_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn conn_update_label(
        arg1: *const conn_t,
        arg2: *const ip_xmit_attr_t,
        arg3: *const in6_addr_t,
        arg4: *mut ip_pkt_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_opt_set_multicast_group(
        arg1: *mut conn_t,
        arg2: t_scalar_t,
        arg3: *mut uchar_t,
        arg4: boolean_t,
        arg5: boolean_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_opt_set_multicast_sources(
        arg1: *mut conn_t,
        arg2: t_scalar_t,
        arg3: *mut uchar_t,
        arg4: boolean_t,
        arg5: boolean_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn conn_getsockname(
        arg1: *mut conn_t,
        arg2: *mut sockaddr,
        arg3: *mut uint_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn conn_getpeername(
        arg1: *mut conn_t,
        arg2: *mut sockaddr,
        arg3: *mut uint_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn conn_build_hdr_template(
        arg1: *mut conn_t,
        arg2: uint_t,
        arg3: uint_t,
        arg4: *const in6_addr_t,
        arg5: *const in6_addr_t,
        arg6: u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn conn_prepend_hdr(
        arg1: *mut ip_xmit_attr_t,
        arg2: *const ip_pkt_t,
        arg3: *const in6_addr_t,
        arg4: *const in6_addr_t,
        arg5: u8,
        arg6: u32,
        arg7: uint_t,
        arg8: *mut mblk_t,
        arg9: uint_t,
        arg10: uint_t,
        arg11: *mut u32,
        arg12: *mut illumos_sys_hdrs::c_int,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_attr_newdst(arg1: *mut ip_xmit_attr_t);
}
unsafe extern "C" {
    pub fn ip_attr_nexthop(
        arg1: *const ip_pkt_t,
        arg2: *const ip_xmit_attr_t,
        arg3: *const in6_addr_t,
        arg4: *mut in6_addr_t,
    );
}
unsafe extern "C" {
    pub fn conn_connect(
        arg1: *mut conn_t,
        arg2: *mut iulp_t,
        arg3: u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_attr_connect(
        arg1: *const conn_t,
        arg2: *mut ip_xmit_attr_t,
        arg3: *const in6_addr_t,
        arg4: *const in6_addr_t,
        arg5: *const in6_addr_t,
        arg6: in_port_t,
        arg7: *mut in6_addr_t,
        arg8: *mut iulp_t,
        arg9: u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn conn_inherit_parent(
        arg1: *mut conn_t,
        arg2: *mut conn_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn conn_ixa_cleanup(
        connp: *mut conn_t,
        arg: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn conn_wantpacket(
        arg1: *mut conn_t,
        arg2: *mut ip_recv_attr_t,
        arg3: *mut ipha_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ip_type_v4(arg1: ipaddr_t, arg2: *mut ip_stack_t) -> uint_t;
}
unsafe extern "C" {
    pub fn ip_type_v6(arg1: *const in6_addr_t, arg2: *mut ip_stack_t)
        -> uint_t;
}
unsafe extern "C" {
    pub fn ip_wput_nondata(
        arg1: *mut queue_t,
        arg2: *mut mblk_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_wsrv(arg1: *mut queue_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_nv_lookup(
        arg1: *mut nv_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn ip_local_addr_ok_v6(
        arg1: *const in6_addr_t,
        arg2: *const in6_addr_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ip_remote_addr_ok_v6(
        arg1: *const in6_addr_t,
        arg2: *const in6_addr_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ip_massage_options(
        arg1: *mut ipha_t,
        arg2: *mut netstack_t,
    ) -> ipaddr_t;
}
unsafe extern "C" {
    pub fn ip_net_mask(arg1: ipaddr_t) -> ipaddr_t;
}
unsafe extern "C" {
    pub fn arp_bringup_done(arg1: *mut ill_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn arp_replumb_done(arg1: *mut ill_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub static mut iprinitv6: qinit;
}
unsafe extern "C" {
    pub fn ipmp_init(arg1: *mut ip_stack_t);
}
unsafe extern "C" {
    pub fn ipmp_destroy(arg1: *mut ip_stack_t);
}
unsafe extern "C" {
    pub fn ipmp_grp_create(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut phyint_t,
    ) -> *mut ipmp_grp_t;
}
unsafe extern "C" {
    pub fn ipmp_grp_destroy(arg1: *mut ipmp_grp_t);
}
unsafe extern "C" {
    pub fn ipmp_grp_info(arg1: *const ipmp_grp_t, arg2: *mut lifgroupinfo_t);
}
unsafe extern "C" {
    pub fn ipmp_grp_rename(
        arg1: *mut ipmp_grp_t,
        arg2: *const illumos_sys_hdrs::c_char,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ipmp_grp_lookup(
        arg1: *const illumos_sys_hdrs::c_char,
        arg2: *mut ip_stack_t,
    ) -> *mut ipmp_grp_t;
}
unsafe extern "C" {
    pub fn ipmp_grp_vet_phyint(
        arg1: *mut ipmp_grp_t,
        arg2: *mut phyint_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ipmp_illgrp_create(arg1: *mut ill_t) -> *mut ipmp_illgrp_t;
}
unsafe extern "C" {
    pub fn ipmp_illgrp_destroy(arg1: *mut ipmp_illgrp_t);
}
unsafe extern "C" {
    pub fn ipmp_illgrp_add_ipif(
        arg1: *mut ipmp_illgrp_t,
        arg2: *mut ipif_t,
    ) -> *mut ill_t;
}
unsafe extern "C" {
    pub fn ipmp_illgrp_del_ipif(arg1: *mut ipmp_illgrp_t, arg2: *mut ipif_t);
}
unsafe extern "C" {
    pub fn ipmp_illgrp_next_ill(arg1: *mut ipmp_illgrp_t) -> *mut ill_t;
}
unsafe extern "C" {
    pub fn ipmp_illgrp_hold_next_ill(arg1: *mut ipmp_illgrp_t) -> *mut ill_t;
}
unsafe extern "C" {
    pub fn ipmp_illgrp_hold_cast_ill(arg1: *mut ipmp_illgrp_t) -> *mut ill_t;
}
unsafe extern "C" {
    pub fn ipmp_illgrp_ipmp_ill(arg1: *mut ipmp_illgrp_t) -> *mut ill_t;
}
unsafe extern "C" {
    pub fn ipmp_illgrp_refresh_mtu(arg1: *mut ipmp_illgrp_t);
}
unsafe extern "C" {
    pub fn ipmp_illgrp_create_arpent(
        arg1: *mut ipmp_illgrp_t,
        arg2: boolean_t,
        arg3: ipaddr_t,
        arg4: *mut uchar_t,
        arg5: usize,
        arg6: u16,
    ) -> *mut ipmp_arpent_t;
}
unsafe extern "C" {
    pub fn ipmp_illgrp_destroy_arpent(
        arg1: *mut ipmp_illgrp_t,
        arg2: *mut ipmp_arpent_t,
    );
}
unsafe extern "C" {
    pub fn ipmp_illgrp_lookup_arpent(
        arg1: *mut ipmp_illgrp_t,
        arg2: *mut ipaddr_t,
    ) -> *mut ipmp_arpent_t;
}
unsafe extern "C" {
    pub fn ipmp_illgrp_refresh_arpent(arg1: *mut ipmp_illgrp_t);
}
unsafe extern "C" {
    pub fn ipmp_illgrp_mark_arpent(
        arg1: *mut ipmp_illgrp_t,
        arg2: *mut ipmp_arpent_t,
    );
}
unsafe extern "C" {
    pub fn ipmp_illgrp_find_ill(
        arg1: *mut ipmp_illgrp_t,
        arg2: *mut uchar_t,
        arg3: uint_t,
    ) -> *mut ill_t;
}
unsafe extern "C" {
    pub fn ipmp_illgrp_link_grp(
        arg1: *mut ipmp_illgrp_t,
        arg2: *mut ipmp_grp_t,
    );
}
unsafe extern "C" {
    pub fn ipmp_illgrp_unlink_grp(
        arg1: *mut ipmp_illgrp_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ipmp_ill_get_ipmp_ifindex(arg1: *const ill_t) -> uint_t;
}
unsafe extern "C" {
    pub fn ipmp_ill_join_illgrp(arg1: *mut ill_t, arg2: *mut ipmp_illgrp_t);
}
unsafe extern "C" {
    pub fn ipmp_ill_leave_illgrp(arg1: *mut ill_t);
}
unsafe extern "C" {
    pub fn ipmp_ill_hold_ipmp_ill(arg1: *mut ill_t) -> *mut ill_t;
}
unsafe extern "C" {
    pub fn ipmp_ill_hold_xmit_ill(
        arg1: *mut ill_t,
        arg2: boolean_t,
    ) -> *mut ill_t;
}
unsafe extern "C" {
    pub fn ipmp_ill_is_active(arg1: *mut ill_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn ipmp_ill_refresh_active(arg1: *mut ill_t);
}
unsafe extern "C" {
    pub fn ipmp_phyint_join_grp(arg1: *mut phyint_t, arg2: *mut ipmp_grp_t);
}
unsafe extern "C" {
    pub fn ipmp_phyint_leave_grp(arg1: *mut phyint_t);
}
unsafe extern "C" {
    pub fn ipmp_phyint_refresh_active(arg1: *mut phyint_t);
}
unsafe extern "C" {
    pub fn ipmp_ipif_bound_ill(arg1: *const ipif_t) -> *mut ill_t;
}
unsafe extern "C" {
    pub fn ipmp_ipif_hold_bound_ill(arg1: *const ipif_t) -> *mut ill_t;
}
unsafe extern "C" {
    pub fn ipmp_ipif_is_dataaddr(arg1: *const ipif_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn ipmp_ipif_is_stubaddr(arg1: *const ipif_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn ipmp_packet_is_probe(
        arg1: *mut mblk_t,
        arg2: *mut ill_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ipmp_ncec_delete_nce(arg1: *mut ncec_t);
}
unsafe extern "C" {
    pub fn ipmp_ncec_refresh_nce(arg1: *mut ncec_t);
}
unsafe extern "C" {
    pub fn conn_drain_insert(arg1: *mut conn_t, arg2: *mut idl_tx_list_t);
}
unsafe extern "C" {
    pub fn conn_setqfull(arg1: *mut conn_t, arg2: *mut boolean_t);
}
unsafe extern "C" {
    pub fn conn_clrqfull(arg1: *mut conn_t, arg2: *mut boolean_t);
}
unsafe extern "C" {
    pub fn conn_ipsec_length(arg1: *mut conn_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_get_dst(arg1: *mut ipha_t) -> ipaddr_t;
}
unsafe extern "C" {
    pub fn ip_get_pmtu(arg1: *mut ip_xmit_attr_t) -> uint_t;
}
unsafe extern "C" {
    pub fn ip_get_base_mtu(arg1: *mut ill_t, arg2: *mut ire_t) -> uint_t;
}
unsafe extern "C" {
    pub fn ip_output_attach_policy(
        arg1: *mut mblk_t,
        arg2: *mut ipha_t,
        arg3: *mut ip6_t,
        arg4: *const conn_t,
        arg5: *mut ip_xmit_attr_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ipsec_out_extra_length(
        arg1: *mut ip_xmit_attr_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ipsec_out_process(
        arg1: *mut mblk_t,
        arg2: *mut ip_xmit_attr_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_output_post_ipsec(
        arg1: *mut mblk_t,
        arg2: *mut ip_xmit_attr_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ipsec_out_to_in(
        arg1: *mut ip_xmit_attr_t,
        ill: *mut ill_t,
        arg2: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ire_cleanup(arg1: *mut ire_t);
}
unsafe extern "C" {
    pub fn ire_inactive(arg1: *mut ire_t);
}
unsafe extern "C" {
    pub fn irb_inactive(arg1: *mut irb_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn ire_unlink(arg1: *mut irb_t) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ip_srcid_insert(
        arg1: *const in6_addr_t,
        arg2: zoneid_t,
        arg3: *mut ip_stack_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_srcid_remove(
        arg1: *const in6_addr_t,
        arg2: zoneid_t,
        arg3: *mut ip_stack_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_srcid_find_id(
        arg1: uint_t,
        arg2: *mut in6_addr_t,
        arg3: zoneid_t,
        arg4: boolean_t,
        arg5: *mut netstack_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ip_srcid_find_addr(
        arg1: *const in6_addr_t,
        arg2: zoneid_t,
        arg3: *mut netstack_t,
    ) -> uint_t;
}
unsafe extern "C" {
    pub fn ipoptp_next(arg1: *mut ipoptp_t) -> u8;
}
unsafe extern "C" {
    pub fn ipoptp_first(arg1: *mut ipoptp_t, arg2: *mut ipha_t) -> u8;
}
unsafe extern "C" {
    pub fn ip_opt_get_user(
        arg1: *mut conn_t,
        arg2: *mut uchar_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ipsec_req_from_conn(
        arg1: *mut conn_t,
        arg2: *mut ipsec_req_t,
        arg3: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_snmp_get(
        q: *mut queue_t,
        mctl: *mut mblk_t,
        level: illumos_sys_hdrs::c_int,
        arg1: boolean_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_snmp_set(
        q: *mut queue_t,
        arg1: illumos_sys_hdrs::c_int,
        arg2: illumos_sys_hdrs::c_int,
        arg3: *mut uchar_t,
        arg4: illumos_sys_hdrs::c_int,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_process_ioctl(
        arg1: *mut ipsq_t,
        arg2: *mut queue_t,
        arg3: *mut mblk_t,
        arg4: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn ip_quiesce_conn(arg1: *mut conn_t);
}
unsafe extern "C" {
    pub fn ip_reprocess_ioctl(
        arg1: *mut ipsq_t,
        arg2: *mut queue_t,
        arg3: *mut mblk_t,
        arg4: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn ip_ioctl_finish(
        arg1: *mut queue_t,
        arg2: *mut mblk_t,
        arg3: illumos_sys_hdrs::c_int,
        arg4: illumos_sys_hdrs::c_int,
        arg5: *mut ipsq_t,
    );
}
unsafe extern "C" {
    pub fn ip_cmpbuf(
        arg1: *const illumos_sys_hdrs::c_void,
        arg2: uint_t,
        arg3: boolean_t,
        arg4: *const illumos_sys_hdrs::c_void,
        arg5: uint_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ip_allocbuf(
        arg1: *mut *mut illumos_sys_hdrs::c_void,
        arg2: *mut uint_t,
        arg3: boolean_t,
        arg4: *const illumos_sys_hdrs::c_void,
        arg5: uint_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ip_savebuf(
        arg1: *mut *mut illumos_sys_hdrs::c_void,
        arg2: *mut uint_t,
        arg3: boolean_t,
        arg4: *const illumos_sys_hdrs::c_void,
        arg5: uint_t,
    );
}
unsafe extern "C" {
    pub fn ipsq_pending_mp_cleanup(
        arg1: *mut ill_t,
        arg2: *mut conn_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn conn_ioctl_cleanup(arg1: *mut conn_t);
}
unsafe extern "C" {
    pub fn ip_unbind(arg1: *mut conn_t);
}
unsafe extern "C" {
    pub fn tnet_init();
}
unsafe extern "C" {
    pub fn tnet_fini();
}
unsafe extern "C" {
    pub static mut cl_inet_isclusterwide: ::core::option::Option<
        unsafe extern "C" fn(
            stack_id: netstackid_t,
            protocol: u8,
            addr_family: sa_family_t,
            laddrp: *mut u8,
            args: *mut illumos_sys_hdrs::c_void,
        ) -> illumos_sys_hdrs::c_int,
    >;
}
unsafe extern "C" {
    pub static mut cl_inet_ipident: ::core::option::Option<
        unsafe extern "C" fn(
            stack_id: netstackid_t,
            protocol: u8,
            addr_family: sa_family_t,
            laddrp: *mut u8,
            faddrp: *mut u8,
            args: *mut illumos_sys_hdrs::c_void,
        ) -> u32,
    >;
}
unsafe extern "C" {
    pub static mut cl_inet_connect2: ::core::option::Option<
        unsafe extern "C" fn(
            stack_id: netstackid_t,
            protocol: u8,
            is_outgoing: boolean_t,
            addr_family: sa_family_t,
            laddrp: *mut u8,
            lport: in_port_t,
            faddrp: *mut u8,
            fport: in_port_t,
            args: *mut illumos_sys_hdrs::c_void,
        ) -> illumos_sys_hdrs::c_int,
    >;
}
unsafe extern "C" {
    pub static mut cl_inet_getspi: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: netstackid_t,
            arg2: u8,
            arg3: *mut u8,
            arg4: usize,
            arg5: *mut illumos_sys_hdrs::c_void,
        ),
    >;
}
unsafe extern "C" {
    pub static mut cl_inet_checkspi: ::core::option::Option<
        unsafe extern "C" fn(
            stack_id: netstackid_t,
            protocol: u8,
            spi: u32,
            args: *mut illumos_sys_hdrs::c_void,
        ) -> illumos_sys_hdrs::c_int,
    >;
}
unsafe extern "C" {
    pub static mut cl_inet_deletespi: ::core::option::Option<
        unsafe extern "C" fn(
            stack_id: netstackid_t,
            protocol: u8,
            spi: u32,
            args: *mut illumos_sys_hdrs::c_void,
        ),
    >;
}
unsafe extern "C" {
    pub static mut cl_inet_idlesa: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: netstackid_t,
            arg2: u8,
            arg3: u32,
            arg4: sa_family_t,
            arg5: in6_addr_t,
            arg6: in6_addr_t,
            arg7: *mut illumos_sys_hdrs::c_void,
        ),
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgtp_filter_ops {
    pub cfo_filter_rev: illumos_sys_hdrs::c_int,
    pub cfo_change_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: netstackid_t,
            arg2: illumos_sys_hdrs::c_int,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cfo_add_dest_v4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: netstackid_t,
            arg2: ipaddr_t,
            arg3: ipaddr_t,
            arg4: ipaddr_t,
            arg5: ipaddr_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cfo_del_dest_v4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: netstackid_t,
            arg2: ipaddr_t,
            arg3: ipaddr_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cfo_add_dest_v6: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: netstackid_t,
            arg2: *mut in6_addr_t,
            arg3: *mut in6_addr_t,
            arg4: *mut in6_addr_t,
            arg5: *mut in6_addr_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cfo_del_dest_v6: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: netstackid_t,
            arg2: *mut in6_addr_t,
            arg3: *mut in6_addr_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cfo_filter: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: netstackid_t,
            arg2: uint_t,
            arg3: *mut mblk_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
    pub cfo_filter_v6: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: netstackid_t,
            arg2: uint_t,
            arg3: *mut ip6_t,
            arg4: *mut ip6_frag_t,
        ) -> illumos_sys_hdrs::c_int,
    >,
}
pub type cgtp_filter_ops_t = cgtp_filter_ops;
unsafe extern "C" {
    pub static mut ip_cgtp_filter_rev: illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_cgtp_filter_supported() -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_cgtp_filter_register(
        arg1: netstackid_t,
        arg2: *mut cgtp_filter_ops_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_cgtp_filter_unregister(
        arg1: netstackid_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_cgtp_filter_is_registered(
        arg1: netstackid_t,
    ) -> illumos_sys_hdrs::c_int;
}
pub const ip_ring_state_t_RR_FREE: ip_ring_state_t = 0;
pub const ip_ring_state_t_RR_SQUEUE_UNBOUND: ip_ring_state_t = 1;
pub const ip_ring_state_t_RR_SQUEUE_BIND_INPROG: ip_ring_state_t = 2;
pub const ip_ring_state_t_RR_SQUEUE_BOUND: ip_ring_state_t = 3;
pub const ip_ring_state_t_RR_FREE_INPROG: ip_ring_state_t = 4;
pub type ip_ring_state_t = illumos_sys_hdrs::c_uint;
pub type ip_mac_intr_disable_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut illumos_sys_hdrs::c_void) -> boolean_t,
>;
pub type ip_mac_intr_enable_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int,
>;
pub type ip_dld_tx_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: *mut mblk_t,
        arg3: u64,
        arg4: u16,
    ) -> ip_mac_tx_cookie_t,
>;
pub type ip_flow_enable_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: ip_mac_tx_cookie_t,
    ),
>;
pub type ip_dld_callb_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: ip_flow_enable_t,
        arg3: *mut illumos_sys_hdrs::c_void,
    ) -> *mut illumos_sys_hdrs::c_void,
>;
pub type ip_dld_fctl_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: ip_mac_tx_cookie_t,
    ) -> boolean_t,
>;
pub type ip_capab_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: uint_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: uint_t,
    ) -> illumos_sys_hdrs::c_int,
>;
pub type ip_mac_rx_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut illumos_sys_hdrs::c_void,
        arg2: usize,
    ) -> *mut mblk_t,
>;
pub type ip_accept_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ill_t,
        arg2: *mut ill_rx_ring_t,
        arg3: *mut squeue_t,
        arg4: *mut mblk_t,
        arg5: *mut *mut mblk_t,
        arg6: *mut uint_t,
    ) -> *mut mblk_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ill_rx_ring {
    pub rr_intr_disable: ip_mac_intr_disable_t,
    pub rr_intr_enable: ip_mac_intr_enable_t,
    pub rr_intr_handle: *mut illumos_sys_hdrs::c_void,
    pub rr_rx: ip_mac_rx_t,
    pub rr_ip_accept: ip_accept_t,
    pub rr_rx_handle: *mut illumos_sys_hdrs::c_void,
    pub rr_sqp: *mut squeue_t,
    pub rr_ill: *mut ill_t,
    pub rr_ring_state: ip_ring_state_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ill_dld_direct_s {
    pub idd_tx_df: ip_dld_tx_t,
    pub idd_tx_dh: *mut illumos_sys_hdrs::c_void,
    pub idd_tx_cb_df: ip_dld_callb_t,
    pub idd_tx_cb_dh: *mut illumos_sys_hdrs::c_void,
    pub idd_tx_fctl_df: ip_dld_fctl_t,
    pub idd_tx_fctl_dh: *mut illumos_sys_hdrs::c_void,
}
pub type ill_dld_direct_t = ill_dld_direct_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ill_dld_poll_s {
    pub idp_ring_tbl: [ill_rx_ring_t; 256usize],
}
pub type ill_dld_poll_t = ill_dld_poll_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ill_dld_capab_s {
    pub idc_capab_df: ip_capab_func_t,
    pub idc_capab_dh: *mut illumos_sys_hdrs::c_void,
    pub idc_direct: ill_dld_direct_t,
    pub idc_poll: ill_dld_poll_t,
}
unsafe extern "C" {
    pub static mut ip_squeue_fanout: boolean_t;
}
unsafe extern "C" {
    pub fn ip_squeue_init(
        arg1: ::core::option::Option<unsafe extern "C" fn(arg1: *mut squeue_t)>,
    );
}
unsafe extern "C" {
    pub fn ip_squeue_random(arg1: uint_t) -> *mut squeue_t;
}
unsafe extern "C" {
    pub fn ip_squeue_get(arg1: *mut ill_rx_ring_t) -> *mut squeue_t;
}
unsafe extern "C" {
    pub fn ip_squeue_getfree(arg1: pri_t) -> *mut squeue_t;
}
unsafe extern "C" {
    pub fn ip_squeue_cpu_move(
        arg1: *mut squeue_t,
        arg2: processorid_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_squeue_add_ring(
        arg1: *mut ill_t,
        arg2: *mut illumos_sys_hdrs::c_void,
    ) -> *mut illumos_sys_hdrs::c_void;
}
unsafe extern "C" {
    pub fn ip_squeue_bind_ring(
        arg1: *mut ill_t,
        arg2: *mut ill_rx_ring_t,
        arg3: processorid_t,
    );
}
unsafe extern "C" {
    pub fn ip_squeue_clean_ring(arg1: *mut ill_t, arg2: *mut ill_rx_ring_t);
}
unsafe extern "C" {
    pub fn ip_squeue_quiesce_ring(arg1: *mut ill_t, arg2: *mut ill_rx_ring_t);
}
unsafe extern "C" {
    pub fn ip_squeue_restart_ring(arg1: *mut ill_t, arg2: *mut ill_rx_ring_t);
}
unsafe extern "C" {
    pub fn ip_squeue_clean_all(arg1: *mut ill_t);
}
unsafe extern "C" {
    pub fn ip_source_routed(
        arg1: *mut ipha_t,
        arg2: *mut ip_stack_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn tcp_wput(
        arg1: *mut queue_t,
        arg2: *mut mblk_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_fill_mtuinfo(
        arg1: *mut conn_t,
        arg2: *mut ip_xmit_attr_t,
        arg3: *mut ip6_mtuinfo,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ipobs_register_hook(
        arg1: *mut netstack_t,
        arg2: pfv_t,
    ) -> *mut hook_t;
}
unsafe extern "C" {
    pub fn ipobs_unregister_hook(arg1: *mut netstack_t, arg2: *mut hook_t);
}
unsafe extern "C" {
    pub fn ipobs_hook(
        arg1: *mut mblk_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: zoneid_t,
        arg4: zoneid_t,
        arg5: *const ill_t,
        arg6: *mut ip_stack_t,
    );
}
pub type ipsq_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ipsq_t,
        arg2: *mut queue_t,
        arg3: *mut mblk_t,
        arg4: *mut illumos_sys_hdrs::c_void,
    ),
>;
unsafe extern "C" {
    pub fn dce_g_init();
}
unsafe extern "C" {
    pub fn dce_g_destroy();
}
unsafe extern "C" {
    pub fn dce_stack_init(arg1: *mut ip_stack_t);
}
unsafe extern "C" {
    pub fn dce_stack_destroy(arg1: *mut ip_stack_t);
}
unsafe extern "C" {
    pub fn dce_cleanup(arg1: uint_t, arg2: *mut ip_stack_t);
}
unsafe extern "C" {
    pub fn dce_get_default(arg1: *mut ip_stack_t) -> *mut dce_t;
}
unsafe extern "C" {
    pub fn dce_lookup_pkt(
        arg1: *mut mblk_t,
        arg2: *mut ip_xmit_attr_t,
        arg3: *mut uint_t,
    ) -> *mut dce_t;
}
unsafe extern "C" {
    pub fn dce_lookup_v4(
        arg1: ipaddr_t,
        arg2: *mut ip_stack_t,
        arg3: *mut uint_t,
    ) -> *mut dce_t;
}
unsafe extern "C" {
    pub fn dce_lookup_v6(
        arg1: *const in6_addr_t,
        arg2: uint_t,
        arg3: *mut ip_stack_t,
        arg4: *mut uint_t,
    ) -> *mut dce_t;
}
unsafe extern "C" {
    pub fn dce_lookup_and_add_v4(
        arg1: ipaddr_t,
        arg2: *mut ip_stack_t,
    ) -> *mut dce_t;
}
unsafe extern "C" {
    pub fn dce_lookup_and_add_v6(
        arg1: *const in6_addr_t,
        arg2: uint_t,
        arg3: *mut ip_stack_t,
    ) -> *mut dce_t;
}
unsafe extern "C" {
    pub fn dce_update_uinfo_v4(
        arg1: ipaddr_t,
        arg2: *mut iulp_t,
        arg3: *mut ip_stack_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn dce_update_uinfo_v6(
        arg1: *const in6_addr_t,
        arg2: uint_t,
        arg3: *mut iulp_t,
        arg4: *mut ip_stack_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn dce_update_uinfo(
        arg1: *const in6_addr_t,
        arg2: uint_t,
        arg3: *mut iulp_t,
        arg4: *mut ip_stack_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn dce_increment_generation(arg1: *mut dce_t);
}
unsafe extern "C" {
    pub fn dce_increment_all_generations(
        arg1: boolean_t,
        arg2: *mut ip_stack_t,
    );
}
unsafe extern "C" {
    pub fn dce_refrele(arg1: *mut dce_t);
}
unsafe extern "C" {
    pub fn dce_refhold(arg1: *mut dce_t);
}
unsafe extern "C" {
    pub fn dce_refrele_notr(arg1: *mut dce_t);
}
unsafe extern "C" {
    pub fn dce_refhold_notr(arg1: *mut dce_t);
}
unsafe extern "C" {
    pub fn ip_snmp_get_mib2_ip_dce(
        arg1: *mut queue_t,
        arg2: *mut mblk_t,
        ipst: *mut ip_stack_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_laddr_verify_v4(
        arg1: ipaddr_t,
        arg2: zoneid_t,
        arg3: *mut ip_stack_t,
        arg4: boolean_t,
    ) -> ip_laddr_t;
}
unsafe extern "C" {
    pub fn ip_laddr_verify_v6(
        arg1: *const in6_addr_t,
        arg2: zoneid_t,
        arg3: *mut ip_stack_t,
        arg4: boolean_t,
        arg5: uint_t,
    ) -> ip_laddr_t;
}
unsafe extern "C" {
    pub fn ip_laddr_fanout_insert(arg1: *mut conn_t)
        -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_verify_src(
        arg1: *mut mblk_t,
        arg2: *mut ip_xmit_attr_t,
        arg3: *mut uint_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ip_verify_ire(
        arg1: *mut mblk_t,
        arg2: *mut ip_xmit_attr_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_xmit_attr_to_mblk(arg1: *mut ip_xmit_attr_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_xmit_attr_from_mblk(
        arg1: *mut mblk_t,
        arg2: *mut ip_xmit_attr_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ip_xmit_attr_free_mblk(arg1: *mut mblk_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_recv_attr_to_mblk(arg1: *mut ip_recv_attr_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_recv_attr_from_mblk(
        arg1: *mut mblk_t,
        arg2: *mut ip_recv_attr_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ip_recv_attr_free_mblk(arg1: *mut mblk_t) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ip_recv_attr_is_mblk(arg1: *mut mblk_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn inet_ntop(
        arg1: illumos_sys_hdrs::c_int,
        arg2: *const illumos_sys_hdrs::c_void,
        arg3: *mut illumos_sys_hdrs::c_char,
        arg4: illumos_sys_hdrs::c_int,
    ) -> *mut illumos_sys_hdrs::c_char;
}
unsafe extern "C" {
    pub fn inet_pton(
        arg1: illumos_sys_hdrs::c_int,
        arg2: *mut illumos_sys_hdrs::c_char,
        arg3: *mut illumos_sys_hdrs::c_void,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub static mut sin_null: sin_t;
}
unsafe extern "C" {
    pub static mut sin6_null: sin6_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct icmp6_hdr {
    pub icmp6_type: u8,
    pub icmp6_code: u8,
    pub icmp6_cksum: u16,
    pub icmp6_dataun: icmp6_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union icmp6_hdr__bindgen_ty_1 {
    pub icmp6_un_data32: [u32; 1usize],
    pub icmp6_un_data16: [u16; 2usize],
    pub icmp6_un_data8: [u8; 4usize],
}
pub type icmp6_t = icmp6_hdr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mld_hdr {
    pub mld_icmp6_hdr: icmp6_hdr,
    pub mld_addr: in6_addr,
}
pub type mld_hdr_t = mld_hdr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mld2q {
    pub mld2q_hdr: mld_hdr_t,
    pub mld2q_sqrv: u8,
    pub mld2q_qqic: u8,
    pub mld2q_numsrc: u16,
}
pub type mld2q_t = mld2q;
pub type mld2r_t = icmp6_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mld2mar {
    pub mld2mar_type: u8,
    pub mld2mar_auxlen: u8,
    pub mld2mar_numsrc: u16,
    pub mld2mar_group: in6_addr,
}
pub type mld2mar_t = mld2mar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct icmp6_router_renum {
    pub rr_hdr: icmp6_hdr,
    pub rr_segnum: u8,
    pub rr_flags: u8,
    pub rr_maxdelay: u16,
    pub rr_reserved: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rr_pco_match {
    pub rpm_code: u8,
    pub rpm_len: u8,
    pub rpm_ordinal: u8,
    pub rpm_matchlen: u8,
    pub rpm_minlen: u8,
    pub rpm_maxlen: u8,
    pub rpm_reserved: u16,
    pub rpm_prefix: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rr_pco_use {
    pub rpu_uselen: u8,
    pub rpu_keeplen: u8,
    pub rpu_ramask: u8,
    pub rpu_raflags: u8,
    pub rpu_vltime: u32,
    pub rpu_pltime: u32,
    pub rpu_flags: u32,
    pub rpu_prefix: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rr_result {
    pub rrr_flags: u16,
    pub rrr_ordinal: u8,
    pub rrr_matchedlen: u8,
    pub rrr_ifid: u32,
    pub rrr_prefix: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nd_router_solicit {
    pub nd_rs_hdr: icmp6_t,
}
pub type nd_router_solicit_t = nd_router_solicit;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nd_router_advert {
    pub nd_ra_hdr: icmp6_t,
    pub nd_ra_reachable: u32,
    pub nd_ra_retransmit: u32,
}
pub type nd_router_advert_t = nd_router_advert;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nd_neighbor_solicit {
    pub nd_ns_hdr: icmp6_t,
    pub nd_ns_target: in6_addr,
}
pub type nd_neighbor_solicit_t = nd_neighbor_solicit;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nd_neighbor_advert {
    pub nd_na_hdr: icmp6_t,
    pub nd_na_target: in6_addr,
}
pub type nd_neighbor_advert_t = nd_neighbor_advert;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nd_redirect {
    pub nd_rd_hdr: icmp6_t,
    pub nd_rd_target: in6_addr,
    pub nd_rd_dst: in6_addr,
}
pub type nd_redirect_t = nd_redirect;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nd_opt_hdr {
    pub nd_opt_type: u8,
    pub nd_opt_len: u8,
}
pub type nd_opt_hdr_t = nd_opt_hdr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nd_opt_prefix_info {
    pub nd_opt_pi_type: u8,
    pub nd_opt_pi_len: u8,
    pub nd_opt_pi_prefix_len: u8,
    pub nd_opt_pi_flags_reserved: u8,
    pub nd_opt_pi_valid_time: u32,
    pub nd_opt_pi_preferred_time: u32,
    pub nd_opt_pi_reserved2: u32,
    pub nd_opt_pi_prefix: in6_addr,
}
pub type nd_opt_prefix_info_t = nd_opt_prefix_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nd_opt_rd_hdr {
    pub nd_opt_rh_type: u8,
    pub nd_opt_rh_len: u8,
    pub nd_opt_rh_reserved1: u16,
    pub nd_opt_rh_reserved2: u32,
}
pub type nd_opt_rd_hdr_t = nd_opt_rd_hdr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nd_opt_mtu {
    pub nd_opt_mtu_type: u8,
    pub nd_opt_mtu_len: u8,
    pub nd_opt_mtu_reserved: u16,
    pub nd_opt_mtu_mtu: u32,
}
pub type nd_opt_mtu_t = nd_opt_mtu;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nd_opt_lla {
    pub nd_opt_lla_type: u8,
    pub nd_opt_lla_len: u8,
    pub nd_opt_lla_hdw_addr: [u8; 64usize],
}
#[repr(C)]
pub struct nd_opt_dns_resolver {
    pub nd_opt_dnsr_type: u8,
    pub nd_opt_dnsr_len: u8,
    pub nd_opt_dnsr_reserved: u16,
    pub nd_opt_dnsr_lifetime: u32,
    pub nd_opt_dnsr_addr: __IncompleteArrayField<in6_addr>,
}
#[repr(C)]
#[derive(Debug)]
pub struct nd_opt_dns_sl {
    pub nd_opt_dnss_type: u8,
    pub nd_opt_dnss_len: u8,
    pub nd_opt_dnss_reserved: u16,
    pub nd_opt_dnss_lifetime: u32,
    pub nd_opt_dnss_names: __IncompleteArrayField<u8>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icmp6_filter {
    pub __icmp6_filt: [u32; 8usize],
}
pub type icmp6_filter_t = icmp6_filter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip2mac {
    pub ip2mac_pa: sockaddr_storage,
    pub ip2mac_ha: sockaddr_dl,
    pub ip2mac_err: uint_t,
    pub ip2mac_ifindex: uint_t,
}
pub type ip2mac_t = ip2mac;
pub type ip2mac_id_t = *mut illumos_sys_hdrs::c_void;
pub type ip2mac_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ip2mac_t,
        arg2: *mut illumos_sys_hdrs::c_void,
    ),
>;
unsafe extern "C" {
    pub fn ip2mac(
        arg1: uint_t,
        arg2: *mut ip2mac_t,
        arg3: ip2mac_callback_t,
        arg4: *mut illumos_sys_hdrs::c_void,
        arg5: zoneid_t,
    ) -> ip2mac_id_t;
}
unsafe extern "C" {
    pub fn ip2mac_cancel(
        arg1: ip2mac_id_t,
        arg2: zoneid_t,
    ) -> illumos_sys_hdrs::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ncec_cb_s {
    pub ncec_cb_node: list_node_t,
    pub ncec_cb_id: *mut illumos_sys_hdrs::c_void,
    pub ncec_cb_flags: u32,
    pub ncec_cb_func: ip2mac_callback_t,
    pub ncec_cb_arg: *mut illumos_sys_hdrs::c_void,
}
pub type ncec_cb_t = ncec_cb_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ncec_s {
    pub ncec_next: *mut ncec_s,
    pub ncec_ptpn: *mut *mut ncec_s,
    pub ncec_ill: *mut ill_s,
    pub ncec_flags: u16,
    pub ncec_state: u16,
    pub ncec_pcnt: i16,
    pub ncec_rcnt: u16,
    pub ncec_addr: in6_addr_t,
    pub ncec_lladdr: *mut uchar_t,
    pub ncec_qd_mp: *mut mblk_t,
    pub ncec_last: u64,
    pub ncec_refcnt: u32,
    pub ncec_lock: kmutex_t,
    pub ncec_unsolicit_count: illumos_sys_hdrs::c_int,
    pub ncec_timeout_id: timeout_id_t,
    pub ncec_ipversion: uchar_t,
    pub ncec_defense_count: uint_t,
    pub ncec_last_time_defended: clock_t,
    pub ncec_init_time: u64,
    pub ncec_trace_disable: boolean_t,
    pub ncec_xmit_interval: clock_t,
    pub ncec_ipst: *mut ip_stack_t,
    pub ncec_cb: list_t,
    pub ncec_cb_walker_cnt: uint_t,
    pub ncec_nprobes: uint_t,
    pub ncec_lladdr_length: uint_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nce_s {
    pub nce_node: list_node_t,
    pub nce_ill: *mut ill_t,
    pub nce_is_condemned: boolean_t,
    pub nce_addr: in6_addr_t,
    pub nce_dlur_mp: *mut mblk_t,
    pub nce_fp_mp: *mut mblk_t,
    pub nce_common: *mut ncec_s,
    pub nce_lock: kmutex_t,
    pub nce_refcnt: u32,
    pub nce_ipif_cnt: uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndp_g_s {
    pub ndp_g_lock: kmutex_t,
    pub nce_hash_tbl: [*mut ncec_t; 256usize],
    pub ndp_g_walker: illumos_sys_hdrs::c_int,
    pub ndp_g_walker_cleanup: boolean_t,
}
pub type ndp_g_t = ndp_g_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nce_hw_map_t {
    pub hwm_addr: ipaddr_t,
    pub hwm_hwlen: uint_t,
    pub hwm_hwaddr: *mut uchar_t,
    pub hwm_flags: illumos_sys_hdrs::c_int,
}
pub type ncec_walk_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ncec_t,
        arg2: *mut illumos_sys_hdrs::c_void,
    ),
>;
unsafe extern "C" {
    pub fn ip_nce_reclaim(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn ncec_delete(arg1: *mut ncec_t);
}
unsafe extern "C" {
    pub fn ncec_delete_per_ill(
        arg1: *mut ncec_t,
        arg2: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn nce_fastpath_update(arg1: *mut ill_t, arg2: *mut mblk_t);
}
unsafe extern "C" {
    pub fn ndp_get_option(
        arg1: *mut nd_opt_hdr_t,
        arg2: illumos_sys_hdrs::c_int,
        arg3: illumos_sys_hdrs::c_int,
    ) -> *mut nd_opt_hdr_t;
}
unsafe extern "C" {
    pub fn ncec_inactive(arg1: *mut ncec_t);
}
unsafe extern "C" {
    pub fn ndp_input(arg1: *mut mblk_t, arg2: *mut ip_recv_attr_t);
}
unsafe extern "C" {
    pub fn ncec_lookup_illgrp_v6(
        arg1: *mut ill_t,
        arg2: *const in6_addr_t,
    ) -> *mut ncec_t;
}
unsafe extern "C" {
    pub fn ncec_lookup_illgrp_v4(
        arg1: *mut ill_t,
        arg2: *const in_addr_t,
    ) -> *mut ncec_t;
}
unsafe extern "C" {
    pub fn nce_lookup_v4(
        arg1: *mut ill_t,
        arg2: *const in_addr_t,
    ) -> *mut nce_t;
}
unsafe extern "C" {
    pub fn nce_lookup_v6(
        arg1: *mut ill_t,
        arg2: *const in6_addr_t,
    ) -> *mut nce_t;
}
unsafe extern "C" {
    pub fn nce_make_unreachable(arg1: *mut ncec_t);
}
unsafe extern "C" {
    pub fn ndp_mcastreq(
        arg1: *mut ill_t,
        arg2: *const in6_addr_t,
        arg3: u32,
        arg4: u32,
        arg5: *mut mblk_t,
    ) -> *mut mblk_t;
}
unsafe extern "C" {
    pub fn ndp_nce_init(
        arg1: *mut ill_t,
        arg2: *const in6_addr_t,
        arg3: illumos_sys_hdrs::c_int,
    ) -> *mut nce_t;
}
unsafe extern "C" {
    pub fn nce_process(
        arg1: *mut ncec_t,
        arg2: *mut uchar_t,
        arg3: u32,
        arg4: boolean_t,
    );
}
unsafe extern "C" {
    pub fn ndp_query(
        arg1: *mut ill_t,
        arg2: *mut lif_nd_req_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ndp_sioc_update(
        arg1: *mut ill_t,
        arg2: *mut lif_nd_req_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ndp_verify_optlen(
        arg1: *mut nd_opt_hdr_t,
        arg2: illumos_sys_hdrs::c_int,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn nce_timer(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn ncec_walk(
        arg1: *mut ill_t,
        arg2: ncec_walk_cb_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_stack_t,
    );
}
unsafe extern "C" {
    pub fn ncec_walk_common(
        arg1: *mut ndp_g_t,
        arg2: *mut ill_t,
        arg3: ncec_walk_cb_t,
        arg4: *mut illumos_sys_hdrs::c_void,
        arg5: boolean_t,
    );
}
unsafe extern "C" {
    pub fn nce_restart_dad(arg1: *mut ncec_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn ndp_resolv_failed(arg1: *mut ncec_t);
}
unsafe extern "C" {
    pub fn arp_resolv_failed(arg1: *mut ncec_t);
}
unsafe extern "C" {
    pub fn nce_fastpath_list_delete(
        arg1: *mut ill_t,
        arg2: *mut ncec_t,
        arg3: *mut list_t,
    );
}
unsafe extern "C" {
    pub fn nce_queue_mp(arg1: *mut ncec_t, arg2: *mut mblk_t, arg3: boolean_t);
}
unsafe extern "C" {
    pub fn nce_update_hw_changed(
        arg1: *mut ncec_t,
        arg2: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn nce_lookup_then_add_v6(
        arg1: *mut ill_t,
        arg2: *mut uchar_t,
        arg3: uint_t,
        arg4: *const in6_addr_t,
        arg5: u16,
        arg6: u16,
        arg7: *mut *mut nce_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn nce_lookup_then_add_v4(
        arg1: *mut ill_t,
        arg2: *mut uchar_t,
        arg3: uint_t,
        arg4: *const in_addr_t,
        arg5: u16,
        arg6: u16,
        arg7: *mut *mut nce_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn nce_cmp_ll_addr(
        arg1: *const ncec_t,
        arg2: *const uchar_t,
        arg3: u32,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn nce_update(arg1: *mut ncec_t, arg2: u16, arg3: *mut uchar_t);
}
unsafe extern "C" {
    pub fn nce_lookup_mapping(
        arg1: *mut ill_t,
        arg2: *const in6_addr_t,
    ) -> *mut nce_t;
}
unsafe extern "C" {
    pub fn nce_restart_timer(arg1: *mut ncec_t, arg2: uint_t);
}
unsafe extern "C" {
    pub fn ncec_refrele(arg1: *mut ncec_t);
}
unsafe extern "C" {
    pub fn ncec_refhold(arg1: *mut ncec_t);
}
unsafe extern "C" {
    pub fn ncec_refrele_notr(arg1: *mut ncec_t);
}
unsafe extern "C" {
    pub fn ncec_refhold_notr(arg1: *mut ncec_t);
}
unsafe extern "C" {
    pub fn nce_resolv_ok(arg1: *mut ncec_t);
}
unsafe extern "C" {
    pub fn ndp_solicit(
        arg1: *mut ncec_t,
        arg2: in6_addr_t,
        arg3: *mut ill_t,
    ) -> u32;
}
unsafe extern "C" {
    pub fn ip_nce_conflict(
        arg1: *mut mblk_t,
        arg2: *mut ip_recv_attr_t,
        arg3: *mut ncec_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ndp_announce(arg1: *mut ncec_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn ip_nce_lookup_and_update(
        arg1: *mut ipaddr_t,
        arg2: *mut ipif_t,
        arg3: *mut ip_stack_t,
        arg4: *mut uchar_t,
        arg5: illumos_sys_hdrs::c_int,
        arg6: illumos_sys_hdrs::c_int,
    );
}
unsafe extern "C" {
    pub fn nce_refrele(arg1: *mut nce_t);
}
unsafe extern "C" {
    pub fn nce_refhold(arg1: *mut nce_t);
}
unsafe extern "C" {
    pub fn nce_delete(arg1: *mut nce_t);
}
unsafe extern "C" {
    pub fn nce_flush(arg1: *mut ill_t, arg2: boolean_t);
}
unsafe extern "C" {
    pub fn nce_walk(
        arg1: *mut ill_t,
        arg2: pfi_t,
        arg3: *mut illumos_sys_hdrs::c_void,
    );
}
unsafe extern "C" {
    pub fn ip_ndp_resolve(arg1: *mut ncec_s);
}
unsafe extern "C" {
    pub fn ip_addr_recover(
        arg1: *mut ipsq_t,
        arg2: *mut queue_t,
        arg3: *mut mblk_t,
        arg4: *mut illumos_sys_hdrs::c_void,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ire_ftable_args_s {
    pub ift_addr_v6: in6_addr_t,
    pub ift_mask_v6: in6_addr_t,
    pub ift_gateway_v6: in6_addr_t,
    pub ift_type: illumos_sys_hdrs::c_int,
    pub ift_ill: *const ill_t,
    pub ift_zoneid: zoneid_t,
    pub ift_tsl: *const ts_label_t,
    pub ift_flags: illumos_sys_hdrs::c_int,
    pub ift_best_ire: *mut ire_t,
}
pub type ire_ftable_args_t = ire_ftable_args_s;
unsafe extern "C" {
    pub fn ip_plen_to_mask(arg1: uint_t) -> ipaddr_t;
}
unsafe extern "C" {
    pub fn ip_plen_to_mask_v6(
        arg1: uint_t,
        arg2: *mut in6_addr_t,
    ) -> *mut in6_addr_t;
}
unsafe extern "C" {
    pub fn ip_ire_advise(
        arg1: *mut queue_t,
        arg2: *mut mblk_t,
        arg3: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_ire_delete(
        arg1: *mut queue_t,
        arg2: *mut mblk_t,
        arg3: *mut cred_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_ire_reclaim(arg1: *mut illumos_sys_hdrs::c_void);
}
unsafe extern "C" {
    pub fn ip_mask_to_plen(arg1: ipaddr_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_mask_to_plen_v6(
        arg1: *const in6_addr_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ire_add(arg1: *mut ire_t) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_add_v6(arg1: *mut ire_t) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_atomic_start(
        irb_ptr: *mut irb_t,
        ire: *mut ire_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ire_atomic_end(irb_ptr: *mut irb_t, ire: *mut ire_t);
}
unsafe extern "C" {
    pub fn ire_create(
        arg1: *mut uchar_t,
        arg2: *mut uchar_t,
        arg3: *mut uchar_t,
        arg4: ushort_t,
        arg5: *mut ill_t,
        arg6: zoneid_t,
        arg7: uint_t,
        arg8: *mut tsol_gc_t,
        arg9: *mut ip_stack_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_create_bcast(
        arg1: *mut ill_t,
        arg2: ipaddr_t,
        arg3: zoneid_t,
        arg4: *mut *mut ire_t,
    ) -> *mut *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_create_if_clone(
        arg1: *mut ire_t,
        arg2: *const in6_addr_t,
        arg3: *mut uint_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_lookup_bcast(
        arg1: *mut ill_t,
        arg2: ipaddr_t,
        arg3: zoneid_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_init_v4(
        arg1: *mut ire_t,
        arg2: *mut uchar_t,
        arg3: *mut uchar_t,
        arg4: *mut uchar_t,
        arg5: ushort_t,
        arg6: *mut ill_t,
        arg7: zoneid_t,
        arg8: uint_t,
        arg9: *mut tsol_gc_t,
        arg10: *mut ip_stack_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ire_init_v6(
        arg1: *mut ire_t,
        arg2: *const in6_addr_t,
        arg3: *const in6_addr_t,
        arg4: *const in6_addr_t,
        arg5: ushort_t,
        arg6: *mut ill_t,
        arg7: zoneid_t,
        arg8: uint_t,
        arg9: *mut tsol_gc_t,
        arg10: *mut ip_stack_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ire_init_common(
        arg1: *mut ire_t,
        arg2: ushort_t,
        arg3: *mut ill_t,
        arg4: zoneid_t,
        arg5: uint_t,
        arg6: uchar_t,
        arg7: *mut tsol_gc_t,
        arg8: *mut ip_stack_t,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ire_create_v6(
        arg1: *const in6_addr_t,
        arg2: *const in6_addr_t,
        arg3: *const in6_addr_t,
        arg4: ushort_t,
        arg5: *mut ill_t,
        arg6: zoneid_t,
        arg7: uint_t,
        arg8: *mut tsol_gc_t,
        arg9: *mut ip_stack_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_delete(arg1: *mut ire_t);
}
unsafe extern "C" {
    pub fn ire_delete_v6(arg1: *mut ire_t);
}
unsafe extern "C" {
    pub fn ire_dep_build(
        arg1: *mut *mut ire_t,
        arg2: *mut uint_t,
        arg3: uint_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ire_dep_delete_if_clone(arg1: *mut ire_t);
}
unsafe extern "C" {
    pub fn ire_dep_incr_generation(arg1: *mut ire_t);
}
unsafe extern "C" {
    pub fn ire_dep_remove(arg1: *mut ire_t);
}
unsafe extern "C" {
    pub fn ire_dep_unbuild(arg1: *mut *mut ire_t, arg2: uint_t);
}
unsafe extern "C" {
    pub fn ire_dep_validate_generations(arg1: *mut ire_t) -> uint_t;
}
unsafe extern "C" {
    pub fn ire_dep_invalidate_generations(arg1: *mut ire_t);
}
unsafe extern "C" {
    pub fn ire_determine_nce_capable(arg1: *mut ire_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn ire_flush_cache_v4(arg1: *mut ire_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn ire_flush_cache_v6(arg1: *mut ire_t, arg2: illumos_sys_hdrs::c_int);
}
unsafe extern "C" {
    pub fn ire_ftable_lookup_v4(
        arg1: ipaddr_t,
        arg2: ipaddr_t,
        arg3: ipaddr_t,
        arg4: illumos_sys_hdrs::c_int,
        arg5: *const ill_t,
        arg6: zoneid_t,
        arg7: *const ts_label_s,
        arg8: illumos_sys_hdrs::c_int,
        arg9: u32,
        arg10: *mut ip_stack_t,
        arg11: *mut uint_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_ftable_lookup_v6(
        arg1: *const in6_addr_t,
        arg2: *const in6_addr_t,
        arg3: *const in6_addr_t,
        arg4: illumos_sys_hdrs::c_int,
        arg5: *const ill_t,
        arg6: zoneid_t,
        arg7: *const ts_label_s,
        arg8: illumos_sys_hdrs::c_int,
        arg9: u32,
        arg10: *mut ip_stack_t,
        arg11: *mut uint_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_ftable_lookup_simple_v4(
        arg1: ipaddr_t,
        arg2: u32,
        arg3: *mut ip_stack_t,
        arg4: *mut uint_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_ftable_lookup_simple_v6(
        arg1: *const in6_addr_t,
        arg2: u32,
        arg3: *mut ip_stack_t,
        arg4: *mut uint_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_gateway_ok_zone_v4(
        arg1: ipaddr_t,
        arg2: zoneid_t,
        arg3: *mut ill_t,
        arg4: *const ts_label_t,
        arg5: *mut ip_stack_t,
        arg6: boolean_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ire_gateway_ok_zone_v6(
        arg1: *const in6_addr_t,
        arg2: zoneid_t,
        arg3: *mut ill_t,
        arg4: *const ts_label_t,
        arg5: *mut ip_stack_t,
        arg6: boolean_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ire_alt_local(
        arg1: *mut ire_t,
        arg2: zoneid_t,
        arg3: *const ts_label_t,
        arg4: *const ill_t,
        arg5: *mut uint_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_lookup_multi_ill_v4(
        arg1: ipaddr_t,
        arg2: zoneid_t,
        arg3: *mut ip_stack_t,
        arg4: *mut boolean_t,
        arg5: *mut ipaddr_t,
    ) -> *mut ill_t;
}
unsafe extern "C" {
    pub fn ire_lookup_multi_ill_v6(
        arg1: *const in6_addr_t,
        arg2: zoneid_t,
        arg3: *mut ip_stack_t,
        arg4: *mut boolean_t,
        arg5: *mut in6_addr_t,
    ) -> *mut ill_t;
}
unsafe extern "C" {
    pub fn ire_nexthop(arg1: *mut ire_t) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_nexthop_ill(arg1: *mut ire_t) -> *mut ill_t;
}
unsafe extern "C" {
    pub fn ire_nce_ill(arg1: *mut ire_t) -> *mut ill_t;
}
unsafe extern "C" {
    pub fn ire_reject(arg1: *mut ip_stack_t, arg2: boolean_t) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_blackhole(arg1: *mut ip_stack_t, arg2: boolean_t) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_multicast(arg1: *mut ill_t) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_recv_forward_v4(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ire_recv_noroute_v4(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ire_recv_broadcast_v4(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ire_recv_multicast_v4(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ire_recv_multirt_v4(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ire_recv_loopback_v4(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ire_recv_local_v4(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ire_recv_noaccept_v4(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ire_recv_forward_v6(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ire_recv_noroute_v6(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ire_recv_multicast_v6(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ire_recv_multirt_v6(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ire_recv_loopback_v6(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ire_recv_local_v6(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn ire_recv_noaccept_v6(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_recv_attr_t,
    );
}
unsafe extern "C" {
    pub fn irb_refhold(arg1: *mut irb_t);
}
unsafe extern "C" {
    pub fn irb_refhold_locked(arg1: *mut irb_t);
}
unsafe extern "C" {
    pub fn irb_refrele(arg1: *mut irb_t);
}
unsafe extern "C" {
    pub fn irb_increment_generation(arg1: *mut irb_t);
}
unsafe extern "C" {
    pub fn ire_refhold(arg1: *mut ire_t);
}
unsafe extern "C" {
    pub fn ire_refhold_notr(arg1: *mut ire_t);
}
unsafe extern "C" {
    pub fn ire_refhold_locked(arg1: *mut ire_t);
}
unsafe extern "C" {
    pub fn ire_refrele(arg1: *mut ire_t);
}
unsafe extern "C" {
    pub fn ire_refrele_notr(arg1: *mut ire_t);
}
unsafe extern "C" {
    pub fn ire_make_condemned(arg1: *mut ire_t);
}
unsafe extern "C" {
    pub fn ire_no_good(arg1: *mut ire_t) -> boolean_t;
}
unsafe extern "C" {
    pub fn ire_handle_condemned_nce(
        arg1: *mut nce_t,
        arg2: *mut ire_t,
        arg3: *mut ipha_t,
        arg4: *mut ip6_t,
        arg5: boolean_t,
    ) -> *mut nce_t;
}
unsafe extern "C" {
    pub fn ire_round_robin(
        arg1: *mut irb_t,
        arg2: *mut ire_ftable_args_t,
        arg3: uint_t,
        arg4: *mut ire_t,
        arg5: *mut ip_stack_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_route_recursive_v4(
        arg1: ipaddr_t,
        arg2: uint_t,
        arg3: *const ill_t,
        arg4: zoneid_t,
        arg5: *const ts_label_t,
        arg6: uint_t,
        arg7: uint_t,
        arg8: u32,
        arg9: *mut ip_stack_t,
        arg10: *mut ipaddr_t,
        arg11: *mut *mut tsol_ire_gw_secattr_t,
        arg12: *mut uint_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_route_recursive_v6(
        arg1: *const in6_addr_t,
        arg2: uint_t,
        arg3: *const ill_t,
        arg4: zoneid_t,
        arg5: *const ts_label_t,
        arg6: uint_t,
        arg7: uint_t,
        arg8: u32,
        arg9: *mut ip_stack_t,
        arg10: *mut in6_addr_t,
        arg11: *mut *mut tsol_ire_gw_secattr_t,
        arg12: *mut uint_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_route_recursive_dstonly_v4(
        arg1: ipaddr_t,
        arg2: uint_t,
        arg3: u32,
        arg4: *mut ip_stack_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_route_recursive_dstonly_v6(
        arg1: *const in6_addr_t,
        arg2: uint_t,
        arg3: u32,
        arg4: *mut ip_stack_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_route_recursive_impl_v4(
        ire: *mut ire_t,
        arg1: ipaddr_t,
        arg2: uint_t,
        arg3: *const ill_t,
        arg4: zoneid_t,
        arg5: *const ts_label_t,
        arg6: uint_t,
        arg7: uint_t,
        arg8: u32,
        arg9: *mut ip_stack_t,
        arg10: *mut ipaddr_t,
        arg11: *mut *mut tsol_ire_gw_secattr_t,
        arg12: *mut uint_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_route_recursive_impl_v6(
        ire: *mut ire_t,
        arg1: *const in6_addr_t,
        arg2: uint_t,
        arg3: *const ill_t,
        arg4: zoneid_t,
        arg5: *const ts_label_t,
        arg6: uint_t,
        arg7: uint_t,
        arg8: u32,
        arg9: *mut ip_stack_t,
        arg10: *mut in6_addr_t,
        arg11: *mut *mut tsol_ire_gw_secattr_t,
        arg12: *mut uint_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_send_local_v4(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_xmit_attr_t,
        arg5: *mut u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ire_send_multirt_v4(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_xmit_attr_t,
        arg5: *mut u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ire_send_noroute_v4(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_xmit_attr_t,
        arg5: *mut u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ire_send_multicast_v4(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_xmit_attr_t,
        arg5: *mut u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ire_send_broadcast_v4(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_xmit_attr_t,
        arg5: *mut u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ire_send_wire_v4(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_xmit_attr_t,
        arg5: *mut u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ire_send_local_v6(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_xmit_attr_t,
        arg5: *mut u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ire_send_multirt_v6(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_xmit_attr_t,
        arg5: *mut u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ire_send_noroute_v6(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_xmit_attr_t,
        arg5: *mut u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ire_send_multicast_v6(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_xmit_attr_t,
        arg5: *mut u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ire_send_wire_v6(
        arg1: *mut ire_t,
        arg2: *mut mblk_t,
        arg3: *mut illumos_sys_hdrs::c_void,
        arg4: *mut ip_xmit_attr_t,
        arg5: *mut u32,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ire_to_nce_pkt(arg1: *mut ire_t, arg2: *mut mblk_t) -> *mut nce_t;
}
unsafe extern "C" {
    pub fn ire_to_nce(
        arg1: *mut ire_t,
        arg2: ipaddr_t,
        arg3: *const in6_addr_t,
    ) -> *mut nce_t;
}
unsafe extern "C" {
    pub fn ip_xmit(
        arg1: *mut mblk_t,
        arg2: *mut nce_s,
        arg3: iaflags_t,
        arg4: uint_t,
        arg5: u32,
        arg6: zoneid_t,
        arg7: zoneid_t,
        arg8: *mut usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_postfrag_loopcheck(
        arg1: *mut mblk_t,
        arg2: *mut nce_s,
        arg3: iaflags_t,
        arg4: uint_t,
        arg5: u32,
        arg6: zoneid_t,
        arg7: zoneid_t,
        arg8: *mut usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_postfrag_multirt_v4(
        arg1: *mut mblk_t,
        arg2: *mut nce_s,
        arg3: iaflags_t,
        arg4: uint_t,
        arg5: u32,
        arg6: zoneid_t,
        arg7: zoneid_t,
        arg8: *mut usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_postfrag_multirt_v6(
        arg1: *mut mblk_t,
        arg2: *mut nce_s,
        arg3: iaflags_t,
        arg4: uint_t,
        arg5: u32,
        arg6: zoneid_t,
        arg7: zoneid_t,
        arg8: *mut usize,
    ) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_postfrag_loopback(
        arg1: *mut mblk_t,
        arg2: *mut nce_s,
        arg3: iaflags_t,
        arg4: uint_t,
        arg5: zoneid_t,
    );
}
unsafe extern "C" {
    pub fn ire_revalidate_nce(arg1: *mut ire_t) -> illumos_sys_hdrs::c_int;
}
unsafe extern "C" {
    pub fn ip_select_route_pkt(
        arg1: *mut mblk_t,
        arg2: *mut ip_xmit_attr_t,
        arg3: *mut uint_t,
        arg4: *mut illumos_sys_hdrs::c_int,
        arg5: *mut boolean_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ip_select_route(
        arg1: *const in6_addr_t,
        arg2: in6_addr_t,
        arg3: *mut ip_xmit_attr_t,
        arg4: *mut uint_t,
        arg5: *mut in6_addr_t,
        arg6: *mut illumos_sys_hdrs::c_int,
        arg7: *mut boolean_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ip_select_route_v4(
        arg1: ipaddr_t,
        arg2: ipaddr_t,
        arg3: *mut ip_xmit_attr_t,
        arg4: *mut uint_t,
        arg5: *mut ipaddr_t,
        arg6: *mut illumos_sys_hdrs::c_int,
        arg7: *mut boolean_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ip_select_route_v6(
        arg1: *const in6_addr_t,
        arg2: in6_addr_t,
        arg3: *mut ip_xmit_attr_t,
        arg4: *mut uint_t,
        arg5: *mut in6_addr_t,
        arg6: *mut illumos_sys_hdrs::c_int,
        arg7: *mut boolean_t,
    ) -> *mut ire_t;
}
unsafe extern "C" {
    pub fn ire_walk(
        arg1: pfv_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: *mut ip_stack_t,
    );
}
unsafe extern "C" {
    pub fn ire_walk_ill(
        arg1: uint_t,
        arg2: uint_t,
        arg3: pfv_t,
        arg4: *mut illumos_sys_hdrs::c_void,
        arg5: *mut ill_t,
    );
}
unsafe extern "C" {
    pub fn ire_walk_v4(
        arg1: pfv_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: zoneid_t,
        arg4: *mut ip_stack_t,
    );
}
unsafe extern "C" {
    pub fn ire_walk_ill_tables(
        match_flags: uint_t,
        ire_type: uint_t,
        func: pfv_t,
        arg: *mut illumos_sys_hdrs::c_void,
        ftbl_sz: usize,
        htbl_sz: usize,
        ipftbl: *mut *mut irb_t,
        ill: *mut ill_t,
        zoneid: zoneid_t,
        arg1: *mut ip_stack_t,
    );
}
unsafe extern "C" {
    pub fn ire_walk_v6(
        arg1: pfv_t,
        arg2: *mut illumos_sys_hdrs::c_void,
        arg3: zoneid_t,
        arg4: *mut ip_stack_t,
    );
}
unsafe extern "C" {
    pub fn ire_match_args(
        arg1: *mut ire_t,
        arg2: ipaddr_t,
        arg3: ipaddr_t,
        arg4: ipaddr_t,
        arg5: illumos_sys_hdrs::c_int,
        arg6: *const ill_t,
        arg7: zoneid_t,
        arg8: *const ts_label_s,
        arg9: illumos_sys_hdrs::c_int,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ire_match_args_v6(
        arg1: *mut ire_t,
        arg2: *const in6_addr_t,
        arg3: *const in6_addr_t,
        arg4: *const in6_addr_t,
        arg5: illumos_sys_hdrs::c_int,
        arg6: *const ill_t,
        arg7: zoneid_t,
        arg8: *const ts_label_t,
        arg9: illumos_sys_hdrs::c_int,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn arp_nce_init(
        arg1: *mut ill_t,
        arg2: in_addr_t,
        arg3: illumos_sys_hdrs::c_int,
    ) -> *mut nce_s;
}
unsafe extern "C" {
    pub fn ire_walk_ill_match(
        arg1: uint_t,
        arg2: uint_t,
        arg3: *mut ire_t,
        arg4: *mut ill_t,
        arg5: zoneid_t,
        arg6: *mut ip_stack_t,
    ) -> boolean_t;
}
unsafe extern "C" {
    pub fn ire_increment_generation(arg1: *mut ire_t);
}
unsafe extern "C" {
    pub fn ire_increment_multicast_generation(
        arg1: *mut ip_stack_t,
        arg2: boolean_t,
    );
}
unsafe extern "C" {
    pub fn ire_rebind(arg1: *mut ire_t);
}
unsafe extern "C" {
    pub fn ire_clone_verify(arg1: *mut ire_t) -> boolean_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ct_template {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct contract {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psinfo {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _sobj_ops {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_ops {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lgrp_ld {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_audit_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollstate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollcache {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _disp {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct door_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sc_shared {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpupart {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sleepq {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dls_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iptun_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct str_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct neti_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arp_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icmp_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sctp_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rts_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipsec_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct keysock_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spd_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipsecah_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipsecesp_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipnet_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ilb_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dinode {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stdata {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filock {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shrlocklist {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct polldat {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct syncq {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fmodsw_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_stat {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fthdr {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct map {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_prop_info_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct connf_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcb_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_asp {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrtstat {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vif {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mfcb {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tbf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __ldi_ident {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct portfd {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sess {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct door_node {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct p_audit_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aio {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lwpchan_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sc_page_ctl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ct_equeue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cont_process {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: illumos_sys_hdrs::c_uint,
    pub fp_offset: illumos_sys_hdrs::c_uint,
    pub overflow_arg_area: *mut illumos_sys_hdrs::c_void,
    pub reg_save_area: *mut illumos_sys_hdrs::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipsa_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isaf_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipsid_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arl_ill_common_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipsec_policy_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipsec_action_s {
    pub _address: u8,
}
