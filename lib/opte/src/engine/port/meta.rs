// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Copyright 2026 Oxide Computer Company

use alloc::borrow::Cow;
use alloc::collections::BTreeMap;
use alloc::string::String;
use core::marker::PhantomData;

/// A value meant to be used in the [`ActionMeta`] map.
///
/// The purpose of this trait is to define the value's key as well
/// as serialization to/from strings. These are like Display and
/// FromStr; but here their focus is on unambiguous parsing. That
/// is, we can't necessarily rely on a type's Display impl being
/// good for serializing to a metadata string, but at the same
/// time we don't want to force its Display to have to work in
/// this constraint.
///
/// A value doesn't have to implement this type; there is nothing
/// that enforces the strings stored in [`ActionMeta`] are strings
/// generated by this trait impl. It's just a convenient way to
/// mark and implement values meant to be used as action metadata.
pub trait ActionMetaValue: Sized {
    const KEY: &'static str;

    fn key(&self) -> Cow<'static, str> {
        Cow::Borrowed(Self::KEY)
    }

    /// Create a representation of the value to be used in
    /// [`ActionMeta`].
    fn as_meta(&self) -> Cow<'static, str>;

    /// Attempt to create a value assuming that `s` was created
    /// with [`ActionMetaValue::as_meta`].
    fn from_meta(s: &str) -> Result<Self, String>;
}

/// The action metadata map.
///
/// This metadata is accessible by all actions during layer
/// processing and acts as a form of inter-action communication.
/// Given that packets and their metadata are immutable (outside of
/// reified header transforms), this also allows actions to inform
/// OPTE of facts about a path or destination (e.g., MTU).
///
/// Action metadata is nothing more than a map of string keys
/// to string values. It is up to the actions to decide what these strings
/// mean. However, *all keys prefaced with "opte:" are reserved for use by
/// operations on `ActionMeta`*, and map to functionality in OPTE itself
/// rather than a given dataplane design.
#[derive(Default)]
pub struct ActionMeta {
    inner: BTreeMap<Cow<'static, str>, Cow<'static, str>>,
}

impl ActionMeta {
    pub fn new() -> Self {
        Self::default()
    }

    /// Clear all entries.
    pub fn clear(&mut self) {
        self.inner.clear();
    }

    /// Insert the key-value pair into the map, replacing any
    /// existing key-value pair. Return the value being replaced,
    /// or `None`.
    pub fn insert(
        &mut self,
        key: Cow<'static, str>,
        val: Cow<'static, str>,
    ) -> Option<Cow<'static, str>> {
        self.inner.insert(key, val)
    }

    /// Insert a value with a type-determined key into the map,
    /// replacing any existing key-value pair. Return the value
    /// being replaced, or `None`.
    pub fn insert_typed(
        &mut self,
        val: &impl ActionMetaValue,
    ) -> Option<Cow<'static, str>> {
        self.insert(val.key(), val.as_meta())
    }

    /// Remove the key-value pair with the specified key. Return
    /// the value, or `None` if no such entry exists.
    pub fn remove(&mut self, key: &str) -> Option<Cow<'static, str>> {
        self.inner.remove(key)
    }

    /// Get a reference to the value with the given key, or `None`
    /// if no such entry exists.
    pub fn get(&self, key: &str) -> Option<&str> {
        self.inner.get(key).map(|v| &**v)
    }

    /// Get a reference to the value at a well known key key, or `None`
    /// if no such entry exists.
    pub fn get_typed<T: ActionMetaValue>(
        &self,
    ) -> Result<T, ActionMetaError<'_, T>> {
        let raw_val =
            self.get(T::KEY).ok_or(ActionMetaError::NotFound(PhantomData))?;

        T::from_meta(raw_val)
            .map_err(|err| ActionMetaError::ParseFailed { raw_val, err })
    }

    /// Records whether this packet's destination can be reached using only
    /// internal/private paths.
    ///
    /// The dataplane may use this to choose a larger (jumbo-frame) MSS for
    /// TCP segmentation, or rely on other aspects of its internal network.
    pub fn set_internal_target(&mut self, val: bool) {
        _ = self.insert_typed(&InternalTarget(val));
    }

    /// Returns whether this packet's destination can be reached using only
    /// internal/private paths.
    pub fn is_internal_target(&self) -> bool {
        self.get_typed::<InternalTarget>().unwrap_or_default().0
    }
}

/// Failure modes when reading a target `impl ActionMetaValue` from [`ActionMeta`].
#[derive(Debug)]
pub enum ActionMetaError<'a, T> {
    /// No value was stored using the type's well-known key.
    NotFound(PhantomData<T>),
    /// The stored value could not be deserialised into the requested type.
    ParseFailed { raw_val: &'a str, err: String },
}

impl<'a, T: core::fmt::Debug> core::error::Error for ActionMetaError<'a, T> {}

impl<'a, T> core::fmt::Display for ActionMetaError<'a, T> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            ActionMetaError::NotFound(_) => write!(
                f,
                "no {} metadata entry found",
                core::any::type_name::<T>()
            ),
            ActionMetaError::ParseFailed { raw_val, err } => {
                write!(f, "failed to parse metadata entry '{raw_val}': {err}")
            }
        }
    }
}

#[derive(Copy, Clone, Default)]
struct InternalTarget(bool);

impl ActionMetaValue for InternalTarget {
    const KEY: &'static str = "opte:internal-target";

    fn as_meta(&self) -> Cow<'static, str> {
        (if self.0 { "1" } else { "0" }).into()
    }

    fn from_meta(s: &str) -> Result<Self, String> {
        match s {
            "1" => Ok(Self(true)),
            "0" => Ok(Self(false)),
            s => Err(format!("value `{s}` is illegal for InternalTarget")),
        }
    }
}
