// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Copyright 2025 Oxide Computer Company

use alloc::borrow::Cow;
use alloc::collections::BTreeMap;
use alloc::string::String;

/// A value meant to be used in the [`ActionMeta`] map.
///
/// The purpose of this trait is to define the value's key as well
/// as serialization to/from strings. These are like Display and
/// FromStr; but here their focus is on unambiguous parsing. That
/// is, we can't necessarily rely on a type's Display impl being
/// good for serializing to a metadata string, but at the same
/// time we don't want to force its Display to have to work in
/// this constraint.
///
/// A value doesn't have to implement this type; there is nothing
/// that enforces the strings stored in [`ActionMeta`] are strings
/// generated by this trait impl. It's just a convenient way to
/// mark and implement values meant to be used as action metadata.
pub trait ActionMetaValue: Sized {
    const KEY: &'static str;

    fn key(&self) -> Cow<'static, str> {
        Cow::Borrowed(Self::KEY)
    }

    /// Create a representation of the value to be used in
    /// [`ActionMeta`].
    fn as_meta(&self) -> Cow<'static, str>;

    /// Attempt to create a value assuming that `s` was created
    /// with [`Self::as_meta()`].
    fn from_meta(s: &str) -> Result<Self, String>;
}

/// The action metadata map.
///
/// This metadata is accessible by all actions during layer
/// processing and acts as a form of inter-action communication.
/// Given that packets and their metadata are immutable (outside of
/// reified header transforms), this also allows actions to inform
/// OPTE of facts about a path or destination (e.g., MTU).
///
/// Action metadata is nothing more than a map of string keys
/// to string values. It is up to the actions to decide what these strings
/// mean. However, *all keys prefaced with "opte:" are reserved for use by
/// operations on `ActionMeta`*, and map to functionality in OPTE itself
/// rather than a given dataplane design.
#[derive(Default)]
pub struct ActionMeta {
    inner: BTreeMap<Cow<'static, str>, Cow<'static, str>>,
}

impl ActionMeta {
    pub fn new() -> Self {
        Self::default()
    }

    /// Clear all entries.
    pub fn clear(&mut self) {
        self.inner.clear();
    }

    /// Insert the key-value pair into the map, replacing any
    /// existing key-value pair. Return the value being replaced,
    /// or `None`.
    pub fn insert(
        &mut self,
        key: Cow<'static, str>,
        val: Cow<'static, str>,
    ) -> Option<Cow<'static, str>> {
        self.inner.insert(key, val)
    }

    /// Remove the key-value pair with the specified key. Return
    /// the value, or `None` if no such entry exists.
    pub fn remove(&mut self, key: &str) -> Option<Cow<'static, str>> {
        self.inner.remove(key)
    }

    /// Get a reference to the value with the given key, or `None`
    /// if no such entry exists.
    pub fn get(&self, key: &str) -> Option<&str> {
        self.inner.get(key).map(|v| &**v)
    }

    /// Records whether this packet's destination can be reached using only
    /// internal/private paths.
    ///
    /// The dataplane may use this to choose a larger (jumbo-frame) MSS for
    /// TCP segmentation, or rely on other aspects of its internal network.
    pub fn set_internal_target(&mut self, val: bool) {
        _ = self
            .insert(InternalTarget::KEY.into(), InternalTarget(val).as_meta());
    }

    /// Returns whether this packet's destination can be reached using only
    /// internal/private paths.
    pub fn is_internal_target(&self) -> bool {
        self.get(InternalTarget::KEY)
            .and_then(|v| InternalTarget::from_meta(v).ok())
            .unwrap_or_default()
            .0
    }
}

#[derive(Copy, Clone, Default)]
struct InternalTarget(bool);

impl ActionMetaValue for InternalTarget {
    const KEY: &'static str = "opte:internal-target";

    fn as_meta(&self) -> Cow<'static, str> {
        (if self.0 { "1" } else { "0" }).into()
    }

    fn from_meta(s: &str) -> Result<Self, String> {
        match s {
            "1" => Ok(Self(true)),
            "0" => Ok(Self(false)),
            s => Err(format!("value `{s}` is illegal for InternalTarget")),
        }
    }
}
